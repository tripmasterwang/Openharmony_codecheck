[
    {
        "规则名称": "WordsTool.52 CoreML",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.282 不会更便宜了",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.8 aidl",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.STD.07-CPP 禁止使用std::string存储敏感信息",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "如下代码中，Foo函数中获取密码，保存到std::string变量password中，随后传递给VerifyPassword函数，在这个过程中，password实际上在内存中出现了两份。\n```CPP\nbool VerifyPassword(std::string password)\n{\n  ...\n}\nvoid Foo()\n{\n    std::string password = GetPassword();\n    if (!VerifyPassword(password)) {\n      ... // 错误处理\n    }\n    ...\n}\n```",
        "修改建议": "严禁使用string类存储敏感信息，关键字包括password、psw、pwd、passwd",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "226"
    },
    {
        "规则名称": "G.PRE.13 所有#else、#elif、#endif和与之对应的#if、#ifdef、#ifndef预处理指令应出现在同一文件中【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：#endif在另一个文件中\r\n- 修复示例：\r\n\r\n```cpp\r\n// sample.h 开始\r\n#if defined(__VXWORKS__)\r\n#include \"vx_config.h\"\r\n...\r\n#endif // 符合：预处理指令在同一个文件中闭合\r\n// sample.h 结束\r\n```",
        "错误示例": "##### 场景1：#endif在另一个文件中\r\n- 错误示例：\r\n\r\n```cpp\r\n// sample.h 开始\r\n#if defined(__VXWORKS__)  // 未在相同文件中闭合该预处理块\r\n#include \"vx_config.h\"\r\n\r\n// 不符合：这里结束前，本应当有 #endif 与前面的 #if defined 形成闭合\r\n// sample.h 结束\r\n```",
        "修改建议": "修改预处理指令在同一个文件中闭合。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "150"
    },
    {
        "规则名称": "G.FMT.03 使用统一的大括号换行风格【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：选择K&R风格，但是使用时没有保持风格一致\r\n- 修复示例：选择并统一使用K&R风格。\r\n\r\n```c\r\nstruct MyType {     // 符合：跟随语句放行末，前置1空格\r\n    ...\r\n};                  // 符合：右大括号后面紧跟分号\r\n\r\nint Foo(int a)\r\n{                   // 符合：函数左大括号独占一行，放行首\r\n    if (a > 0) {    // 符合：左大括号跟随语句放行末，前置1空格\r\n        ...\r\n    } else {        // 符合：右大括号、\"else\"、以及后续的左大括号均在同一行\r\n        ...\r\n    }\r\n    ...\r\n}                   // 符合：右大括号独占一行\r\n```\r\n##### 场景2：选择Allman风格，但是使用时没有保持风格一致\r\n- 修复示例：选择并统一使用Allman风格。\r\n\r\n```c\r\nstruct MyType\r\n{               // 符合：另起并独占一行\r\n    ...\r\n};\r\nint Foo(int a)\r\n{               // 符合：左大括另起并独占一行\r\n    if (a > 0)\r\n    {\r\n        ...\r\n    }\r\n    else        // 符合：前后的左右大括号均独占一行，所以 'else' 也只能独占一行\r\n    {\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：选择K&R风格，但是使用时没有保持风格一致\r\n- 错误示例：\r\n\r\n```c\r\nstruct MyType       // 不符合\r\n{\r\n    ...\r\n};\r\n\r\nint Foo(int a) {    // 不符合\r\n    if (a > 0)      // 不符合\r\n    {\r\n        ...\r\n    } else          // 不符合\r\n    {\r\n        ...\r\n    }\r\n    ... }           // 不符合\r\n```\r\n##### 场景2：选择Allman风格，但是使用时没有保持风格一致\r\n- 错误示例：\r\n\r\n```c\r\nstruct MyType {     // 不符合\r\n    ...\r\n};\r\n\r\nint Foo(int a) {    // 不符合\r\n    if (a > 0)\r\n    {\r\n        ...\r\n    } else {        // 不符合\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "修改建议": "建议通过格式化工具自动修复。\r\n使用K&R风格或者Allman风格，并保持风格一致。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.252 独一无二",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.MEM.04 内存中的敏感信息使用完毕后立即清0",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码示例中，为了防止信息泄露，应先清除包含敏感信息的动态内存（用'\\0'字符填充空间），然后再释放它。\n```c\nchar *secret = NULL;\n/*\n* 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符，\n* 并且以null终止的字节字符串\n*/\nsize_t size = strlen(secret);\nchar *newSecret = NULL;\nnewSecret = (char *)malloc(size + 1);\nif (newSecret == NULL) {\n    ... // 错误处理\n} else {\n    errno_t ret = strcpy_s(newSecret, size + 1, secret);\n    ... // 处理 ret\n\n    ... // 处理 newSecret...\n\n    (void)memset_s(newSecret, size + 1, 0, size + 1);\n    free(newSecret);\n    newSecret = NULL;\n}\n```",
        "错误示例": "通常内存在释放前不需要清除内存数据，因为这样在运行时会增加额外开销，所以在这段内存被释放之后，之前的数据还是会保留在其中。如果这段内存中的数据包含敏感信息，则可能会意外泄露敏感信息。为了防止敏感信息泄露，必须先清除内存中的敏感信息，然后再释放。\n\n在如下代码示例中，存储在所引用的动态内存中的敏感信息secret被复制到新动态分配的缓冲区newSecret，最终通过free()释放。因为释放前未清除这块内存数据，这块内存可能被重新分配到程序的另一部分，之前存储在newSecret中的敏感信息可能会无意中被泄露。\n\n```C\nchar *secret = NULL;\n/*\n* 假设 secret 指向敏感信息，敏感信息的内容是长度小于SIZE_MAX个字符，\n* 并且以null终止的字节字符串\n*/\nsize_t size = strlen(secret);\nchar *newSecret = NULL;\nnewSecret = (char *)malloc(size + 1);\nif (newSecret == NULL) {\n    ... // 错误处理\n} else {\n    errno_t ret = strcpy_s(newSecret, size + 1, secret);\n    ... // 处理 ret\n    ... // 处理 newSecret...\n    free(newSecret);\n    newSecret = NULL;\n}\n...\n```",
        "修改建议": "内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "226"
    },
    {
        "规则名称": "G.FUU.13 禁止封装安全函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "1.使用类似危险函数的接口封装安全函数，destMax与count参数使用相同参数\n```C\nvoid XXX_memcpy(void *dest, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count); \n  ...\n}\n```\n\n2.使用函数简单封装安全函数，封装函数的接口入参类型与安全函数入参相同，但封装函数内调用安全函数时destMax与count参数使用相同参数。\n```C\nerrno_t XXX_memcpy_s(void *dest, size_t destMax, const void *src, size_t count)\n{\n  ...\n  memcpy_s(dest, count, src, count);\n  ...\n}\n```\n\n3.使用类似安全函数的名字的函数，但是参数与安全函数不同\n```C\nerrno_t XXX_memcpy_s(void *dest, const void *src, size_t count)\n{\n  ...\n}\n```\n\n4.将函数的名字命名为类似安全函数(函数名称内包含安全函数的名字），但实现为危险函数。\n```C\nerrno_t XXX_memcpy_s(void *dest, size_t destmax, const void *src, size_t count)\n{\n  ...\n  memcpy(dest, src, count);\n  ...\n}\n```\n\n5.用函数实现自定义不安全函数\n```C\nerrno_t XXX_strncpy(char *dest, size_t destMax, const char *src)\n{\n  ...\n}\n```",
        "修改建议": "对安全函数做封装时，正确理解destMax的用法，不要用count替代destMax",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--类型转换【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：被强制转换的变量与类型之间存在空格\r\n- 修复示例1：\r\n\r\n```cpp\r\nuint16_t number = ...\r\nuint32_t newNumber = (uint32_t)number; // 符合\r\n```",
        "错误示例": "##### 场景1：被强制转换的变量与类型之间存在空格\r\n- 错误示例：\r\n\r\n```cpp\r\nuint16_t number = ...\r\nuint32_t newNumber = (uint32_t) number; // 不符合：'(uint32_t)'和number之间存在空格\r\n```",
        "修改建议": "移除被强制转换的变量与类型之间多余的空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.231 一流",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.38-CPP switch语句中至少有两个条件分支",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下的代码中，存在多个条件分支。\n\n```cpp\nswitch (color) {\n    case Color::RED:\n        DoRedThing();\n        break;\n    case Color::GREEN:\n        DoGreenThing();\n        break;\n    case Color::BLUE:\n        DoBlueThing();\n        break;\n    default:                \n        DoDefault();\n        break;\n}\n```",
        "错误示例": "如下代码中，条件分支少于两个。\n\n```cpp\nswitch (color) {\n    default:         // 不符合：switch是多余的  \n        DoDefault();\n        break;\n}\n```\n\n```cpp\nswitch (color) {\n    case Color::RED:\n    default:         // 不符合：switch是多余的  \n        DoDefault();\n        break;\n}\n```",
        "修改建议": "switch至少要有两个分支，单分支的情况可以改为if语句。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "187,1071,1076"
    },
    {
        "规则名称": "WordsTool.190 V8",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.222 最受欢迎",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.109 Intellj",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.130 low memory killer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.35-CPP 使用nullptr作为空指针常量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "NullMacros:\"\";AllowedNullMacros:\"\"",
        "正确示例": "##### 场景1：使用定义为`((void*)0)`的`NULL`宏来表示空指针常量\r\n- 修复示例：\r\n\r\n```cpp\r\nchar* str = nullptr; // 符合\r\n\r\nvoid(C::*pmf)() = &C::Fun;\r\nif (pmf == nullptr) { // 符合\r\n    ...\r\n}\r\n```\r\n##### 场景2：使用常量`0`来表示空指针常量容易引起歧义。\r\n- 修复示例：\r\n\r\n```cpp\r\nauto result = Find(id);\r\nif (result == nullptr) { // 符合：Find() 返回的是“指针”\r\n    ...\r\n}\r\n```\r\n##### 场景3：使用常量`0`或定义常量`0`的`NULL`宏来表示空指针常量，导致调用的函数不符合预期。\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid F(int);\r\nvoid F(int*);\r\nF(nullptr);           // 符合： 调用 F(int*)\r\n```",
        "错误示例": "##### 场景1：使用定义为`((void*)0)`的`NULL`宏来表示空指针常量\r\n- 错误示例：\r\n\r\n```cpp\r\n#define NULL ((void*)0)\r\n\r\nchar* str = NULL; // 不符合：编译错误，void* 不能自动转换为 char*\r\n\r\nvoid(C::*pmf)() = &C::Fun;\r\nif (pmf == NULL) { // 不符合：编译错误，void* 不能自动转换为指向成员函数的指针\r\n    ...\r\n}\r\n```\r\n##### 场景2：使用常量`0`来表示空指针常量容易引起歧义。\r\n- 错误示例：\r\n\r\n```cpp\r\nauto result = Find(id);\r\nif (result == 0) { // 不符合：Find() 返回的是“指针”还是“整数”?\r\n    ...\r\n}\r\n```\r\n##### 场景3：使用常量`0`或定义常量`0`的`NULL`宏来表示空指针常量，导致调用的函数不符合预期。\r\n- 错误示例：\r\n\r\n```cpp\r\n#define NULL (0)\r\nvoid F(int);\r\nvoid F(int*);\r\nF(0);                 // 不符合： 调用 F(int)，而非 F(int*)\r\nF(NULL);              // 不符合： 调用 F(int)，而非 F(int*)\r\n```",
        "修改建议": "使用nullptr替换空指针常量。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1024"
    },
    {
        "规则名称": "WordsTool.220 最高级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.38 CarHvacManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "弱加密算法【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "使用了不安全的随机算法MD5、EVP_sha、xx_ecb、RSA_padding_add_XXX\n```C\nvoid weakEncryption_bad_01()\n{\n    char* ptr = xy_DES_C;\n    // POTENTIAL FLAW:Insecure algorithm 'MD5' is called. It is recommended to use strong encryption algorithm.\n    MD5(A, B, C);\n    // POTENTIAL FLAW:Insecure algorithm 'EVP_sha' is called. It is recommended to use strong encryption algorithm.\n    EVP_sha(xy_DES_C, y, z);\n    // POTENTIAL FLAW:Insecure algorithm 'xx_ecb' is called. It is recommended to use strong encryption algorithm.\n    xx_ecb(a, b, c);\n    // POTENTIAL FLAW:Insecure algorithm 'RSA_padding_add_XXX' is called. It is recommended to use strong encryption\n    // algorithm.\n    RSA_padding_add_XXX(ptr, ptr);\n}\n```",
        "修改建议": "使用安全的加密函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1240"
    },
    {
        "规则名称": "WordsTool.303 色情",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.10 Android",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.6 Activity",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.117 Javap",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.29-CPP 比较两个表达式时，左侧倾向于变化，右侧倾向于不变",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nif (value == MAX) {\n    ...\n}\n\nif (value < MAX) {\n    ...\n}\n```",
        "错误示例": NaN,
        "修改建议": "将变量放在比较表达式左侧",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.RES.05-CPP 当lambda会逃逸出函数外面时，禁止按引用捕获局部变量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "WhiteListFuncs:\"\"",
        "正确示例": "##### 场景1：lambda按引用捕获局部变量\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int local = 0;\r\n    // 符合：按值捕获 local, 在Process() 调用过程中，local 总是有效的\r\n    threadPool.QueueWork([local] { Process(local); });\r\n}\r\n```",
        "错误示例": "##### 场景1：lambda按引用捕获局部变量\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int local = 0;\r\n    // 不符合：按引用捕获 local，当函数返回后，local 不再存在，因此 Process() 的行为未定义\r\n    threadPool.QueueWork([&] { Process(local); });\r\n}\r\n```",
        "修改建议": "lambda 按值捕获局部变量。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "562"
    },
    {
        "规则名称": "WordsTool.79 DropBox",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.75 dex",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.210 WTF",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.02 定义宏时，要使用完备的括号",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "函数式宏参数使用时添加括号",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "783"
    },
    {
        "规则名称": "WordsTool.83 EuiccCardController",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.03 含有变量自增或自减运算的表达式中禁止再次引用该变量【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：一个表达式中既有变量的递增或递减运算，也有此变量的其它运算\r\n- 修复示例：将自增或自减运算单独放一行。\r\n\r\n```cpp\r\nx = b[i] + i;\r\ni++;            // 符合： 单独一行\r\n\r\ni--;            // 符合： 单独一行\r\nx = Fun(i);     // 函数微重构\r\n```",
        "错误示例": "##### 场景1：一个表达式中既有变量的递增或递减运算，也有此变量的其它运算\r\n- 错误示例：\r\n\r\n```cpp\r\nx = b[i] + i++; // 不符合： b[i]运算跟 i++，先后顺序并不明确\r\n\r\nFun(i--, i);    // 不符合： 传递第2个参数时，不确定自减运算有没有发生\r\n```",
        "修改建议": "自增或自减运算提到表达式之外，单独放一行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "758"
    },
    {
        "规则名称": "WordsTool.173 SoudPool",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.10 指针类型\"*\"跟随变量或者函数名【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：指针类型*跟随类型\r\n- 修复示例：\r\n\r\n```cpp\r\nint *p2;  // 符合: \"*\"跟随变量\r\nstruct Foo *CreateFoo(void); // 符合: \"*\"跟随函数名\r\n```\r\n##### 场景2：指针类型*左右都有空格或者都没有空格\r\n- 修复示例：\r\n\r\n```cpp\r\nint *p3; // 符合\r\nint *p4; // 符合\r\n```",
        "错误示例": "##### 场景1：指针类型*跟随类型\r\n- 错误示例：\r\n\r\n```cpp\r\nint* p2;  // 不符合\r\nstruct Foo* CreateFoo(void); // 不符合\r\n```\r\n##### 场景2：指针类型*左右都有空格或者都没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint*p3;   // 不符合：\"*\"两边都没空格\r\nint * p4; // 不符合：\"*\"两边都有空格\r\n```",
        "修改建议": "修改`*`跟随变量名或者函数名。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.ERR.08-CPP 如果catch子句中不做任何操作，应添加注释说明原因",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：这里的catch块没有任何内容。其他程序员很难判断是原作者的疏忽，还是有意什么也不做。\r\n- 修复示例：添加注释以后，代码的意图变得明确。\r\n\r\n```cpp\r\nstd::vector<double> results;\r\nfor (auto &data : dataSet) {\r\n    try {\r\n        double result = Process(data);\r\n        results.push_back(result);\r\n    } catch (const BadDataException &e) { // 符合：添加注释说明意图\r\n        // 忽略错误的数据。虽然数据集没有被清理，但已有足够的好数据来计算最终结果\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：这里的catch块没有任何内容。其他程序员很难判断是原作者的疏忽，还是有意什么也不做。\r\n- 错误示例：\r\n\r\n```cpp\r\nstd::vector<double> results;\r\nfor (auto &data : dataSet) {\r\n    try {\r\n        double result = Process(data);\r\n        results.push_back(result);\r\n    } catch (const BadDataException &e) { // 不符合：空的catch\r\n    }\r\n}\r\n```",
        "修改建议": "1. 如果是遗漏了catch中的操作，请添加。\r\n2. 如果是有意的catch不做任何操作，应该添加注释说明原因。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "390"
    },
    {
        "规则名称": "G.FUD.05 函数要简短--函数大小【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "max_function_size:50",
        "正确示例": "##### 场景1：\r\n- 修复示例1：\r\n略",
        "错误示例": "##### 场景1：\r\n- 错误示例：\r\n略",
        "修改建议": "函数不超过50行（非空非注释），可通过一些重构方法进行改进，修改方法如：\r\n\r\n1. 拆分函数：将函数拆分成多个较小的函数，每个函数负责完成特定的任务。\r\n\r\n2. 提取子函数：将函数中的一部分代码提取出来，封装成一个独立的子函数。这样可以减少主函数的代码行数，并且可以复用这个子函数。\r\n\r\n3. 提取重复代码块：检查函数中是否有重复的代码块，如果有，可以将其提取出来，封装成一个独立的函数或者方法。\r\n\r\n4. 使用设计模式：使用适当的设计模式可以帮助将复杂的函数拆分成更小的模块。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080,1124"
    },
    {
        "规则名称": "G.EXP.30-CPP 用括号明确表达式的操作顺序，避免过分依赖默认优先级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nif ((a & b) == 0) ...       // 符合：明确先进行逻辑位运算\nx = (a & 0xFF) + b;         // 符合：明确先进行逻辑位运算\nx = 1 << (2 + 3);           // 符合：明确先进行加法运算\nx = (1 << 2) + 3;           // 符合：明确先进行移位运算\nx = (a == b) ? a : (a – b); // 符合：使用括号提升可读性\n```\n\n对于常用、不易混淆优先级的表达式，不需要强制增加额外的括号。\n\n```cpp\nx = a + b + c;              // 符合：操作符相同，可以不加括号\nx = Foo(a + b, c);          // 符合：逗号两边的表达式，不需要括号\nif (a > b && c > d) ...     // 符合：逻辑表达式，根据子表达式的复杂情况选择是否加括号\n```",
        "错误示例": "```cpp\nif (a & b == 0) ...         // 不符合：涉及逻辑位运算，需要括号\nx = a & 0xFF + b;           // 不符合：涉及逻辑位运算，需要括号\nx = 1 << 2 + 3;             // 不符合：涉及移位运算，需要括号\nx = a == b ? a : a – b;     // 不符合：操作符不同，建议括号\n```",
        "修改建议": "添加括号明确表达式顺序。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "783"
    },
    {
        "规则名称": "不安全函数[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "242"
    },
    {
        "规则名称": "G.ERR.06-CPP 禁止给函数加\"throw\"异常说明",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nvoid Foo()\n{\n    Bar(); // 不管Bar抛出什么异常，都可以继续抛出Foo\n}\n```",
        "错误示例": "```cpp\n// warning: dynamic exception specifications are deprecated\nvoid Foo() throw (AException, BException)\n{\n    // 万一Bar函数的行为变化了，抛出了除了AException和BException以外的其他异常，\n    // 就会导致std::terminate而不是异常继续向上抛\n    Bar();\n}\n```",
        "修改建议": "用noexcept标记",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "477"
    },
    {
        "规则名称": "WordsTool.262 冠军",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.12 正确设置安全函数中的destMax参数--检查destMax和count参数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "以下代码，destBuff跨越到不可访问内存，属于误用：\n\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nmemcpy_s(destBuff, 0x7fffffff, src, srcLen); // 不符合\n```\ndestMax参数设置原则：\n\n（为聚焦于说明destMax的用法，示例代码中省略了安全函数的返回值检查以及其他检查）\n\n1. destBuff 为 char destBuff[BUFF_SIZE] 形式的局部变量的情况\n\n1.1 使用时，destMax必须设置为 sizeof(destBuff) 或 BUFF_SIZE\n【反例】\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\n...\nmemcpy_s(destBuff, 100, src, srcLen);       // 不符合\nmemcpy_s(destBuff, srcLen, src, srcLen);     // 不符合\n```\n【正例】\n```c\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nchar strDest[BUFF_SIZE];\n...\nmemcpy_s(destBuff, sizeof(destBuff), src, srcLen);   // 符合\nmemcpy_s(destBuff, BUFF_SIZE, src, srcLen);           // 符合\nsprintf_s(strDest, sizeof(strDest), \"Hello, world\"); // 符合\n...\nmemset_s(strDest, BUFF_SIZE, 0, BUFF_SIZE);           // 符合\nscanf_s(\"%s\", strDest, sizeof(strDest));             // 符合\n```\n1.2 如果 destBuff 作为参数跨函数传递，必须将 destBuff 的实际大小作为参数进行传递\n\n【反例】\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, 100);   // 不符合\n    ParseBuff2(destBuff);       // 不符合：必须增加destMax参数\n    ...\n}\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, BUFF_SIZE, src, srcLen);         // 不符合\n    memcpy_s(destBuff, sizeof(destBuff), src, srcLen); // 不符合\n    memcpy_s(destBuff, 100, src, srcLen);               // 不符合\n    memcpy_s(destBuff, srcLen, src, srcLen);           // 不符合\n  ...\n}\n```\n\n【正例】\n\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, BUFF_SIZE); // 符合：传递BUFF_SIZE\n    ...\n}\n\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, destMax, src, srcLen);   // 符合\n    ...\n}\n```",
        "修改建议": "正确设置memcpy_s、strcpy_s等函数的destMax和count参数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "G.STD.17-CPP 禁止调用kill、TerminateProcess函数直接终止其他进程",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "正确的做法是通知对方进程停止，在等待一定时间内如果对方仍然未退出，再强行终止目标进程。\n```C\nif (isFatalStatus) {\n    ...\n    kill(pid, SIGUSR1); // 符合：目标进程将SIGUSR1定义为停止命令\n    ...\n    if (WaitForRemoteProcessExit() == TIME_OUT) {\n        kill(pid, SIGKILL); // 目标进程在限定时间内仍然未退出，强行结束目标进程\n    }\n}\n```",
        "错误示例": "```C\nif (inFatalStatus) {\n    ...\n    kill(pid, SIGKILL);     // 不符合：直接调用kill强行结束目标进程\n}\n```",
        "修改建议": "禁止调用kill、TerminateProcess函数直接终止其他进程。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "459"
    },
    {
        "规则名称": "WordsTool.27 Bionic",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.STD.01-CPP 使用新的标准头文件",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在C++代码中使用C标准头文件\r\n- 修复示例：\r\n\r\n```cpp\r\n#include <cstdlib>  // 符合：使用C++标准库头文件\r\n```",
        "错误示例": "##### 场景1：在C++代码中使用C标准头文件\r\n- 错误示例：\r\n\r\n```cpp\r\n#include <stdio.h>  // 不符合：使用C标准头文件\r\n...\r\n```",
        "修改建议": "用C++标准头文件`<cxxx>`替换C标准头文件`<xxx.h>`。\r\n举例如下\r\n| C标准头文件 | C++标准头文件 |\r\n| ------- | ------- |\r\n| stdlib.h | cstdlib |\r\n| time.h | ctime |\r\n| math.h | cmath |\r\n| stdio.h | cstdio |\r\n| ... | ... |",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.119 JD-Eclipse",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.113 Jad",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CTL.03 循环必须安全退出【C】",
        "问题级别": "提示",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：循环变量没有被更新，导致循环无法终止\r\n- 修复示例：循环变量i自增，确保循环能够正常退出\r\n\r\n```cpp\r\nvoid TestCaseGood01()\r\n{\r\n    int i = 0;\r\n    int n = 10;\r\n    while (i < n) {\r\n        /* do something */\r\n        i++; // 符合\r\n    }\r\n}\r\n```\r\n##### 场景2：循环控制变量的类型小于循环上限，可能导致整型回绕，造成死循环\r\n- 修复示例：循环条件变量使用同类型\r\n\r\n```cpp\r\nvoid TestCaseGood02()\r\n{\r\n    unsigned int ui = 9999;\r\n    // 符合：uc和ui使用相同类型\r\n    for (unsigned int uc = 0; uc < ui; uc++) {\r\n        ...\r\n    }\r\n}\r\n```\r\n##### 场景3：循环恒成立时，没有break或return语句，导致循环无法终止\r\n- 修复示例：循环恒成立场景，有合适的break语句\r\n\r\n```cpp\r\nvoid TestCaseGood03()\r\n{\r\n    for (;;) {\r\n        ...\r\n        if (...) {\r\n            break; // 符合\r\n        }\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：循环变量没有被更新，导致循环无法终止\r\n- 错误示例：while循环中，循环变量i没有被更新\r\n\r\n```cpp\r\nvoid TestCaseBad01()\r\n{\r\n    int i = 0;\r\n    int n = 10;\r\n    // 不符合：while循环中，循环变量i没有被更新\r\n    while (i < n) {\r\n        /* do something */\r\n    }\r\n}\r\n```\r\n##### 场景2：循环控制变量的类型小于循环上限，可能导致整型回绕，造成死循环\r\n- 错误示例：for循环条件uc<ui中，uc类型小于ui类型\r\n\r\n```cpp\r\nvoid TestCaseBad02()\r\n{\r\n    unsigned int ui = 9999;\r\n    // 不符合：uc类型小于ui类型，uc递增的最大值也还是小于ui，导致死循环\r\n    for (unsigned char uc = 0; uc < ui; uc++) {\r\n        ...\r\n    }\r\n}\r\n```\r\n##### 场景3：循环恒成立时，没有break或return语句，导致循环无法终止\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid TestCaseBad03()\r\n{\r\n    // 不符合：循环无终止条件\r\n    for (;;) {\r\n        ...\r\n    }\r\n}\r\n```",
        "修改建议": "确保循环能够正常退出，不出现死循环的情况。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "570,571,835"
    },
    {
        "规则名称": "G.INT.04 整型表达式比较或赋值为一种更大类型之前必须用这种更大类型对它进行求值【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：算术运算（加法）表达式的值可能在结果被赋值给较大的数据类型之前溢出\r\n- 修复示例：\r\n```c\r\nint OverflowBeforeIntegerWidenCombinationGoodCase01()\r\n{\r\n    uint64_t a = 0xffffffffU;\r\n    uint64_t b = 1;\r\n    uint64_t c = 2;\r\n    /* POTENTIAL FLAW GOOD: 最佳做法是修改变量类型，保持表达式中的操作数类型一致 */\r\n    uint64_t x = a + b + c;\r\n    return 0;\r\n}\r\n\r\nint OverflowBeforeIntegerWidenCombinationGoodCase02()\r\n{\r\n    uint32_t a = 0xffffffffU;\r\n    uint32_t b = 1;\r\n    uint64_t c = 2;\r\n    /* POTENTIAL FLAW GOOD: 将这个整数表达式中的一个操作数显式转换为较大的整数类型 */\r\n    uint64_t y = (uint64_t)a + (uint64_t)b + c;\r\n    return 0;\r\n}\r\n ```\r\n\r\n##### 场景2：算术运算（乘法）表达式的值可能在结果被赋值给较大的数据类型之前溢出\r\n- 修复示例：\r\n```c\r\nint OverflowBeforeIntegerWidenGoodCase01(void)\r\n{\r\n    uint64_t a = 0x10000000;\r\n    /* POTENTIAL FLAW GOOD: 最佳做法是修改变量类型，保持表达式中的操作数类型一致 */\r\n    uint64_t b = a * 0xab;\r\n    printf(\"b = %llX\\n\", b);\r\n    return 0;\r\n}\r\n\r\nint OverflowBeforeIntegerWidenGoodCase02(void)\r\n{\r\n    uint32_t a = 0x10000000;\r\n    /* POTENTIAL FLAW GOOD: uint32_t类型变量a乘法之前已经强转为uint64_t类型 */\r\n    uint64_t b = (uint64_t)a * 0xab;\r\n    printf(\"b = %llX\\n\", b);\r\n    return 0;\r\n}\r\n ```\r\n\r\n##### 场景3：算术运算（乘法）表达式的值可能在结果与较大的数据类型比较之前溢出\r\n- 修复示例：\r\n```c\r\nvoid OverflowBeforeIntegerWidenGoodCase03()\r\n{\r\n    uint64_t x = 2147483648;\r\n    uint64_t y = 2;\r\n    uint64_t z = 0;\r\n    /* POTENTIAL FLAW GOOD: 最佳做法是修改变量类型，保持表达式中的操作数类型一致 */\r\n    if ((x * y) < z) {\r\n        x = 0;\r\n        y = 0;\r\n    }\r\n}\r\n\r\nvoid OverflowBeforeIntegerWidenGoodCase03()\r\n{\r\n    uint32_t x = 2147483648;\r\n    uint32_t y = 2;\r\n    uint64_t z = 0;\r\n    /* POTENTIAL FLAW GOOD: 将这个整数表达式中的一个操作数显式转换为较大的整数类型 */\r\n    if (((uint64_t)x * (uint64_t)y) < z) {\r\n        x = 0;\r\n        y = 0;\r\n    }\r\n}\r\n ```",
        "错误示例": "##### 场景1：算术运算（加法）表达式的值可能在结果被赋值给较大的数据类型之前溢出\r\n- 错误示例：\r\n\r\n```c\r\nint OverflowBeforeIntegerWidenCombinationBadCase01()\r\n{\r\n    uint32_t a = 0xffffffffU;\r\n    uint32_t b = 1;\r\n    uint64_t c = 2;\r\n    /* POTENTIAL FLAW: 表达式 a + b + c 等同于表达式 (a + b) + c ，计算组合表达式 (a + b) 时先发生整数回绕 */\r\n    uint64_t x = a + b + c;\r\n    return 0;\r\n}\r\n ```\r\n\r\n##### 场景2：算术运算（乘法）表达式的值可能在结果被赋值给较大的数据类型之前溢出\r\n- 错误示例：\r\n\r\n```c\r\nint OverflowBeforeIntegerWidenBadCase07()\r\n{\r\n    uint32_t a = 0x10000000;\r\n    /* POTENTIAL FLAW: uint32_t类型乘法赋值和uint64_t类型 */\r\n    uint64_t b = a * 0xab;\r\n    printf(\"b = %llX\\n\", b);\r\n    return 0;\r\n}\r\n ```\r\n\r\n##### 场景3：算术运算（乘法）表达式的值可能在结果与较大的数据类型比较之前溢出\r\n- 错误示例：\r\n\r\n```c\r\n// @scene 两个int型变量做乘法之后与longlong类型变量做<比较\r\nvoid OverflowBeforeIntegerWidenBadCase03()\r\n{\r\n    uint32_t  x = 2147483648;\r\n    uint32_t  y = 2;\r\n    uint64_t z = 0;\r\n    /* POTENTIAL FLAW: x * y 超过了目标平台的 unsigned 类型允许的最大值（2^32    1，即 4,294,967,295） */\r\n    if ((x * y) < z) {\r\n        x = 0;\r\n        y = 0;\r\n    }\r\n}\r\n ```",
        "修改建议": "当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "192,843"
    },
    {
        "规则名称": "WordsTool.136 monkeyrunner",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.15 只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数--检查安全函数定义是否在安全函数库中【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：自定义安全函数。\r\n- 修复示例：不能自定义安全函数，只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数。\r\n\r\n```c\r\n略\r\n```",
        "错误示例": "##### 场景1：自定义安全函数。\r\n- 错误示例：\r\n\r\n```c\r\n// 不符合：自定义安全函数\r\nvoid Memcpy_s(void *dest, unsigned int destMax, const void *src, unsigned int count)\r\n{\r\n    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {\r\n        return;\r\n    }\r\n    if (dest == NULL || src == NULL) {\r\n        return;\r\n    }\r\n    if (count > destMax) {\r\n        return;\r\n    }\r\n    if (dest == src) {\r\n        return;\r\n    }\r\n    if (((uint32_t)dest > (uint32_t)src && (uint32_t)dest < (uint32_t)((uint8_t *)src + count)) ||\r\n        ((uint32_t)src > (uint32_t)dest && (uint32_t)src < (uint32_t)((uint8_t *)dest + count))) {\r\n        return;\r\n    }\r\n    memcpy(dest, src, count);\r\n    return;\r\n}\r\n```",
        "修改建议": "不要自定义安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.258 领导者",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.09 禁止使用realloc()函数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "使用malloc()函数代替realloc()函数\n```c\n// 使用malloc()函数代替realloc()函数\nchar *newPtr = (char *)malloc(NEW_SIZE);\nif (newPtr == NULL) {\n  ... // 错误处理\n}\n\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\n... // 校验ret，确保安全函数执行成功\n\n... // 返回前，释放oldPtr\n```",
        "错误示例": "如下代码示例中，使用realloc不当导致内存泄漏。\n\n代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏\n\n```C\n// 当realloc()分配内存失败时会返回NULL，导致内存泄漏\nchar *ptr = (char *)realloc(ptr, NEW_SIZE);\nif (ptr == NULL) {\n  .. // 错误处理\n}\n```",
        "修改建议": "禁止调用realloc函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.30 Build flavor",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.176 STM",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.14-CPP 指针类型\"*\"和引用类型\"&\"只跟随类型或变量名--指针类型",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "c_coding_standard_v5.0:true;pointer_follow_type_or_var:2",
        "正确示例": "##### 场景1：选用的风格是跟随变量名或函数名，但是实际开发时跟随类型\r\n- 修复示例：\r\n\r\n```cpp\r\nint *p2;                        // 符合：\"*\"跟随变量名\r\nstruct Foo *CreateFoo(void);    // 符合: \"*\"跟随函数名\r\n```\r\n##### 场景2：选用的风格是跟随类型，但是实际开发时跟随变量名或函数名\r\n- 修复示例：\r\n\r\n```cpp\r\nint i = 0;\r\nint* p = &i;        // 符合：\"*\"跟随类型\r\nFoo* CreateFoo();   // 符合：\"*\"跟随类型\r\n```\r\n\r\n##### 场景3：指针符号左右都有空格或者都没有空格\r\n- 修复示例1：选用跟随变量名或函数名风格的规则并遵从。\r\n\r\n```cpp\r\nint *p3; // 符合\r\nint *p4; // 符合\r\nconst char *const VERSION = \"V100\"; // 符合：向右跟随关键字（可选\"*\"两边都有空格的风格）\r\n```\r\n\r\n- 修复示例2：选用跟随类型风格的规则并遵从。\r\n\r\n```cpp\r\nint* p3; // 符合\r\nint* p4; // 符合\r\nconst char* const VERSION = \"V100\"; // 符合：跟随类型（可选\"*\"两边都有空格的风格）\r\n```",
        "错误示例": "##### 场景1：选用的风格是跟随变量名或函数名，但是实际开发时跟随类型\r\n- 错误示例：\r\n\r\n```cpp\r\nint* p2;                        // 不符合\r\nstruct Foo* CreateFoo(void);    // 不符合\r\n```\r\n\r\n##### 场景2：选用的风格是跟随类型，但是实际开发时跟随变量名或函数名\r\n- 错误示例：\r\n\r\n```cpp\r\nint i = 0;\r\nint *p = &i;        // 不符合\r\nFoo *CreateFoo();   // 不符合\r\n```\r\n\r\n##### 场景3：指针符号左右都有空格或者都没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint*p3;                             // 不符合：两边都没空格\r\nint * p4;                           // 不符合：两边都有空格\r\nconst char*const VERSION = \"V100\";  // 不符合：两边都没空格\r\n```",
        "修改建议": "\"*\"和\"&\"按要求跟随类型或者名称。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.277 免抽检",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ERR.02-CPP 抛异常时，抛对象本身，而不是指向对象的指针",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：抛出对象的指针\r\n- 修复示例：\r\n\r\n```cpp\r\ntry {\r\n    if (SomeFunction()) {\r\n        throw SomeException(\"reason 1\"); // 符合：抛出对象本身\r\n    } else {\r\n        throw SomeException(\"reason 2\"); // 符合：抛出对象本身\r\n    }\r\n} catch (const SomeException& e) {\r\n    ...                                  // 符合：这里可以确定不需要delete\r\n}\r\n```",
        "错误示例": "##### 场景1：抛出对象的指针\r\n- 错误示例：\r\n\r\n```cpp\r\nstatic SomeException exc1(\"reason 1\");\r\n\r\ntry {\r\n    if (SomeFunction()) {\r\n        throw &exc1;                         // 不符合：这是静态对象的指针，不应该delete\r\n    } else {\r\n        throw new SomeException(\"reason 2\"); // 不符合：这是动态分配的，应该delete\r\n    }\r\n} catch (const SomeException* e) {\r\n    delete e;                                // 不符合：这里不能确定是否需要delete\r\n}\r\n```",
        "修改建议": "抛出对象本身而非指针。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "401,755"
    },
    {
        "规则名称": "WordsTool.115 Java Crash",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.51 ConnectionServiceAdapter",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.13 禁止封装安全函数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用类似不安全函数的接口封装安全函数，destMax与count参数使用相同参数。\r\n- 修复示例：禁止定义和使用不正确的封装或自实现安全函数，请使用安全函数。\r\n\r\n```c\r\n略\r\n```\r\n##### 场景2：使用函数简单封装安全函数，封装函数的接口入参类型与安全函数入参相同，但封装函数内调用安全函数时destMax与count参数使用相同参数。\r\n- 修复示例：禁止定义和使用不正确的封装或自实现安全函数，请使用安全函数。\r\n\r\n```c\r\n略\r\n```\r\n##### 场景3：使用#define重命名安全函数并且destMax与count两个参数一致，导致安全函数失效的情况。\r\n- 修复示例：禁止定义和使用不正确的封装或自实现安全函数，请使用安全函数。\r\n\r\n```c\r\n略\r\n```\r\n##### 场景4：使用类似安全函数接口的宏，重定义安全函数，destMax与count参数使用相同参数。\r\n- 修复示例：禁止定义和使用不正确的封装或自实现安全函数，请使用安全函数。\r\n\r\n```c\r\n略\r\n```",
        "错误示例": "##### 场景1：使用类似不安全函数的接口封装安全函数，destMax与count参数使用相同参数。\r\n- 错误示例：\r\n\r\n```c\r\nvoid *XXX_memcpy(void *dest, const void *src, size_t count)\r\n{\r\n    ...\r\n    memcpy_s(dest,  count,  src, count); // 不符合：destMax与count参数相同\r\n    ...\r\n}\r\n```\r\n##### 场景2：使用函数简单封装安全函数，封装函数的接口入参类型与安全函数入参相同，但封装函数内调用安全函数时destMax与count参数使用相同参数。\r\n- 错误示例：\r\n\r\n```c\r\nerrno_t XXX_memcpy_s(void *dest, size_t destMax, const void *src, size_t count)\r\n{\r\n    ...\r\n    memcpy_s(dest,  count,  src, count); // 不符合：destMax与count参数相同\r\n    ...\r\n}\r\n```\r\n##### 场景3：使用#define重命名安全函数并且destMax与count两个参数一致，导致安全函数失效的情况。\r\n- 错误示例：\r\n\r\n```c\r\n#define XXX_memcpy(dst, src, count) memcpy_s(dst, count, src, count) // 不符合：destMax与count参数相同\r\n```\r\n##### 场景4：使用类似安全函数接口的宏，重定义安全函数，destMax与count参数使用相同参数。\r\n- 错误示例：\r\n\r\n```c\r\n#define XXX_memcpy_s(dst, destMax, src, count) memcpy_s(dst, count, src, count) // 不符合：destMax与count参数相同\r\n```",
        "修改建议": "对安全函数做封装时，正确理解destMax的用法，不要用count替代destMax",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.FUU.21 禁止使用内存操作类不安全函数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用不安全函数。\r\n- 修复示例：  使用安全函数替代对应的不安全函数。\r\n\r\n```c\r\nvoid RiskyFuncGood(const char* src)\r\n{\r\n    char dest[16];\r\n    // 符合：推荐使用安全函数，增加destMax参数，对目的缓冲区做保护\r\n    errno_t ret = memcpy_s(dest, sizeof(dest), src, strlen(src));\r\n    if (ret != EOK) {\r\n        return;\r\n    }\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：使用不安全函数。\r\n- 错误示例：\r\n\r\n```c\r\nvoid RiskyFuncBad(const char* src)\r\n{\r\n    char dest[16];\r\n    // 不符合：使用危险函数，目的缓冲区未做保护，若src的长度大于16，则会造成dest拷贝越界\r\n    memcpy(dest, p, strlen(src));\r\n}\r\n```",
        "修改建议": "使用安全函数替代危险函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "242"
    },
    {
        "规则名称": "G.FMT.13-CPP case/default语句相对switch缩进一层",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nswitch (var) {\n    case CASE1:         // 符合：缩进  \n        DoSomething1(); // 符合：缩进  \n        break;\n    case CASE2: {       // 符合：带大括号格式  \n        DoSomething2();\n        break;\n    }\n    ...\n    default:\n        break;\n}\n```",
        "错误示例": "```cpp\nswitch (var) {\ncase CASE1:             // 不符合：case 未缩进  \n    DoSomething1();\n    break;\n...\ndefault:                // 不符合：default 未缩进  \n    break;\n}\n```",
        "修改建议": "按要求进行缩进。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.264 遥遥领先",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.306 病毒",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.227 最新科技",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.INT.09 确保枚举常量映射到唯一值【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：两个枚举常量为相同值\r\n- 修复示例1：\r\n\r\n```cpp\r\nenum class LocalType1 { // 符合：枚举值从0开始，不提供显式的整数赋值\r\n    LOCAL1_TYPE0,\r\n    LOCAL1_TYPE1,\r\n    LOCAL1_TYPE2,\r\n    LOCAL1_TYPE3,\r\n    LOCAL1_TYPE4,\r\n    LOCAL1_TYPE5,\r\n    LOCAL1_TYPE_END\r\n};\r\n```\r\n\r\n- 修复示例2：\r\n\r\n```cpp\r\nenum class LocalType1 { // 符合：如果第一个枚举值不需要从0开始的话，只对第一个成员赋值，其它成员不提供显示的整数赋值\r\n    LOCAL1_TYPE1 = 1,\r\n    LOCAL1_TYPE2,\r\n    LOCAL1_TYPE3,\r\n    LOCAL1_TYPE4,\r\n    LOCAL1_TYPE5,\r\n    LOCAL1_TYPE_END\r\n};\r\n```",
        "错误示例": "##### 场景1：两个枚举常量为相同值\r\n- 错误示例：\r\n\r\n```cpp\r\nenum class LocalType1 { // 不符合，LOCAL1_TYPE2和LOCAL1_TYPE5值相同，LOCAL1_TYPE3和LOCAL1_TYPE_END值相同\r\n    LOCAL1_TYPE1 = 1,\r\n    LOCAL1_TYPE2,\r\n    LOCAL1_TYPE3,\r\n    LOCAL1_TYPE4 = 1,\r\n    LOCAL1_TYPE5,\r\n    LOCAL1_TYPE_END\r\n};\r\n```",
        "修改建议": "1、不提供显式的整数赋值。\r\n2、如果第一个枚举值不需要从0开始的话，只对第一个成员赋值，其它成员不提供显示的整数赋值。\r\n3、如果枚举类型的多个成员确实需要分配相同的值，需要提供显式的整数赋值，并写一条注释，解释为什么这样做。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "462"
    },
    {
        "规则名称": "G.FMT.14-CPP 指针类型\"*\"和引用类型\"&\"只跟随类型或变量名--引用类型",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：选用的风格是`跟随变量名或函数名`，但是实际开发时`跟随类型`\r\n- 修复示例：\r\n\r\n```cpp\r\nint &r;                         // 符合：\"&\"跟随变量名\r\nstruct Foo &CreateFoo(void);    // 符合: \"&\"跟随函数名\r\n```\r\n##### 场景2：选用的风格是`跟随类型`，但是实际开发时`跟随变量名或函数名`\r\n- 修复示例：\r\n\r\n```cpp\r\nint& r = i;         // 符合：\"&\"跟随类型\r\nint&& rr = i + 10;  // 符合：\"&\"跟随类型\r\nint*& rp = p;       // 符合：\"&\"跟随类型\r\nFoo& GetFoo();      // 符合：\"&\"跟随类型\r\n```\r\n##### 场景3：引用符号左右都有空格或者都没有空格\r\n- 修复示例1：选用**跟随变量名或函数名**风格的规则并遵从。\r\n\r\n```cpp\r\nint &r1; // 符合\r\nint &r2; // 符合\r\n```\r\n- 修复示例2：选用**跟随类型**风格的规则并遵从。\r\n\r\n```cpp\r\nint& r1; // 符合\r\nint& r2; // 符合\r\n```",
        "错误示例": "##### 场景1：选用的风格是`跟随变量名或函数名`，但是实际开发时`跟随类型`\r\n- 错误示例：\r\n\r\n```cpp\r\nint& r;                         // 不符合\r\nstruct Foo& CreateFoo(void);    // 不符合\r\n```\r\n##### 场景2：选用的风格是`跟随类型`，但是实际开发时`跟随变量名或函数名`\r\n- 错误示例：\r\n\r\n```cpp\r\nint &r = i;         // 不符合\r\nint &&rr = i + 10;  // 不符合\r\nint *&rp = p;       // 不符合\r\nFoo &GetFoo();      // 不符合\r\n```\r\n##### 场景3：引用符号左右都有空格或者都没有空格\r\n- 错误示例：\r\n```cpp\r\nint&r1;   // 不符合：两边都没空格\r\nint & r2; // 不符合：两边都有空格\r\n```",
        "修改建议": "1. 确认选用的规则是跟随类型还是跟随变量名或函数名，根据确认结果修改。\r\n\r\n2. 可通过格式化工具修复问题，可配置是**跟随类型**或**跟随变量名或函数名**。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.152 WordsTool.1PKEraserTool",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.232 国家级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.02 定义宏时，要使用完备的括号【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：宏参数未添加括号\r\n- 修复示例：\r\n```cpp\r\n#define MAX_OF(x, y) (x) > (y) ? (x) : (y)  // 符合\r\n```\r\n##### 场景2：宏参数在赋值语句中未添加括号\r\n- 修复示例：\r\n```cpp\r\n#define UPDATE_VALUE(value, a, b) (value = (a) + (b))   // 符合：a, b 需要括号；而 value 可以不加括号\r\n```\r\n##### 场景3：宏定义中的负数未添加括号\r\n- 修复示例：\r\n```cpp\r\n#define ANOTHER_CONST (-1)  // 符合: 负数需要使用括号\r\n```",
        "错误示例": "##### 场景1：宏参数未添加括号\r\n- 错误示例：\r\n```cpp\r\n#define MAX_OF(x, y)  x > y ? x : y         // 不符合\r\n```\r\n##### 场景2：宏参数在赋值语句中未添加括号\r\n- 错误示例：\r\n```cpp\r\n#define UPDATE_VALUE(value, a, b) value = a + b         // 不符合\r\n```\r\n##### 场景3：宏定义中的负数未添加括号\r\n- 错误示例：\r\n```cpp\r\n#define ANOTHER_CONST -1    // 不符合\r\n```",
        "修改建议": "在宏定义中加上括号，如：\r\n```c\r\n#define SQUARE(x) x * x // 不符合\r\n```\r\n改为\r\n```c\r\n#define SQUARE(x) ((x) * (x)) // 符合\r\n```",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "783"
    },
    {
        "规则名称": "WordsTool.249 首次",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.141 MyScript",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.VAR.05 指向资源句柄或描述符的变量，在资源释放后立即赋予新值【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：单个函数内，使用被释放的资源（指针）\r\n- 修复示例1：应确保局部变量资源释放后，其无效值不被再次使用。\r\n\r\n```c\r\nvoid UseP(int32_t *p);\r\n\r\nvoid GoodCase01(int32_t coreNum)\r\n{\r\n    int32_t *intP = (int32_t *)malloc(coreNum * sizeof(int32_t));\r\n    if (intP == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    free(intP);\r\n    // 符合: 指针指向的资源被释放后，不再使用\r\n}\r\n```\r\n- 修复示例2：应确保局部变量资源释放后，其无效值不被再次使用。如果还需使用，请在使用前重新赋值。\r\n\r\n```c\r\nvoid UseP(int32_t *p);\r\n\r\nvoid GoodCase01(int32_t coreNum)\r\n{\r\n    int32_t *intP = (int32_t *)malloc(coreNum * sizeof(int32_t));\r\n     if (intP == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    free(intP);\r\n    // 符合: 指针指向的资源被释放后，立即赋空\r\n    intP = NULL;\r\n    ...\r\n    if (intP != NULL) {\r\n        UseP(intP); // 指针使用前保证非空\r\n    }\r\n}\r\n```\r\n##### 场景2：单个函数内，使用被释放的资源（socket描述符）\r\n- 修复示例1：应确保局部变量资源释放后，其无效值不被再次使用。\r\n\r\n```c\r\nvoid UseSocket(SOCKET s);\r\n\r\nvoid GoodCase02()\r\n{\r\n    SOCKET s = INVALID_SOCKET;\r\n    ... // 创建并使用套接字\r\n    closesocket(s);\r\n    // 符合: 套接字关闭后，不再使用\r\n}\r\n```\r\n- 修复示例2：应确保局部变量资源释放后，其无效值不被再次使用。如果还需使用，请在使用前重新赋值。\r\n\r\n```c\r\nvoid UseSocket(SOCKET s);\r\n\r\nvoid GoodCase02()\r\n{\r\n    SOCKET s = INVALID_SOCKET;\r\n    ... // 创建并使用套接字\r\n    closesocket(s);\r\n    // 符合: 还需要再次使用套接字，需要重新创建和初始化套接字\r\n    s = INVALID_SOCKET;\r\n    ... // 重新创建套接字\r\n    UseSocket(s);\r\n}\r\n```\r\n##### 场景3：全局性的资源（指针）被释放后未重新赋值\r\n- 修复示例1：全局变量的资源句柄或描述符被释放后应该立即重新赋值。\r\n\r\n```c\r\nint32_t *g_intP;\r\n\r\nvoid GoodCase03()\r\n{\r\n    if (g_intP == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    free(g_intP);\r\n    // 符合: 全局变量指向的资源被释放后，立即被赋空\r\n    g_intP = NULL;\r\n}\r\n```\r\n##### 场景4：全局性的资源（socket描述符）被释放后未重新赋值\r\n- 修复示例1：全局变量的资源句柄或描述符被释放后应该立即重新赋值。\r\n\r\n```c\r\nSOCKET g_socket = INVALID_SOCKET;\r\n\r\nvoid GoodCase04()\r\n{\r\n    ... // 创建并使用套接字\r\n    closesocket(g_socket);\r\n    // 符合: 全局变量指向的资源被释放后，立即重新赋值。\r\n    g_socket = INVALID_SOCKET;\r\n    ... // 重新创建套接字\r\n}\r\n```",
        "错误示例": "##### 场景1：单个函数内，使用被释放的资源（指针）\r\n- 错误示例：\r\n\r\n```c\r\nvoid UseP(int32_t *p);\r\n\r\nvoid BadCase01(int32_t coreNum)\r\n{\r\n    int32_t *intP = (int32_t *)malloc(coreNum * sizeof(int32_t));\r\n    if (intP == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    free(intP);\r\n    // 不符合: 指针指向的资源被释放后，指针没有被重新赋值，直接使用\r\n    UseP(intP);\r\n}\r\n```\r\n##### 场景2：单个函数内，使用被释放的资源（socket描述符）\r\n- 错误示例：\r\n\r\n```c\r\nvoid UseSocket(SOCKET s);\r\n\r\nvoid BadCase02()\r\n{\r\n    SOCKET s = INVALID_SOCKET;\r\n    ... // 创建并使用套接字\r\n    closesocket(s);\r\n    // 不符合: 使用已关闭的套接字\r\n    UseSocket(s);\r\n}\r\n```\r\n##### 场景3：全局性的资源（指针）被释放后未重新赋值\r\n- 错误示例：\r\n\r\n```c\r\nint32_t *g_intP;\r\n\r\nvoid BadCase03()\r\n{\r\n    if (g_intP == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    // 不符合: 全局变量指向的资源被释放后未重新赋值\r\n    free(g_intP);\r\n}\r\n```\r\n##### 场景4：全局性的资源（socket描述符）被释放后未重新赋值\r\n- 错误示例：\r\n\r\n```c\r\nSOCKET g_socket = INVALID_SOCKET;\r\n\r\nvoid BadCase04()\r\n{\r\n    ... // 创建并使用套接字\r\n    // 不符合: 全局变量指向的资源被释放后未重新赋值\r\n    closesocket(g_socket);\r\n}\r\n```",
        "修改建议": "对于局部变量，调用closesocket、free、close、delete等函数释放资源后，需要重新赋值后再继续使用；对于全局变量，释放后在函数结束前需要被重新赋值",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "416"
    },
    {
        "规则名称": "WordsTool.224 最高搭载",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.185 traceview",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.05-CPP 移动构造函数和移动赋值操作符应该同时声明",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：只声明了移动构造函数，没有声明移动赋值操作符\r\n- 修复示例1：有些情况下，移动构造函数和移动赋值操作符以`相同的方式`来进行处理\r\n\r\n```cpp\r\n// 符合\r\nclass Foo {\r\npublic:\r\n    ...\r\n    Foo(Foo&& other) noexcept;\r\n    Foo& operator=(Foo&& other) noexcept;\r\n    ...\r\n};\r\n```\r\n- 修复示例2：有些情况下，移动构造函数和移动赋值操作符以`不同的方式`来进行处理\r\n\r\n```cpp\r\n// 符合：移动构造函数和移动赋值操作符同时声明\r\nclass Foo {\r\npublic:\r\n    ...\r\n    // 如果编译器不能隐式生成移动赋值操作符，可以只实现移动构造函数，并将移动赋值操作符显式定义为`=delete`\r\n    Foo(Foo&& other) noexcept;\r\n    Foo& operator=(Foo&&) = delete;\r\n    ...\r\n};\r\n```",
        "错误示例": "##### 场景1：只声明了移动构造函数，没有声明移动赋值操作符\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：只声明了移动构造函数，没有声明移动赋值操作符\r\nclass Foo {\r\npublic:\r\n    ...\r\n    Foo(Foo&& other) noexcept;\r\n    ...\r\n};\r\n```",
        "修改建议": "同时声明移动构造函数和移动赋值操作符，包括自定义实现、`=default`和`=delete`。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.165 ReleaseAndSwap",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.139 multidex",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.261 之王",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.04 禁止把带副作用的表达式作为参数传递给函数式宏【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：递增表达式作为宏参数\r\n- 修复示例：\r\n\r\n```cpp\r\n#define ADD_TWICE(x, y) ((x) + ((x) + (y)) + (y))\r\n\r\nint Fun(int a, int b)\r\n{\r\n    a++;\r\n    return ADD_TWICE(a, b); // 符合\r\n}\r\n```\r\n##### 场景2：递减表达式作为宏参数\r\n- 修复示例：\r\n\r\n```cpp\r\n#define SQUARE(a) ((a) * (a))\r\n\r\nint Fun(int a)\r\n{\r\n    a--;\r\n    return SQUARE(a); // 符合\r\n}\r\n```",
        "错误示例": "##### 场景1：递增表达式作为宏参数\r\n- 错误示例：\r\n\r\n```cpp\r\n#define ADD_TWICE(x, y) ((x) + ((x) + (y)) + (y))\r\n\r\nint Fun(int a, int b)\r\n{\r\n    return ADD_TWICE(a++, b); // 不符合：a++有副作用\r\n}\r\n```\r\n##### 场景2：递减表达式作为宏参数\r\n- 错误示例：\r\n\r\n```cpp\r\n#define SQUARE(a) ((a) * (a))\r\n\r\nint Fun(int a)\r\n{\r\n    return SQUARE(a--); // 不符合：a--有副作用\r\n}\r\n```",
        "修改建议": "不要将带副作用的表达式作为宏的参数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "WordsTool.256 领袖品牌",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.195 VMS",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.4 AAudio",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.05-CPP 行宽不超过120个字符",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "column_width:120",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "在合适的位置换行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.217 最快",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.15 只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数--检查安全函数定义是否在安全函数库中",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "在下面的拷贝安全函数实现中，由于不恰当的进行了类转换，因此缺乏在64位系统上的可移植性，同时，该函数的返回值也不兼容C11标准中的安全拷贝函数memcpy_s。\n```C\n#define SECUREC_MEM_MAX_LEN (0x7fffffffUL)\nvoid MemcpySafe(void *dest, unsigned int destMax, const void *src, unsigned int count)\n{\n  if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN ) {\n    return;\n }\n  if (dest == NULL || src == NULL) {\n    return;\n }\n  if (count > destMax) {\n    return;\n }\n  if (dest == src) {\n    return;\n }\n  if (((uint32_t)dest > (uint32_t)src &&\n    (uint32_t)dest < (uint32_t)(void *)((uint8_t *)src + count)) ||\n   ((uint32_t)src > (uint32_t)dest &&\n    (uint32_t)src < (uint32_t)(void *)((uint8_t *)dest + count))) {\n    return;\n }\n  memcpy(dest, src, count);\n}\n```",
        "修改建议": "不要自定义安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.AST.01 断言必须使用宏定义，且只能在调试版本中生效【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用自定义断言宏时，在发布版本中使用打印替换断言。\r\n- 修复示例：使用自定义断言宏时，在发布版本中不能使用打印。\r\n```cpp\r\n#ifdef DEBUG\r\n#define ASSERT(f)  assert(f)\r\n#else\r\n#define ASSERT(f)  ((void)0)    // 符合\r\n#endif\r\n```\r\n\r\n##### 场景2：在代码中直接使用assert()。\r\n- 修复示例：在代码中不应直接使用assert()，应该使用自定义断言宏。\r\n```cpp\r\n// 例如以下宏定义\r\n#ifdef DEBUG\r\n#define ASSERT(f)  assert(f)\r\n#else\r\n#define ASSERT(f)  ((void)0)\r\n#endif\r\n\r\nint Foo(int *array, size_t size)\r\n{\r\n    ASSERT(array != NULL);  // 符合\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：使用自定义断言宏时，在发布版本中使用打印替换断言。\r\n- 错误示例：在发布版本中使用打印替换断言，生成了实际代码，是不正确的设计。\r\n```C\r\n#ifdef DEBUG\r\n#define ASSERT(f)  assert(f)\r\n#else\r\n#define ASSERT(f)  do { \\\r\n    if (!(f)) { \\\r\n        printf(\"Error in function=%s, Line=%d\\n\", __FUNCTION__, __LINE__); \\    // 不符合\r\n    } \\\r\n} while (0)\r\n#endif\r\n```\r\n\r\n##### 场景2：在代码中直接使用assert()。\r\n- 错误示例：\r\n```C\r\nint Foo(int *array, size_t size)\r\n{\r\n    assert(array != NULL);  // 不符合\r\n    ...\r\n}\r\n```",
        "修改建议": "断言必须使用宏定义，且只能在调试版本中生效。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.279 机关推荐",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.33 canvasViewDidBeginUsingTool",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.291 真皮",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.312 地震",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.21 AudioFocus",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.24 BarringActive",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐--数据初始化换行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：数组初始化时同一层级没有缩进对齐\r\n- 修复示例：\r\n\r\n```cpp\r\nint a[][2] = {\r\n    {1, 2},        // {1, 2}和 {3, 4}、{5, 6}是同一层级\r\n    {3, 4},        // 符合：同一层级缩进对齐\r\n    {5, 6}         // 符合：同一层级缩进对齐\r\n};\r\n```\r\n\r\n##### 场景2：数组初始化时嵌套层级相对上一层级未缩进4空格\r\n- 修复示例：\r\n\r\n```cpp\r\nint a[][2] = {\r\n    {1, 2},    // 符合：相对上一层级缩进4空格\r\n    {3, 4},\r\n    {5, 6}\r\n};\r\n```",
        "错误示例": "##### 场景1：数组初始化时同一层级没有缩进对齐\r\n- 错误示例：\r\n\r\n```cpp\r\nint a[][2] = {\r\n    {1, 2},        // {1, 2}和 {3, 4}、{5, 6}是同一层级\r\n        {3, 4},    // 不符合：同一层级没有缩进对齐\r\n            {5, 6} // 不符合：同一层级没有缩进对齐\r\n};\r\n```\r\n\r\n##### 场景2：数组初始化时嵌套层级相对上一层级未缩进4空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint a[][2] = {\r\n{1, 2},        // 不符合：相对上一层级未缩进4空格\r\n{3, 4},\r\n{5, 6}\r\n};\r\n```",
        "修改建议": "按要求进行对齐。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.140 MYFITNESSPAL",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.101 HWC",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.205 libomp",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.99 HoldAndAnswer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.153 places",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.AST.03 禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "下面代码演示了如何重构上面的错误代码\n```C\nFILE *fp = fopen(path, \"r\");\nif (fp == NULL) {\n    ... // 错误处理\n}\nchar *str = (char *)malloc(MAX_LINE);\nif (str == NULL) {\n    ... // 错误处理\n}\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\");\nif (p == NULL) {\n    ... // 错误处理\n}\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nif (age <= 0) {\n    ... // 错误处理\n}\n```",
        "错误示例": "以下代码的所有ASSERT的用法都是错误的。例如，错误的使用ASSERT宏来验证内存分配是否成功，因为内存的可用性取决于系统的整体状态，并且在程序运行的任何时候都可能耗尽，所以必须以具有韧性的方式来妥善处理并将程序从内存耗尽中恢复。因此，使用ASSERT宏来验证内存分配是否成功将是不合适的，因为这样做可能导致进程突然终止，从而开启了拒绝服务攻击的可能性。\n```C\nFILE *fp = fopen(path, \"r\");\nASSERT(fp != NULL);  // 不符合：文件有可能打开失败\nchar *str = (char *)malloc(MAX_LINE);\nASSERT(str != NULL); // 不符合：内存有可能分配失败\nReadLine(fp, str);\nchar *p = strstr(str, \"age=\"\");\nASSERT(p != NULL);  // 不符合：文件中不一定存在该字符串\nchar *end = NULL;\nlong age = strtol(p + 4, &end, 10);\nASSERT(age > 0);   // 不符合：文件内容不一定符合预期\n ```",
        "修改建议": "不要在发布版本上使用assert检查程序运行过程中发生的错误。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.171 SmsManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.110 Intent",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.63 CXCallUpdate",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.254 金牌",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.7 adb",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--二元表达式【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：二元操作符至少一边没加空格\r\n- 修复示例1：二元操作符两边加上空格\r\n\r\n```cpp\r\nc = a + b;      // 符合\r\n```",
        "错误示例": "##### 场景1：二元操作符至少一边没加空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = a+b;        // 不符合：'+' 左右没有空格\r\nc = a +b;       // 不符合：'+' 右边没有空格\r\nc = a+ b;       // 不符合：'+' 左边没有空格\r\n```",
        "修改建议": "二元操作符左右两边需要有一个空格，请补齐。\r\n\r\n建议通过格式化工具自动修复。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.ERR.07-CPP 在构造函数的函数级try-catch的catch块内，不能使用基类以及成员变量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：构造函数的函数级try-catch的catch块内使用成员变量\r\n- 修复示例：虽然基类和成员都不能访问，但参数还是可以访问的\r\n\r\n```cpp\r\nclass Bar {\r\n    int y;\r\n    Evil evil;\r\npublic:\r\n    Bar(int newX, int newY) try : Foo(newX), y(newY), evil(666) {\r\n        ...\r\n    } catch (...) {\r\n        // 符合：可以访问函数参数\r\n        Log(\"Error happened when constructing Bar with\", newX, \"and\", newY);\r\n        throw;\r\n    }\r\n};\r\n```",
        "错误示例": "##### 场景1：构造函数的函数级try-catch的catch块内使用成员变量\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Evil {\r\npublic:\r\n    Evil(int n)\r\n    {\r\n       throw SomeException();\r\n    }\r\n};\r\n\r\nclass Foo {\r\nprotected:\r\n    int x;\r\npublic:\r\n    Foo(int newX) : x(newX)\r\n    {\r\n    }\r\n};\r\n\r\nclass Bar : public Foo {\r\n    int y;\r\n    Evil evil;\r\npublic:\r\n    Bar(int newX, int newY)\r\n    try : Foo(newX), y(newY), evil(666) {\r\n        ...\r\n    } catch (...) {\r\n        Use(x);     // 不符合：x已经被破坏\r\n        Use(y);     // 不符合：y已经被破坏\r\n        Use(evil);  // 不符合：evil还没完成构造\r\n        throw;\r\n    }\r\n};\r\n```",
        "修改建议": "在构造函数的函数级try-catch的catch块内，不要使用基类以及成员变量。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.230 TOP.1",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.146 NuPlayer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.26-CPP 整型表达式比较或赋值为一种更大类型之前必须用这种更大类型对它进行求值",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下的一种解决方案，是显式转换变量 a 和 b 的类型为  uint64_t 类型：\n```C\nuint32_t a = 0xffffffffU;\nuint32_t b = 1;\nuint64_t c = 2;\nuint64_t x = static_cast<uint64_t>(a) + static_cast<uint64_t>(b) + c;\nuint64_t y = (static_cast<uint64_t>(a) + static_cast<uint64_t>(b)) + c;\nuint64_t z = static_cast<uint64_t>(a) + c + static_cast<uint64_t>(b);\nuint64_t t = static_cast<uint64_t>(a) + (static_cast<uint64_t>(b) + c);\nuint64_t m = static_cast<uint64_t>(a) + static_cast<uint64_t>(b) * c;\n```\n\n最佳做法是修改变量 a 和 b 的类型为  uint64_t 类型，保持表达式中的操作数类型一致（如果表达式的数值不可信，应先校验其范围防止无符号整数回绕）。\n```C\nuint64_t a = 0xffffffffU;\nuint64_t b = 1;\nuint64_t c = 2;\nuint64_t x = a + b + c;\nuint64_t y = a + c + b;\nuint64_t z = a + (b + c);\nuint64_t t = a + b * c;\n```",
        "错误示例": "在以二进制补码表示整数的系统中：\n\n- 表达式  a + b + c 等同于表达式  (a + b) + c ，计算组合表达式  (a + b) 时先发生整数回绕，其结果为0，再与c相加后得到 x 的值为2。\n\n- 表达式  static_cast<uint64_t>(a + b) + c ，计算组合表达式 (a + b) 时先发生整数回绕，其结果为0，然后再转换  uint64_t 类型并与 c 相加后得到 y 的值为2\n\n- 表达式  a + c + b 等同于表达式  (a + c) + b ，与前面表达式不同点在于，计算 a + c 时发生了隐式类型转换，将 a 隐式提升到了  uint64_t 类型后在进行计算，因此最后 z 的值是正确的，但是该代码依赖表达式计算顺序，不利于维护和阅读，应禁止使用该技巧。类似的，t 和 m 的值虽然正确，但是依赖表达式优先级，应禁止使用该技巧。\n\n```C\nuint32_t a = 0xffffffffU;\nuint32_t b = 1;\nuint64_t c = 2;\nuint64_t x = a + b + c;             // 结果非预期, x的值为2\nuint64_t y = static_cast<uint64_t>(a + b) + c;   // 结果非预期, y的值为2\nuint64_t z = a + c + b;             // 结果正确，但是依赖表达式顺序，禁止使用该技巧\nuint64_t t = a + (b + c);            // 结果正确，但是依赖表达式优先级，禁止使用该技巧\nuint64_t m = a + b * c;             // 结果正确，但是依赖表达式优先级，禁止使用该技巧\n```",
        "修改建议": "当组合表达式的运算结果赋值给比它更大类型，或者与比它更大类型进行运算时，应显式转换其中一个操作数为较大的类型。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "190"
    },
    {
        "规则名称": "G.INC.02 头文件的扩展名只使用.h，不使用非习惯用法的扩展名，如.inc【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "headerFilesufix:ph,inc,hpp",
        "正确示例": "##### 场景1：头文件扩展名为.inc\r\n- 修复示例：\r\n\r\n```c\r\n// sample.h 开始\r\n// 符合\r\n\r\n// sample.h 结束\r\n```",
        "错误示例": "##### 场景1：头文件扩展名为.inc\r\n- 错误示例：头文件扩展名为.inc\r\n\r\n```c\r\n// sample.inc 开始\r\n// 不符合\r\n\r\n// sample.inc 结束\r\n```",
        "修改建议": "修改头文件扩展名为.h。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "WordsTool.238 极品",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.188 UsbManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.RES.10-CPP 使用std::make_shared 而不是new 创建std::shared_ptr",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用std::shared_ptr\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo() \r\n{\r\n    std::unique_ptr<int> p1 = std::make_shared<int>(); // 符合\r\n}\r\n\r\nstd::unique_ptr<Base> GetPointer() \r\n{\r\n    return std::make_shared<Base>(); // 符合\r\n}\r\n```",
        "错误示例": "##### 场景1：使用std::shared_ptr\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo() \r\n{\r\n    std::unique_ptr<int> p1 = std::shared_ptr<int>(new int());  // 不符合\r\n}\r\n\r\nstd::shared_ptr<Base> GetPointer() \r\n{\r\n    return std::shared_ptr<Base>(new Base); // 不符合\r\n}\r\n```",
        "修改建议": "使用`make_shared`创建`shared_ptr`。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.54 CreateMultiparty",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.105 InCallAdapter",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.124 Kotlin",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.5 无LICENSE文件",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.11 必须检查安全函数返回值，并进行正确的处理",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\nbool ParseBuff(unsigned char *destBuff, size_t destMax)\n{\n    unsigned char *src = ...\n    size_t srcLen = ...\n    if (destBuff == NULL || destMax == 0) {\n        return false; // 返回失败\n    }\n    errno_t ret = memcpy_s(destBuff, destMax, src, srcLen);\n    if (ret != EOK) {\n        Log(\"memcpy_s failed, err = %d\\n\", err);\n        return false; // 返回失败\n    }\n    ...\n    return true;\n}\n```",
        "错误示例": "安全函数memcpy_s可能拷贝失败，未检查返回值\n```C\nBOOL ParseBuff(BYTE* destBuff, size_t destMax, BYTE* src, size_t srcLen)\n{\n    errno_t err = EOK;\n    if (destBuff == NULL || destMax == 0) {\n        return FALSE; // 返回失败\n    }\n    memcpy_s(destBuff, destMax, src, srcLen); // 未检查返回值\n    return TRUE;\n}\n```",
        "修改建议": "需要对安全函数的返回值进行检查，并在返回错误状态时，做出相应的错误处理。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "252"
    },
    {
        "规则名称": "G.CNS.01-CPP 禁止使用小写字母“l”作为数值型字面量后缀",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，通过使用大写字母 `L` 而不是小写字母 `l` 来消除视觉上的错觉。\n\n```cpp\nconstexpr long long BARRETT_REDUCTION = 0xFF6511LL;\nconstexpr long double MAX_DEGREE = 180.0L;\n```",
        "错误示例": "如下代码中，常量的值分别是 `0xFF6511`和`180.0`，但是视觉上像是 `0xFF651111`和`180.01`。\n\n```cpp\nconstexpr long long BARRETT_REDUCTION = 0xFF6511ll;\nconstexpr long double MAX_DEGREE = 180.0l;\n```",
        "修改建议": "小写\"l\"替换成大写\"L\"。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1107"
    },
    {
        "规则名称": "WordsTool.214 安卓",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.73 DefaultDialerManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.RES.11-CPP new和delete配对使用，new[]和delete[]配对使用",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nclass C {\npublic:\n    C(size_t len) : arr(new int[len]) {}\n\n    ~C()\n    {\n        delete[] arr;\n    }\n\nprivate:\n    int* arr;\n};\n```",
        "错误示例": "```cpp\nclass C {\npublic:\n    C(size_t len) : arr(new int[len]) {}\n\n    ~C()\n    {\n        delete arr;                       // 不符合：此处应使用delete[]\n    }\n\nprivate:\n    int* arr;\n};\n```",
        "修改建议": "使用相应的delete操作符",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "762"
    },
    {
        "规则名称": "WordsTool.207 mingw",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.125 liblog",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CMT.04-CPP 不写空有格式的函数头注释",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "函数头注释统一放在函数声明或定义上方，并选择使用如下风格之一：\n\n**使用`//`**\n\n```cpp\n// 单行函数头\nint Fun1();\n\n// 多行函数头\n// 第二行\nint Fun2();\n```\n\n**使用 `/*  */`**\n\n```cpp\n/* 单行函数头 */  \nint Fun1();\n\n/*\n * 单行或多行函数头\n * 第二行\n */\nint Fun2();\n```\n\n函数头注释内容**可选**，其内容不限于：功能说明、返回值、性能约束、用法、内存约定、可重入的要求等等。",
        "错误示例": "下面的函数头注释存在两个问题，应避免出现类似的注释：\n\n- 参数、返回值，空有格式没内容\n- 注释中的函数名信息冗余\n\n```cpp\n/*\n * 函数名：WriteData\n * 功能：写入字符串\n * 参数：\n * 返回值：\n */\nint WriteData(const unsigned char* buf, size_t len);\n```",
        "修改建议": "补充内容或者删除空有格式的注释。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1116"
    },
    {
        "规则名称": "G.NAM.03-CPP 使用统一的命名风格",
        "问题级别": "提示",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "MethodCase:CamelCase;EnumForbiddenWord:;ConstantParameterCase:camelBack;UnionCase:CamelCase;GlobalConstantCase:UPPER_CASE;ClassCase:CamelCase;NestingThreshold:4;ClassCase:CamelCase;GlobalVariablePrefixes:;EnumModuleLevel:;EnumModuleLevel:;LocalVariableCase:camelBack;GlobalVariablePrefixes:;ConstantParameterModuleLevel:;EnumConstantCase:UPPER_CASE;ConstantParameterModuleLevel:;MacroDefinitionCase:UPPER_CASE;IgnoreFailedSplit:;ParameterPackCase:;GlobalVariableCase:camelBack;GlobalVariableCase:camelBack;ParameterCase:camelBack;MemberCase:camelBack;ModuleNamesIgnoreNS:;MethodCase:CamelCase;HungarianPrefixes:;StructCase:CamelCase;ParameterPackCase:;ModuleNames:;GlobalConstantCase:UPPER_CASE;StaticVariableCase:camelBack;EnumConstantCase:UPPER_CASE;IgnoreFailedSplit:;ParameterCase:camelBack;LineThreshold:50;ModuleNames:;LineThreshold:50;GlobalVariablePrefix:g_;FunctionCase:CamelCase;UnionCase:CamelCase;EnumForbiddenWord:;GlobalVariablePrefix:g_;ConstantParameterCase:camelBack;HungarianPrefixes:;EnumCase:CamelCase;NestingThreshold:4;StaticVariableCase:camelBack;MemberCase:camelBack;LocalVariableCase:camelBack;MacroDefinitionCase:UPPER_CASE;StructCase:CamelCase;FunctionCase:CamelCase;ParameterThreshold:5;ModuleNamesIgnoreNS:;ParameterThreshold:5;EnumCase:CamelCase",
        "正确示例": "##### 场景1：全局变量命名没有g_前缀\r\n- 修复示例1：\r\n```cpp\r\nint g_variable;                 // 符合：全局变量，带g_前缀的小驼峰\r\n\r\nSomeClass g_someObject{};       // 符合：全局对象，带g_前缀的小驼峰\r\n\r\nstatic int g_blockCount = 0;    // 符合：文件作用域中的全局变量，带g_前缀的小驼峰\r\n\r\nnamespace Utils {\r\nint g_fileCount = 0;            // 符合：命名空间中的全局变量，带g_前缀的小驼峰\r\n}\r\n```\r\n\r\n##### 场景2：选择驼峰命名风格，但是使用时没有遵循\r\n- 修复示例1：遵循驼峰命名风格。\r\n```cpp\r\nnamespace FileUtils {                       // 符合：命名空间使用“大驼峰”\r\n...\r\n}\r\n\r\nclass SomeClass {                           // 符合：类类型使用“大驼峰”\r\n    void SetData();                         // 符合：成员函数使用“大驼峰”\r\n    ...\r\n    std::string m_msg;                      // 符合：类成员变量使用“小驼峰”\r\n};\r\n\r\nstruct StrType {                            // 符合：结构体类型使用“大驼峰”\r\n    int typeMember;                         // 符合：结构体中字段使用“小驼峰”\r\n};\r\n\r\nvoid Compare(int leftVal, int rightVal);    // 符合：函数大驼峰，参数小驼峰\r\n\r\nchar * const VERSION = \"V100\";              // 符合：常量用全大写下划线分割\r\n```",
        "错误示例": "##### 场景1：全局变量命名没有g_前缀\r\n- 错误示例：\r\n\r\n```cpp\r\nint Global_variable = 7;    // 不符合\r\n\r\nSomeClass G_someObject{};   // 不符合\r\n\r\nstatic int blockCount = 0;  // 不符合\r\n\r\nnamespace Utils {\r\nint file_Count = 0;         // 不符合\r\n}\r\n```\r\n\r\n##### 场景2：选择驼峰命名风格，但是使用时没有遵循\r\n- 错误示例：\r\n\r\n```cpp\r\nnamespace FILEUTILS {                       // 不符合\r\n...\r\n}\r\n\r\nclass Some_Class {                          // 不符合\r\n    void set_data();                        // 不符合\r\n    ...\r\n    std::string Msg;                        // 不符合\r\n};\r\n\r\nstruct strType {                            // 不符合\r\n    int Type_Member;                        // 不符合\r\n};\r\n\r\nvoid compare(int left_val, int right_val);  // 不符合\r\n\r\nchar * const version = \"V100\";              // 不符合\r\n```",
        "修改建议": "根据提示信息验证代码风格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "WordsTool.138 Morpho",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CTL.06 goto语句只能向下跳转【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用向上跳转的goto语句\r\n- 修复示例：\r\n```c\r\nvoid Func(void)\r\n{\r\n    int loopCnt = 0;\r\n\r\n    while(loopCnt++) {\r\n        if (loopCnt == MAX_COUNT) {\r\n            goto LOOP2; // 符合：只能向下跳转\r\n        }\r\n        ...\r\n    }\r\n    ...\r\n\r\nLOOP2:\r\n    ...\r\n}\r\n\r\n```",
        "错误示例": "##### 场景1：使用向上跳转的goto语句\r\n- 错误示例：\r\n```c\r\nvoid Func(void)\r\n{\r\n    int loopCnt = 0;\r\n\r\nLOOP1:\r\n    loopCnt++;\r\n    if (loopCnt < MAX_COUNT) {\r\n        goto LOOP1;     // 不符合：向上跳转\r\n    } else {\r\n        ...\r\n    }\r\n    ...\r\n\r\n}\r\n\r\n```",
        "修改建议": "1. 除了必须使用goto的场景（如在函数末尾进行错误处理）外，不应使用goto语句，可使用结构化的控制语句（如if、for、while等）来实现程序逻辑。\r\n2. 必须使用goto的场景，goto语句不要向上跳转，只能向下跳转。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1075"
    },
    {
        "规则名称": "WordsTool.90 FirstBeat",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CNS.03-CPP 对于不会修改成员变量的成员函数应使用const修饰",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1",
        "正确示例": "##### 场景1：函数本意是不需要修改成员变量，但未加const保护\r\n- 修复示例1：在函数声明中添加const\r\n\r\n```c++\r\nclass Foo {\r\npublic:\r\n    ...\r\n    void PrintValue() const  // 符合\r\n    {\r\n        std::cout << value;\r\n    }\r\n    int GetValue() const    // 符合\r\n    {\r\n        return value;\r\n    }\r\nprivate:\r\n    int value;\r\n};\r\n```",
        "错误示例": "##### 场景1：函数本意是不需要修改成员变量，但未加const保护\r\n- 错误示例：\r\n\r\n```c++\r\nclass Foo {\r\npublic:\r\n    ...\r\n    void PrintValue()  // 不符合\r\n    {\r\n        std::cout << value;\r\n    }\r\n    int GetValue()    // 不符合\r\n    {\r\n        return value;\r\n    }\r\nprivate:\r\n    int value;\r\n};\r\n```",
        "修改建议": "设计意图上，对于不需要修改成员变量的成员函数都应使用const修饰。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "471"
    },
    {
        "规则名称": "WordsTool.200 profiler",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.180 Telecom",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.179 Talkback",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.88 Fernflower",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "FossScan.1 OpenSource Software",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "FossScan",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.257 世界领先",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.09 case/default 语句相对 switch 缩进一层【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：case/default语句相对switch未缩进一层\r\n- 修复示例：\r\n\r\n```cpp\r\nswitch (var) {\r\n    case CASE1:         // 符合：缩进\r\n        DoSomething1(); // 符合：缩进\r\n        break;\r\n    case CASE2: {       // 符合：带大括号格式\r\n        DoSomething2();\r\n        break;\r\n    }\r\n    ...\r\n    default:\r\n        break;\r\n}\r\n```",
        "错误示例": "##### 场景1：case/default语句相对switch未缩进一层\r\n- 错误示例：\r\n\r\n```cpp\r\nswitch (var) {\r\ncase CASE1:             // 不符合：case 未缩进\r\n    DoSomething1();\r\n    break;\r\n...\r\ndefault:                // 不符合：default 未缩进\r\n    break;\r\n}\r\n```",
        "修改建议": "建议通过格式化工具自动修复。\r\ncase/default语句相对switch缩进一层，case中的语句相对case缩进一层。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.91 flutter",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.42 CarSensor",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.60 CXAction",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CMT.02 代码注释置于对应代码的上方或右边【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：注释符与代码之间没有空格\r\n- 修复示例：\r\n\r\n```c++\r\nint x; // 符合：注释符与代码之间至少留有1个空格\r\n\r\nint y; /* 符合：注释符与代码之间至少留有1个空格 */\r\n```\r\n\r\n##### 场景2：注释位于代码中间\r\n- 修复示例1：\r\n```c++\r\nint y = 1; // 注释          // 符合：注释位于代码右侧\r\n```\r\n- 修复示例2：\r\n```c++\r\nint y = 1; /* 注释 */       // 符合：注释位于代码右侧\r\n```\r\n\r\n- 修复示例3：\r\n```c++\r\n/*\r\n * 注释\r\n * 第二行\r\n */\r\nint y = 1;                  // 符合：注释位于代码上方\r\n```",
        "错误示例": "##### 场景1：注释符与代码之间没有空格\r\n- 错误示例：\r\n\r\n```c++\r\nint x;// 不符合：注释符与代码之间无空格\r\n\r\nint y;/* 不符合：注释符与代码之间无空格 */\r\n```\r\n\r\n##### 场景2：注释位于代码中间\r\n- 错误示例：\r\n\r\n```c++\r\nint y /* 注释 */ = 1;       // 不符合：注释位于代码中间\r\n```",
        "修改建议": "将注释放置于代码`上一行`或`右边`。\r\n1. 当注释内容不长时，可考虑置于对应代码右边。\r\n2. 如果注释内容超过行宽，或者注释内容多行时，可考虑将注释置于代码上一行。可通过工具格式化。注释符与代码之间留有1个空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1113"
    },
    {
        "规则名称": "WordsTool.122 jetpack",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--三元条件表达式【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：条件表达式中问号两边没有空格\r\n- 修复示例1：给问号两边都加上空格\r\n\r\n```cpp\r\nc = (a > b) ? a : b;        // 符合\r\n```\r\n##### 场景2：条件表达式中冒号两边没有空格\r\n- 修复示例1：给冒号两边都加上空格\r\n\r\n```cpp\r\nc = (a > b) ? a : b;        // 符合\r\n```",
        "错误示例": "##### 场景1：条件表达式中问号两边没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = (a > b)?a : b;          // 不符合：'?' 左右没有空格\r\nc = (a > b) ?a : b;         // 不符合：'?' 右边没有空格\r\nc = (a > b)? a : b;         // 不符合：'?' 左边没有空格\r\n```\r\n##### 场景2：条件表达式中冒号两边没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = (a > b) ? a:b;          // 不符合：':' 左右没有空格\r\nc = (a > b) ? a :b;         // 不符合：':' 右边没有空格\r\nc = (a > b) ? a: b;         // 不符合：':' 左边没有空格\r\n```",
        "修改建议": "条件表达式`问号`和`冒号`左右两边需要有一个空格，请补齐。\r\n\r\n建议通过格式化工具自动修复。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.236 顶尖",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUN.07-CPP 不要使用std::move返回函数局部变量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用`std::move`返回函数局部变量\r\n- 修复示例：\r\n\r\n```cpp\r\nSomeType Fun()\r\n{\r\n    SomeType result;\r\n    ...\r\n    return result;            // 符合： 编译器可以优化为直接在返回位置构造result\r\n}\r\n```",
        "错误示例": "##### 场景1：使用`std::move`返回函数局部变量\r\n- 错误示例：\r\n\r\n```cpp\r\nSomeType Fun()\r\n{\r\n    SomeType result;\r\n    ...\r\n    return std::move(result); // 不符合： 阻止了返回值优化\r\n}\r\n```",
        "修改建议": "返回函数局部变量时，不要使用 std::move()。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "562"
    },
    {
        "规则名称": "WordsTool.215 ADT",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.196 VNDK",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.112 ios CoreData",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.97 harmonyos",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.08-CPP 确保对象在使用之前已被初始化",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数内的代码块中的变量读取前未经初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x = 0;\r\n    ^{int y = x;} (); // 符合\r\n}\r\n```\r\n\r\n##### 场景2：二元操作符操作数未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint32_t Func()\r\n{\r\n    int32_t val;\r\n    if (conditionErr) {\r\n        printf(...);\r\n        return 0;\r\n    } else {\r\n        val = GetValue();\r\n    }\r\n    return val + 1; // 符合：加法运算的左操作数已初始化\r\n}\r\n```\r\n\r\n##### 场景3：函数返回值未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    int x = OUTPUT_ERROR;\r\n    ...\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    return x; // 符合：返回的已被初始化\r\n}\r\n```\r\n\r\n##### 场景4：解引用空指针\r\n- 修复示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t member;\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *p = new(std::nothrow) A;\r\n    if (p == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    std::cout << p->member << std::endl; // 符合\r\n    delete p;\r\n    p = nullptr; // 指针释放后被置空\r\n    ...\r\n}\r\n```\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *a = nullptr;\r\n    ... // 指针a赋值操作\r\n    if (a != nullptr) {\r\n        int32_t x = a->Get(); // 符合：解引用之前已判空\r\n    }\r\n}\r\n```\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *a = new(std::nothrow) A;\r\n    if (a == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    int32_t x = a->Get(); // 符合：解引用之前已判空\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景5：一元操作符的操作数读取之前未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    bool x = true;\r\n    bool y = !x; // 符合\r\n}\r\n```\r\n\r\n##### 场景6：赋值的右操作数未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x = OUTPUT_ERROR;\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    ...\r\n    int y = x; // 符合\r\n}\r\n```\r\n\r\n##### 场景7：数组索引可能未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func(int arr[], uint32_tarrLen)\r\n{\r\n    uint32_t index;\r\n\r\n    if (conditionErr) {\r\n        printf(...);\r\n        return;    // 异常分支返回\r\n    } else {\r\n        index = GetIndex();\r\n    }\r\n\r\n    int val = arr[index]; // 符合：此处数组索引已初始化\r\n}\r\n```\r\n\r\n##### 场景8：条件语句中变量未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    bool x = false;\r\n    ...\r\n    if (cond) {\r\n        x = IsExit();\r\n    }\r\n    if (x) { ... } // 符合\r\n}\r\n```",
        "错误示例": "##### 场景1：函数内的代码块中的变量读取前未经初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x;\r\n    ^{int y = x;} (); // 不符合：x未初始化\r\n}\r\n```\r\n\r\n##### 场景2：二元操作符操作数未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint32_t Func()\r\n{\r\n    int32_t val;\r\n    if (conditionErr) {\r\n        printf(...);\r\n    } else {\r\n        val = GetValue();\r\n    }\r\n    return val + 1; // 不符合：加法运算的左操作数可能未初始化\r\n}\r\n```\r\n\r\n##### 场景3：函数返回值未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    int x;\r\n    ...\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    return x; // 不符合：返回的x可能未初始化\r\n}\r\n```\r\n\r\n##### 场景4：解引用空指针\r\n- 错误示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t member;\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *p = new(std::nothrow) A;\r\n    if (p == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    delete p;\r\n    p = nullptr; // 指针释放后被置空\r\n    ...\r\n    std::cout << p->member << std::endl; // 不符合：解引用空指针\r\n}\r\n```\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *a = nullptr;\r\n    int32_t x = a->Get(); // 不符合：解引用空指针\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景5：一元操作符的操作数读取之前未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    bool x;\r\n    bool y = !x; // 不符合：x未初始化\r\n}\r\n```\r\n\r\n##### 场景6：赋值的右操作数未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x;\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    ...\r\n    int y = x; // 不符合：x可能未初始化\r\n}\r\n```\r\n\r\n##### 场景7：数组索引可能未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func(int arr[], uint32_t arrLen)\r\n{\r\n    uint32_t index;\r\n\r\n    if (conditionErr) {\r\n        printf(...);\r\n    } else {\r\n        index = GetIndex();\r\n    }\r\n\r\n    int val = arr[index]; // 不符合：此处数组索引可能未初始化\r\n}\r\n```\r\n\r\n##### 场景8：条件语句中变量未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    bool x;\r\n    ...\r\n    if (cond) {\r\n        x = IsExit();\r\n    }\r\n    if (x) { ... } // 不符合：x可能未初始化\r\n}\r\n```",
        "修改建议": "变量使用前进行初始化",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "456,457"
    },
    {
        "规则名称": "WordsTool.147 openjdk",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.04-CPP 拷贝构造函数和拷贝赋值操作符应该同时声明",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：只声明了拷贝构造函数，没有声明拷贝赋值操作符\r\n- 修复示例1：最常见的情况，拷贝构造函数和拷贝赋值操作符以`相同的方式`来进行处理\r\n\r\n```cpp\r\n// 符合：拷贝构造函数和拷贝赋值操作符同时声明\r\nclass Foo {\r\npublic:\r\n    ...\r\n    Foo(const Foo& other);\r\n    Foo& operator=(const Foo& other);\r\n    ...\r\n};\r\n```\r\n- 修复示例2：其他的情况，拷贝构造函数和拷贝赋值操作符以`不同的方式`来进行处理\r\n\r\n```cpp\r\n// 符合：拷贝构造函数和拷贝赋值操作符同时声明\r\nclass Foo {\r\npublic:\r\n    ...\r\n    // 在以面向对象方式设计的对象体系，对象只能克隆和使用引用传递，不能赋值\r\n    // 此时，删除拷贝赋值操作符（=delete），但仍声明拷贝构造函数\r\n    Foo(const Foo& other);\r\n    Foo& operator=(const Foo&) = delete;\r\n    ...\r\n};\r\n```",
        "错误示例": "##### 场景1：只声明了拷贝构造函数，没有声明拷贝赋值操作符\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：只声明了拷贝构造函数，没有声明拷贝赋值操作符\r\nclass Foo {\r\npublic:\r\n    ...\r\n    Foo(const Foo& other);\r\n    ...\r\n};\r\n```",
        "修改建议": "同时声明拷贝构造函数和拷贝赋值操作符，包括自定义实现、=default和=delete。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.PRE.07 宏的名称不应与关键字相同",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "```c\n// 不符合：改变了int的行为，导致后面包含标准头文件时，程序出现未定义的行为\n#define int OTHER_TYPE\n#include <stdlib.h>\n\n// 不符合：重定义关键字\n#define while(x) for (; (x);)\n```",
        "修改建议": "修改宏的名称。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "G.STD.05-CPP 确保用于字符串操作的缓冲区有足够的空间容纳字符数据和结束符，并且字符串以null结束符结束",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "使用安全函数实现整数转换为10进制形式的字符串。\n```C\nchar buf[BUFFER_SIZE] = {0};\nstd::cin.width(sizeof(buf) - 1); // 注意需要缓冲区长度-1，以留出字符串末尾'\\0'的空间\nstd::cin >> buf;\n```\n\n```C\nvoid Foo(std::istream& in)\n{\n    char buffer[BUFFER_SIZE];\n    if (!in.read(buffer, sizeof(buffer)) { // 注意in.read()不能保证'\\0'结尾\n        ... // 错误处理\n        return;\n    }\n    std::string str(buffer, in.gcount()); // 让std::string构造函数，只读取指定长度的字符内容\n    ...\n}\n```\n\n```C\nvoid Foo(std::istream& in)\n{\n    std::string s;\n    in.width(MAX_NEED_SIZE);\n    in >> s;    // 符合：已经限制读取的最大长度\n    ...\n}\n```",
        "错误示例": "```C\nchar buf[BUFFER_SIZE];\nstd::cin >> buf;\n```\n\n```C\nvoid Foo(std::istream& in)\n{\n    char buffer[BUFFER_SIZE];\n    if (!in.read(buffer, sizeof(buffer))) { // 注意：in.read()不能保证'\\0'结尾\n      ... // 错误处理\n        return;\n    }\n    std::string str(buffer);    // 不符合：字符串没有结尾的'\\0'\n    ...\n}\n```\n\n```C\nvoid Foo(std::istream& in)\n{\n    std::string s;\n    in >> s;     // 不符合：没有限制待读取的长度，可能导致资源消耗或攻击\n    ...\n}\n```",
        "修改建议": "1. 使用itoa/ltoa函数需确保目的缓冲区有足够的长度存储转换后的字符串，防止溢出；\n2. 使用realpath函数的第二个参数应为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏。linux环境：PATH_MAX的定义在/usr/include/linux/limits.h；windows环境：MAX_PATH的定义在minwindef.h (visual studio 2017)",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "119"
    },
    {
        "规则名称": "G.EXP.05 不要向sizeof传递有副作用的操作数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：将指针当做数组进行sizeof操作时，返回的是指针的内存大小，而不是指针指向对象的大小。\r\n- 修复示例1：使用buffer缓冲区申请时，设置的内存大小。\r\n\r\n```c\r\n#define SIZE 1000\r\n\r\nvoid TestGoodCase1()\r\n{\r\n    char path[MAX_PATH];\r\n    char *buffer = (char *)malloc(SIZE);\r\n    ...\r\n    memset(path, 0, sizeof(path));\r\n\r\n    // 符合：使用申请buffer缓冲区的大小\r\n    memset(buffer, 0, SIZE);\r\n}\r\n```\r\n##### 场景2：在sizeof的操作数内，对变量进行赋值或自增自减的操作。\r\n- 修复示例1：在sizeof操作数外对变量做赋值或者自增自减。\r\n\r\n```c\r\n#define INIT_NUM 1000\r\n\r\nvoid TestGoodCase2()\r\n{\r\n    int32_t data = INIT_NUM;\r\n    data++;\r\n    size_t size = sizeof(data);             // 符合\r\n    printf(\"%zu\\n\", size);\r\n}\r\n```",
        "错误示例": "##### 场景1：将指针当做数组进行sizeof操作时，返回的是指针的内存大小，而不是指针指向对象的大小。\r\n- 错误示例：\r\n\r\n```c\r\n#define SIZE 1000\r\n\r\nvoid TestBadCase1()\r\n{\r\n    char path[MAX_PATH];\r\n    char *buffer = (char *)malloc(SIZE);\r\n    ...\r\n    memset(path, 0, sizeof(path));\r\n\r\n    // 不符合：错误使用指针的内存大小\r\n    memset(buffer, 0, sizeof(buffer));\r\n}\r\n```\r\n##### 场景2：在sizeof的操作数内，对变量进行赋值或自增自减的操作。\r\n- 错误示例：\r\n\r\n```c\r\n#define INIT_NUM 1000\r\n\r\nvoid TestBadCase2()\r\n{\r\n    int32_t data;\r\n    size_t size1 = sizeof(data = INIT_NUM); // 不符合：这里data没有被赋值\r\n    size_t size2 = sizeof(data++);          // 不符合：这里data不会自增\r\n    printf(\"%zu, %zu\\n\", size1, size2);\r\n}\r\n```",
        "修改建议": "禁止通过对指针变量进行sizeof操作来获取数组大小。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "WordsTool.276 质量检测",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.87 FastApp",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.55 CTCall/CXCall",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.INT.03 确保除法和余数运算不会导致除零错误(被零除)【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码示例中，添加numB是否为0的校验，防止除零错误。\n```c\nint numA = ... // 来自外部数据\nint numB = ... // 来自外部数据\nint result = 0;\nif ((numB == 0) || ((numA == INT_MIN) && (numB == -1))) {\n    ... // 错误处理\n}\nresult = numA / numB;\n...\n```",
        "错误示例": "有符号整数类型的除法运算如果限制不当，会导致溢出。如下示例对有符号整数进行的除法运算做了防止溢出限制，确保不会导致溢出，但不能防止有符号操作数numA和numB之间的除法过程中出现除零错误。\n```C\nint numA = ... // 来自外部数据\nint numB = ... // 来自外部数据\nint result = 0;\nif ((numA == INT_MIN) && (numB == -1)) {\n  ... // 错误处理\n}\nresult = numA / numB; // 可能出现除零错误\n...\n```",
        "修改建议": "如果除数为外部变量，则需要在使用前进行非零校验",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "369"
    },
    {
        "规则名称": "G.FMT.01 非纯ASCII码源文件使用 UTF-8 编码【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "使用UTF-8编码格式。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "174"
    },
    {
        "规则名称": "WordsTool.172 SmsMessage",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.06 函数式宏要简短",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```c\r\n// 符合: 将函数式宏改为函数\r\nvoid BubbleSort(int arr[], int n)\r\n{\r\n    int i, j;\r\n    for (i = 0; i < n - 1; i++) {\r\n        for (j = 0; j < n - i - 1; j++) {\r\n            if (arr[j] > arr[j + 1]) {\r\n                int temp = arr[j];\r\n                arr[j] = arr[j + 1];\r\n                arr[j + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
        "错误示例": "```c\r\n// 不符合: 函数式宏超过10行\r\n#define BUBBLESORT(arr, n)                \\\r\n    int i, j;                             \\\r\n    for (i = 0; i < n - 1; i++) {         \\\r\n        for (j = 0; j < n - i - 1; j++) { \\\r\n            if (arr[j] > arr[j + 1]) {    \\\r\n                int temp = arr[j];        \\\r\n                arr[j] = arr[j + 1];      \\\r\n                arr[j + 1] = temp;        \\\r\n            }                             \\\r\n        }                                 \\\r\n    }\r\n```",
        "修改建议": "减少函数式宏的复杂度或者改成函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "G.FUU.11 必须检查安全函数返回值，并进行正确的处理【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：未对memcpy_s的返回值进行校验\r\n- 修复示例：\r\n\r\n```cpp\r\nbool ParseBuff(unsigned char *destBuff, size_t destMax)\r\n{\r\n    unsigned char *src = ...\r\n    size_t srcLen = ...\r\n    if (destBuff == nullptr || destMax == 0) {\r\n        return false; // 返回失败\r\n    }\r\n    errno_t ret = memcpy_s(destBuff, destMax, src, srcLen); // 符合：增加返回值校验\r\n    if (ret != EOK) {\r\n        Log(\"memcpy_s failed, ret = %d\\n\", ret);\r\n        return false; // 返回失败\r\n    }\r\n    ...\r\n    return true;\r\n}\r\n```\r\n##### 场景2：未对memset_s的返回值进行校验\r\n- 修复示例：\r\n```cpp\r\nbool GoodCase2(char *destBuff, size_t destMax, size_t count)\r\n{\r\n    if (destBuff == nullptr || destMax == 0 || count == 0) {\r\n        return false; // 返回失败\r\n    }\r\n    // 符合：对安全函数的返回值进行校验\r\n    errno_t rc = memset_s(destBuff, destMax, 0, count);\r\n    if (rc != EOK) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n```",
        "错误示例": "##### 场景1：未对memcpy_s的返回值进行校验\r\n- 错误示例：\r\n\r\n```cpp\r\nbool ParseBuff(unsigned char *destBuff, size_t destMax)\r\n{\r\n    unsigned char *src = ...\r\n    size_t srcLen = ...\r\n    if (destBuff == nullptr || destMax == 0) {\r\n        return false; // 返回失败\r\n    }\r\n    memcpy_s(destBuff, destMax, src, srcLen); // 不符合：未校验安全函数返回值\r\n    ...\r\n    return true;\r\n}\r\n```\r\n##### 场景2：未对memset_s的返回值进行校验\r\n- 错误示例：\r\n```cpp\r\nbool BadCase02(char *destBuff, size_t destMax, size_t count)\r\n{\r\n    if (destBuff == nullptr || destMax == 0 || count == 0) {\r\n        return false; // 返回失败\r\n    }\r\n\r\n    // 不符合：未检查安全函数返回值\r\n    memset_s(destBuff, destMax, 0, count);\r\n\r\n    return true;\r\n}\r\n```",
        "修改建议": "需要对安全函数的返回值进行检查，并在返回错误状态时，做出相应的错误处理。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "252"
    },
    {
        "规则名称": "WordsTool.48 CommandsInterface",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.11 ANR",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.96 GsmCdmaCall",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.142 Nbaio",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.85 EuiccController",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.01 处理函数的返回值【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：未处理malloc函数返回值\r\n- 修复示例：\r\n\r\n```c\r\nchar *p = (char *)malloc(SOME_SIZE);\r\nif (p == NULL) {    // 符合: 对返回值进行合法性检查\r\n    ...\r\n    return ...;\r\n}\r\n// 符合: 此处符合可省略memset_s返回值检查的例外场景，可以显式忽略掉返回值的检查\r\n(void)memset_s(p, SOME_SIZE, 0, SOME_SIZE);\r\n```\r\n##### 场景2：未处理fopen函数返回值\r\n- 修复示例：\r\n\r\n```c\r\nFILE *fp = fopen(filePath, \"r\");\r\nif (fp == NULL) {               // 符合: 对返回值进行合法性检查\r\n    ...\r\n    return ...;\r\n}\r\nchar ch = fgetc(fp);\r\n...\r\nfclose(fp);\r\n```",
        "错误示例": "##### 场景1：未处理malloc函数返回值\r\n- 错误示例：\r\n\r\n```c\r\nchar *p = (char *)malloc(SOME_SIZE);\r\nmemset_s(p, SOME_SIZE, 0, SOME_SIZE);   // 不符合: 未检查返回值 p 的合法性就直接使用。\r\n```\r\n##### 场景2：未处理fopen函数返回值\r\n- 错误示例：\r\n\r\n```c\r\nFILE *fp = fopen(filePath, \"r\"); // 不符合：未检查返回值的合法性\r\nchar ch = fgetc(fp);\r\n...\r\nfclose(fp);\r\n```",
        "修改建议": "1. 对返回值进行及时、正确的处理。\r\n2. 如果调用者有意不处理返回值，在经过充分考虑之后，可用`(void)`显式忽略掉。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "252,253,754"
    },
    {
        "规则名称": "WordsTool.289 万能",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.202 clang",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.18 Asset Studio",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.233 全球级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUN.02-CPP 函数的所有声明必须与定义具有一致的参数名",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "CheckDeclVoid:false",
        "正确示例": "保持声明和定义一致。\n\n```cpp\n// Fun.h  \nvoid Fun1(int num);\nvoid Fun2(int num, int count);\n```\n\n```cpp\n// Fun.cpp\nvoid Fun1(int num)\n{\n    ...\n}\n\nvoid Fun2(int num, int count)\n{\n    ...\n}\n```",
        "错误示例": "```cpp\n// Fun.h\nvoid Fun1(int);  // 不符合：缺少参数名，应修改为void Fun1(int num)  \n\n// 不符合：参数名不匹配，应修改为 void Fun2(int num, int count)  \nvoid Fun2(int count, int num);\n// Fun.cpp\nvoid Fun1(int num)\n{\n    ...\n}\n\nvoid Fun2(int num, int count)\n{\n    ...\n}\n```",
        "修改建议": "声明和定义保持一致",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "474,628,843"
    },
    {
        "规则名称": "WordsTool.120 JD-GUI",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.VAR.01 禁止读取未经初始化的变量【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：二元操作符操作数未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint32_t Func()\r\n{\r\n    int32_t val;\r\n    if (conditionErr) {\r\n        printf(...);\r\n        return 0;\r\n    } else {\r\n        val= GetValue();\r\n    }\r\n    return val + 1; // 符合：加法运算的左操作数已初始化\r\n}\r\n```\r\n\r\n##### 场景2：函数内的代码块中的变量读取前未经初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x = 0;\r\n    ^{int y = x;} (); // 符合\r\n}\r\n```\r\n\r\n##### 场景3：一元操作符的操作数读取之前未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    bool x = true;\r\n    bool y = !x; // 符合\r\n}\r\n```\r\n\r\n##### 场景4：条件语句中变量未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    bool x = false;\r\n    ...\r\n    if (cond) {\r\n        x = IsExit();\r\n    }\r\n    if (x) { ... } // 符合\r\n}\r\n```\r\n\r\n##### 场景5：赋值的右操作数未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x = OUTPUT_ERROR;\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    ...\r\n    int y = x; // 符合\r\n}\r\n```\r\n\r\n##### 场景6：解引用空指针\r\n- 修复示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    struct A *a = NULL;\r\n    ... // 指针a赋值操作\r\n    if (a != NULL) {\r\n        int32_t x = a->Get(); // 符合：解引用之前已判空\r\n    }\r\n}\r\n```\r\n\r\n- 修复示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    struct A *a = (struct A *)malloc(sizeof(struct A));\r\n    if (a == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    int32_t x = a->Get(); // 符合：解引用之前已判空\r\n    ...\r\n}\r\n```\r\n- 修复示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t member;\r\n};\r\n\r\nvoid Func()\r\n{\r\n    struct A *p = (struct A *)malloc(sizeof(struct A));\r\n    if (p == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    printf(\"%d\", p->member); // 符合\r\n    free(p);\r\n    p = NULL; // 指针释放后被置空\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景7：函数返回值未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    int x = OUTPUT_ERROR;\r\n    ...\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    return x; // 符合：返回的已被初始化\r\n}\r\n```\r\n\r\n##### 场景8：数组索引可能未初始化\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func(int arr[], uint32_tarrLen)\r\n{\r\n    uint32_t index;\r\n\r\n    if (conditionErr) {\r\n        printf(...);\r\n        return;    // 异常分支返回\r\n    } else {\r\n        index = GetIndex();\r\n    }\r\n\r\n    int val = arr[index]; // 符合：此处数组索引已初始化\r\n}\r\n```",
        "错误示例": "##### 场景1：二元操作符操作数未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint32_t Func()\r\n{\r\n    int32_t val;\r\n    if (conditionErr) {\r\n        printf(...);\r\n    } else {\r\n        val = GetValue();\r\n    }\r\n    return val + 1; // 不符合：加法运算的左操作数可能未初始化\r\n}\r\n```\r\n\r\n##### 场景2：函数内的代码块中的变量读取前未经初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x;\r\n    ^{int y = x;} (); // 不符合：x未初始化\r\n}\r\n```\r\n\r\n##### 场景3：一元操作符的操作数读取之前未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    bool x;\r\n    bool y = !x; // 不符合：x未初始化\r\n}\r\n```\r\n\r\n##### 场景4：条件语句中变量未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    bool x;\r\n    ...\r\n    if (cond) {\r\n        x = IsExit();\r\n    }\r\n    if (x) { ... } // 不符合：x可能未初始化\r\n}\r\n```\r\n\r\n##### 场景5：赋值的右操作数未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func()\r\n{\r\n    int x;\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    ...\r\n    int y = x; // 不符合：x可能未初始化\r\n}\r\n```\r\n\r\n##### 场景6：解引用空指针\r\n- 错误示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *a = NULL;\r\n    int32_t x = a->Get(); // 不符合：解引用空指针\r\n    ...\r\n}\r\n```\r\n\r\n- 错误示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t Get();\r\n};\r\n\r\nvoid Func()\r\n{\r\n    A *a = (struct A *)malloc(sizeof(struct A));\r\n    int32_t x = a->Get(); // 不符合：解引用空指针\r\n    ...\r\n}\r\n```\r\n\r\n- 错误示例：\r\n\r\n```cpp\r\nstruct A {\r\n    int32_t member;\r\n};\r\n\r\nvoid Func()\r\n{\r\n    struct A *p = (struct A *)malloc(sizeof(struct A));\r\n    if (p == NULL) {\r\n        return;\r\n    }\r\n    ...\r\n    free(p);\r\n    p = NULL; // 指针释放后被置空\r\n    ...\r\n    printf(\"%d\", p->member); // 不符合：解引用空指针\r\n}\r\n```\r\n\r\n##### 场景7：函数返回值未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nint Func()\r\n{\r\n    int x;\r\n    ...\r\n    if (cond) {\r\n        x = OUTPUT_FORMAT;\r\n    }\r\n    return x; // 不符合：返回的x可能未初始化\r\n}\r\n```\r\n\r\n##### 场景8：数组索引可能未初始化\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func(int arr[], uint32_t arrLen)\r\n{\r\n    uint32_t index;\r\n\r\n    if (conditionErr) {\r\n        printf(...);\r\n    } else {\r\n        index = GetIndex();\r\n    }\r\n\r\n    int val = arr[index]; // 不符合：此处数组索引可能未初始化\r\n}\r\n```",
        "修改建议": "1. 应该始终在读取变量之前对其进行初始化。\r\n2. 指针解引用前应确保已初始化且非空。\r\n3. 一元操作符的操作数在被读取之前要求具有符合预期的确定值。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "457"
    },
    {
        "规则名称": "WordsTool.104 InboundSmsTracker",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.2 许可证兼容性",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.154 play-services",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.STR.01 确保字符串存储有足够的空间容纳字符数据和null结束符【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：itoa/ltoa不正确使用\r\n- 修复示例：申请的缓冲区长度大于等于对应进制的最大范围\r\n\r\n  ```c++\r\n  void StringOverflowGood01()\r\n  {\r\n      int num = 15;\r\n      // itoa: 10进制的最大范围为10的12次幂，2进制的最大范围为2的33次幂\r\n      // 8进制的最大范围为8的12次幂，16进制的最大范围为16的9次幂\r\n      char str[12] = {0}; // 符合\r\n      itoa(num, str, 10);\r\n\r\n      // ltoa：10进制的最大范围为10的21次幂，2进制的最大范围为2的65次幂\r\n      // 8进制的最大范围为8的23次幂，16进制的最大范围为16的17次幂\r\n      char *str1 = new char[21]; // 符合\r\n      ltoa(num, str1, 10);\r\n      ... // new申请的内存使用完后立即释放\r\n  }\r\n  ```\r\n##### 场景2：realpath不正确使用\r\n- 修复示例：\r\n\r\n  ```c\r\n  void StringOverflowGood02(const char* path)\r\n  {\r\n      char* resolvedPath = new char[PATH_MAX]; // 符合\r\n      // realpath函数的存储缓冲区长度是由PATH_MAX常量申请而来\r\n      realpath(path, resolvedPath); \r\n      ... // new申请的内存使用完后立即释放\r\n  }\r\n  ```",
        "错误示例": "##### 场景1：itoa/ltoa不正确使用\r\n- 错误示例：变量`str`、`str1`缓冲区长度不足，可能会溢出\r\n\r\n  ```c++\r\n  void StringOverflowBad01()\r\n  {\r\n      int num = 15;\r\n      char str[8] = {0};\r\n      // POTENTIAL FLAW:The memory space allocated by str does not reach the maximum storage length and may overflow.\r\n      itoa(num, str, 10);\r\n\r\n      char *str1 = new char[8];\r\n      // POTENTIAL FLAW:The memory space allocated by str does not reach the maximum storage length and may overflow.\r\n      ltoa(num, str1, 10);\r\n      ... // new申请的内存使用完后立即释放\r\n  }\r\n  ```\r\n##### 场景2：realpath不正确使用\r\n- 错误示例：`resolvedPath`缓冲区大小不是用系统提供的`PATH_MAX`或`_PC_PATH_MAX`申请\r\n\r\n  ```c++\r\n  void StringOverflowBad02(const char* path)\r\n  {\r\n      char* resolvedPath = new char[100];\r\n      // POTENTIAL FLAW:The memory space allocated by resolvedPath is not defined by the PATH_MAX constant, or is\r\n      // configured by the _PC_PATH_MAX system value, and may overflow.\r\n      realpath(path, resolvedPath); \r\n      ... // new申请的内存使用完后立即释放\r\n  }\r\n  ```",
        "修改建议": "1. 使用itoa/ltoa函数需确保目的缓冲区有足够的长度存储转换后的字符串，防止溢出；\n2. 使用realpath函数的第二个参数应为系统提供的PATH_MAX或_PC_PATH_MAX，不能使用自定义的宏。linux环境：PATH_MAX的定义在/usr/include/linux/limits.h；windows环境：MAX_PATH的定义在minwindef.h (visual studio 2017)。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "119"
    },
    {
        "规则名称": "WordsTool.35 canvasViewDidFinishRendering",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.OTH.03 禁用rand函数产生用于安全用途的伪随机数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "在类Unix平台上，可以使用/dev/random文件得到随机数。需要注意的是，设备刚启动时，由于硬件输入的熵可能不足，读取该接口可能产生阻塞问题。",
        "错误示例": "程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。",
        "修改建议": "1. 加解密场景必须使用安全随机数（非加解密场景可按误报处理）；\n2. IPSI组件的CRYPT_random，须确保开启了NIST SP 800-90A标准的DRBG后才可使用。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "338"
    },
    {
        "规则名称": "G.EXP.12-CPP 禁止逐位操作非trivially copyable 对象",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：用memcpy_s复制了非trivially copyable对象\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Point {\r\npublic:\r\n    virtual void Fun() {};\r\n    ...\r\n\r\nprivate:\r\n    int x = 0;\r\n    int y = 0;\r\n};\r\n\r\nvoid Foo()\r\n{\r\n    Point a;\r\n    Point b = a; // 符合\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：用memcpy_s复制了非trivially copyable对象\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Point {\r\npublic:\r\n    virtual void Fun() {};\r\n    ...\r\n\r\nprivate:\r\n    int x = 0;\r\n    int y = 0;\r\n};\r\n\r\nvoid Foo()\r\n{\r\n    Point a;\r\n    Point b;\r\n    memcpy(&a, &b, sizeof(Point)); // 不符合：复制了非trivially copyable对象\r\n    ...\r\n}\r\n```",
        "修改建议": "使用构造函数或赋值构造函数来进行初始化或赋值。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--函数名【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数名后面多空格\r\n- 修复示例1：移除函数名后的空格\r\n\r\n```cpp\r\nint main(int argc, char **argv);          // 符合\r\n```",
        "错误示例": "##### 场景1：函数名后面多空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint main (int argc, char **argv);          // 不符合：main 和 ( 之间有空格\r\n```",
        "修改建议": "函数参数列表的小括号与函数名之间不加空格，移除多余的空格。\r\n\r\n建议通过格式化工具自动修复。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.221 最低价",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.22-CPP 确保除法和余数运算不会导致除零错误(被零除)",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：变量除数被赋值零\r\n- 修复示例：作为除数前，进行非零校验\r\n\r\n```cpp\r\n#include <stdlib.h>\r\n\r\nsize_t ReadByte()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid TestGoodCase01()\r\n{\r\n    size_t a = ReadByte();\r\n    // POTENTIAL FLAW GOOD: 对变量进行非0校验\r\n    if (a == 0) {\r\n        return;\r\n    }\r\n    size_t b = 1000 / a;\r\n}\r\n```\r\n\r\n##### 场景2：变量除数未被赋值零\r\n202206及以前版本，默认扫描这种场景。202209及以后版本，需要配置模型，打开开关，才扫描这种场景。\r\n- 修复示例：作为除数前，进行非零校验\r\n\r\n```cpp\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nvoid Getbh(int32_t *p, int32_t len);\r\n\r\nvoid TestGoodCase02(int32_t c, int32_t e)\r\n{\r\n    int32_t a = (rand() - 1);\r\n    // POTENTIAL FLAW GOOD: 对变量进行非0校验\r\n    if (a != 0) {\r\n        int32_t b = 1000 / a;\r\n    }\r\n\r\n    // POTENTIAL FLAW GOOD: 对变量进行非0校验\r\n    bool t = (c != 0) && (100 / c);\r\n    // POTENTIAL FLAW GOOD: 对变量进行非0校验\r\n    e = e != 0 ? 100 / e : 0;\r\n\r\n    int32_t d = 0;\r\n    Getbh(&d, 2);\r\n    // POTENTIAL FLAW GOOD: 对变量进行非0校验\r\n    if (d == 0) {\r\n        return;\r\n    }\r\n    d = 100 % d;\r\n}\r\n```",
        "错误示例": "##### 场景1：变量除数被赋值零\r\n- 错误示例：\r\n\r\n```cpp\r\n#include <stdlib.h>\r\n\r\nsize_t ReadByte()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid TestBadCase01()\r\n{\r\n    size_t a = ReadByte();\r\n    // POTENTIAL FLAW: 变量值必定是0\r\n    size_t b = 1000 / a;\r\n}\r\n```\r\n\r\n##### 场景2：变量除数未被赋值零\r\n202206及以前版本，默认扫描这种场景。202209及以后版本，需要配置模型，打开开关，才扫描这种场景。\r\n- 错误示例：\r\n- \r\n```cpp\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nvoid Getbh(int32_t *p, int32_t len);\r\n\r\nvoid TestBadCase02(int32_t c, int32_t e)\r\n{\r\n    int32_t a = (rand() - 1);\r\n    int32_t b = 1000 / a; // POTENTIAL FLAW: 函数的返回值未做校验\r\n\r\n    int32_t t = 100 / c;  // POTENTIAL FLAW: 函数入参使用前未做校验\r\n    e = 100 / e;          // POTENTIAL FLAW: 函数入参使用前未做校验\r\n\r\n    int32_t d = 0;\r\n    Getbh(&d, 2);\r\n    d = 100 % d;          // POTENTIAL FLAW: 带有&符号的函数参数未做校验\r\n}\r\n```",
        "修改建议": "如果除数为外部变量，则需要在使用前进行非零校验。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "369"
    },
    {
        "规则名称": "G.VAR.02 不要在子作用域中重用变量名【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：两个作用域中使用相同的变量名\r\n- 修复示例：优化变量名，做到清晰表达变量含义，且保证变量名的唯一性。\r\n\r\n```cpp\r\n#define MAX_MESSAGE_LEN 100\r\n#define CUSTOMIZED_SIZE 80\r\nvoid Func(const char *str)\r\n{\r\n    char message[MAX_MESSAGE_LEN];\r\n    ...\r\n    if (str != NULL) {\r\n        char customMsg[CUSTOMIZED_SIZE]; // 符合\r\n        ...\r\n        int ret = sprintf_s(customMsg, sizeof(customMsg), \"Error: %s\\n\", str);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：两个作用域中使用相同的变量名\r\n- 错误示例：\r\n```cpp\r\n#define MAX_MESSAGE_LEN 100\r\n#define CUSTOMIZED_SIZE 80\r\nvoid Func(const char *str)\r\n{\r\n    char message[MAX_MESSAGE_LEN];\r\n    ...\r\n    if (str != NULL) {\r\n        char message[CUSTOMIZED_SIZE];  // 不符合：使用了与外层相同的变量名\r\n        ...\r\n        // MAX_MESSAGE_LEN 使用错误\r\n        int ret = sprintf_s(message, MAX_MESSAGE_LEN, \"Error: %s\\n\", str);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n```",
        "修改建议": "修改变量名，保证两个作用域中变量不重名。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "G.STD.13-CPP 调用格式化输入/输出函数时，使用有效的格式字符串--格式化类型不匹配",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，使用%hhx确保格式串与相应的实参类型严格匹配。\n```c\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...\n```\n注：在C++中不推荐使用sscanf, sprintf等C库函数，可以替换为：std::istringstream, std::ostringstream, std::stringstream等。",
        "错误示例": "如下代码中，格式化输入一个整数到macAddr变量中，但是macAddr为unsigned char类型，而%x对应的是unsigned int类型参数，函数执行完成后会发生写越界。\n```C\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%x:%x:%x:%x:%x:%x\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...\n```",
        "修改建议": "确保format函数参数类型和实际类型一致。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "628"
    },
    {
        "规则名称": "G.RES.06-CPP 避免lambda表达式使用默认捕获模式",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用默认按值捕获模式捕获变量\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Foo {\r\npublic:\r\n    auto Fun()\r\n    {\r\n        int value = 1;\r\n        auto lambda = [value, this]() { data += value; }; // 符合\r\n    }\r\n}\r\n```\r\n##### 场景2：使用默认按引用捕获模式捕获变量\r\n- 修复示例：\r\n\r\n```cpp\r\nint Foo()\r\n{\r\n    int data = 10;\r\n    int *p = &data;\r\n    auto lambda = [value = *p]() { std::cout << value << endl; }; // 符合\r\n\r\n    lambda();\r\n\r\n    p = nullptr;\r\n\r\n    lambda(); // 还是输出10\r\n\r\n    return 0;\r\n}\r\n```",
        "错误示例": "##### 场景1：使用默认按值捕获模式捕获变量\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Foo {\r\npublic:\r\n    auto Fun()\r\n    {\r\n        int value = 1;\r\n        auto lambda = [=]() { data += value; }; // 不符合\r\n    }\r\n}\r\n```\r\n##### 场景2：使用默认按引用捕获模式捕获变量\r\n- 错误示例：\r\n\r\n```cpp\r\nint Foo()\r\n{\r\n    int data = 10;\r\n    int *p = &data;\r\n    auto lambda = [&]() { std::cout << *p << endl; }; // 不符合\r\n\r\n    lambda();\r\n\r\n    p = nullptr;\r\n\r\n    lambda(); // 导致空指针解引用\r\n\r\n    return 0;\r\n}\r\n```",
        "修改建议": "明确写出lambda需要捕获的变量。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "477"
    },
    {
        "规则名称": "WordsTool.250 首款",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.74 devtools",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CTL.03 循环必须安全退出",
        "问题级别": "提示",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "重新设计函数，通过提供服务退出条件，并在资源释放函数ReleaseServiceResource内释放服务循环前申请的资源。\n```C\nbool ParseMsg(unsigned char *msg, size_t msgLen)\n{\n    ...\n    if (msg->type == EXIT_MESSAGE_TYPE) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nvoid DoService(void)\n{\n    ...\n    size_t size = 0;\n    unsigned char *pMsg = NULL;\n    bool doRunServiceFlag = true; // 服务退出条件\n    CreateServiceResource(); // 分配服务资源\n    while (doRunServiceFlag) {\n        pMsg = ReceiveMsg(&size);\n        if (pMsg != NULL) {\n            doRunServiceFlag = ParseMsg(pMsg, size);\n            FreeMsg(pMsg);\n        }\n        size = 0;\n    }\n    ReleaseServiceResource(); // 释放服务资源\n}\n```",
        "错误示例": "以下代码，在一个大循环内，ReceiveMsg函数内申请资源，接收外部数据。ParseMsg函数内处理数据，但没有退出条件，会导致循环前申请的资源无法释放，该程序没有安全退出。\n```C\n...\nvoid DoService(void)\n{\n    ...\n    size_t size = 0;\n    unsigned char *pMsg = NULL;\n    CreateServiceResource(); // 分配服务资源\n    while (true) {\n        pMsg = ReceiveMsg(&size);\n        if (pMsg != NULL) {\n            ParseMsg(pMsg, size);\n            FreeMsg(pMsg);\n        }\n        size = 0;\n    }\n}\n```",
        "修改建议": "确保循环能够正常退出，不出现死循环的情况。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "570,571,835"
    },
    {
        "规则名称": "WordsTool.150 PhoneAccountHandle",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.199 zidaneAAPT",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.118 jdec",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.206 musl",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.114 Jadx",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.244 超级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.156 Procyon-decompiler",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.32 bytecode-viewer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.80 DumpSys",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.11-CPP 在派生类中重写虚函数时禁止重新定义缺省参数值",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在派生类中重写虚函数时重新定义缺省参数值。\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() = default;\r\n    virtual void Display(const std::string& text = \"Base!\") const\r\n    {\r\n        std::cout << text << std::endl;\r\n    }\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    // 符合\r\n    void Display(const std::string& text) const override\r\n    {\r\n        std::cout << text << std::endl;\r\n    }\r\n};\r\n```",
        "错误示例": "##### 场景1：在派生类中重写虚函数时重新定义缺省参数值。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() = default;\r\n    virtual void Display(const std::string& text = \"Base!\") const\r\n    {\r\n        std::cout << text << std::endl;\r\n    }\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    // 不符合：重新定义缺省参数值\r\n    void Display(const std::string& text = \"Derived!\") const override\r\n    {\r\n        std::cout << text << std::endl;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    std::unique_ptr<Base> b = std::make_unique<Derived>();\r\n    std::unique_ptr<Derived> d = std::make_unique<Derived>();\r\n\r\n    b->Display();  // 程序输出结果: Base! 而期望输出：Derived!\r\n    d->Display();  // 程序输出结果: Derived!\r\n    return 0;\r\n}\r\n```",
        "修改建议": "在派生类中重写虚函数时不重新定义缺省参数值。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.201 libcore",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.155 PrivateChat",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--三元条件表达式",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：条件表达式中问号两边没有空格\r\n- 修复示例1：给问号两边都加上空格\r\n```cpp\r\nc = (a > b) ? a : b;        // 符合\r\n```\r\n\r\n##### 场景2：条件表达式中冒号两边没有空格\r\n- 修复示例1：给冒号两边都加上空格\r\n```cpp\r\nc = (a > b) ? a : b;        // 符合\r\n```",
        "错误示例": "##### 场景1：条件表达式中问号两边没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = (a > b)?a : b;          // 不符合：'?' 左右没有空格\r\nc = (a > b) ?a : b;         // 不符合：'?' 右边没有空格\r\nc = (a > b)? a : b;         // 不符合：'?' 左边没有空格\r\n```\r\n\r\n##### 场景2：条件表达式中冒号两边没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = (a > b) ? a:b;          // 不符合：':' 左右没有空格\r\nc = (a > b) ? a :b;         // 不符合：':' 右边没有空格\r\nc = (a > b) ? a: b;         // 不符合：':' 左边没有空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.226 最强",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.INC.06 头文件必须用#define保护，防止重复包含【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：保护符命名时，首尾是下划线(_)\r\n- 修复示例：\r\n\r\n```cpp\r\n#ifndef VOS_INCLUDE_TIME_H     // 符合：保护符命名时，避免首尾是下划线`_`\r\n#define VOS_INCLUDE_TIME_H\r\n...\r\n#endif\r\n```\r\n\r\n##### 场景2：使用#pragma once\r\n- 修复示例：\r\n\r\n```cpp\r\n#ifndef VOS_INCLUDE_TIME_H  // 符合\r\n#define VOS_INCLUDE_TIME_H\r\n...\r\n#endif\r\n```\r\n\r\n##### 场景3：保护符不唯一\r\n- 修复示例：\r\n\r\n```cpp\r\n// vos/path1/time.h\r\n#ifndef VOS_PATH1_TIME_H // 符合：保护符使用唯一名称\r\n#define VOS_PATH1_TIME_H\r\n...\r\n#endif\r\n\r\n// vos/path2/time.h\r\n#ifndef VOS_PATH2_TIME_H // 符合：保护符使用唯一名称\r\n#define VOS_PATH2_TIME_H\r\n...\r\n#endif\r\n```\r\n##### 场景4：`#define`和`#ifndef`名称不一样\r\n- 修复示例：\r\n\r\n```cpp\r\n#ifndef VOS_INCLUDE_TIME_H  // 符合\r\n#define VOS_INCLUDE_TIME_H\r\n...\r\n#endif\r\n```",
        "错误示例": "##### 场景1：保护符命名时，首尾是下划线(_)\r\n- 错误示例：\r\n\r\n```cpp\r\n#ifndef _VOS_INCLUDE_TIME_H_    // 不符合\r\n```\r\n\r\n##### 场景2：使用#pragma once\r\n- 错误示例：\r\n\r\n```cpp\r\n#pragma once                // 不符合\r\n```\r\n\r\n##### 场景3：保护符不唯一\r\n- 错误示例：\r\n\r\n```cpp\r\n// vos/path1/time.h\r\n#ifndef TIME_H\r\n#define TIME_H\r\n...\r\n#endif\r\n\r\n// vos/path2/time.h\r\n#ifndef TIME_H // 不符合：命名不唯一\r\n#define TIME_H\r\n...\r\n#endif\r\n```\r\n##### 场景4：`#define`和`#ifndef`名称不一样\r\n- 错误示例：\r\n\r\n```cpp\r\n#ifndef VOS_INCLUDE_TIME_H\r\n#define TIME_H              // 不符合：和前面的`#ifndef`名称不一样\r\n...\r\n#endif\r\n```",
        "修改建议": "1. 不要使用`#pragma once`来防止头文件被重复包含，要使用`#define`。\r\n2. 定义包含保护符`#define`时，应该遵守如下规则：\r\n    - 保护符命名时，避免首尾是下划线`_`；\r\n    - 保护符使用唯一名称；\r\n    - 建议考虑项目源代码树顶层以下的文件路径，不要在受保护部分的前后放置代码或者注释，文件头注释除外。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1041"
    },
    {
        "规则名称": "G.INC.05-CPP 禁止在extern \"C\"中包含头文件",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "修改include位置，避免出现extern \"C\"嵌套。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.FUU.06 禁用pthread_exit、ExitThread函数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "```C\nvoid test_bad_case()\n{\n    /* POTENTIAL FLAW: Forbid using the thread exit function */\n    pthread_exit();\n}\n```",
        "修改建议": "不要调用pthread_exit、ExitThread函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.FUD.06 内联函数要尽可能短，避免超过10行【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：内联函数超过10行\r\n- 修复示例：\r\n\r\n```c\r\nint MyFread(char *buf, int max) // 符合：改为非内联函数\r\n{\r\n    int c;\r\n    int n = 0;\r\n\r\n    while ((n < max) && ((c = getchar()) != EOF)) {\r\n        *(buf++) = c;\r\n        n++;\r\n        if (c == '\\n' || c == '\\r') {\r\n            break;\r\n        }\r\n    }\r\n    return n;\r\n}\r\n```",
        "错误示例": "##### 场景1：内联函数超过10行\r\n- 错误示例：\r\n\r\n```c\r\ninline int MyFread(char *buf, int max) // 不符合：内联函数超过10行\r\n{\r\n    int c;\r\n    int n = 0;\r\n\r\n    while ((n < max) && ((c = getchar()) != EOF)) {\r\n        *(buf++) = c;\r\n        n++;\r\n        if (c == '\\n' || c == '\\r') {\r\n            break;\r\n        }\r\n    }\r\n    return n;\r\n}\r\n```",
        "修改建议": "拆分内联函数或者改为非内联函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.EXP.43-CPP 不用的代码段直接删除，不要注释掉",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：用`//`注释不用的代码段\r\n- 修复示例：\r\n\r\n```cpp\r\n#define MAX_SIZE\r\n\r\nvoid Foo()\r\n{\r\n    int x;\r\n    ...\r\n    // 符合：直接删除注释的代码\r\n    x = 0;\r\n    ...\r\n}\r\n```\r\n##### 场景2：用`#if 0`注释不用的代码段\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合：直接删除注释的代码\r\n#if defined(__arm64__) && __arm64__\r\ntypedef uint_least16_t char16_t;\r\ntypedef uint_least32_t char32_t;\r\n#endif\r\n```",
        "错误示例": "##### 场景1：用`//`注释不用的代码段\r\n- 错误示例：\r\n\r\n```cpp\r\n#define MAX_SIZE\r\n\r\nvoid Foo()\r\n{\r\n    int x;\r\n    ...\r\n    // 不符合：注释的代码\r\n    // x = MAX_SIZE;\r\n    x = 0;\r\n    ...\r\n}\r\n```\r\n##### 场景2：用`#if 0`注释不用的代码段\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：注释的代码\r\n#if 0\r\ntypedef uint_least16_t char16_t;\r\n#elif defined(__arm64__) && __arm64__\r\ntypedef uint_least16_t char16_t;\r\ntypedef uint_least32_t char32_t;\r\n#endif\r\n```",
        "修改建议": "不用的代码段直接删除掉。若再需要时，考虑移植或重写这段代码。\r\n这里说的“注释掉”的方式，除了`/* */` 或`//`、还包括`#if 0`、`#ifdef NEVER_DEFINED`等，但**注释中的代码示例**不属于被注释掉的代码。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "561"
    },
    {
        "规则名称": "WordsTool.285 抢购",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.248 独家",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.149 PhoneAccount",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--关键信息",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：行尾有空格\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合：清除行尾空格\r\nvoid Foo(int x);\r\n```\r\n\r\n##### 场景2：小括号内两侧有空格\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo(int x);    // 符合：清除小括号内部两侧的空格\r\n```\r\n\r\n##### 场景3：逗号，分号，冒号前有空格\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合：逗号，分号，冒号（不含三元操作符和表示位域的冒号）前无需空格，后需要空格\r\nvoid Foo(int x, int y, int z);\r\n```\r\n\r\n##### 场景4：#include 后无空格\r\n- 修复示例：\r\n\r\n```cpp\r\n#include <stdio.h>  // 符合：#include指令后加上空格\r\n```",
        "错误示例": "##### 场景1：行尾有空格\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：行尾有空格\r\nvoid Foo(int x); \r\n```\r\n\r\n##### 场景2：小括号内两侧有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo( int x );  // 不符合：小括号内两侧有空格\r\n```\r\n\r\n##### 场景3：逗号，分号，冒号前有空格\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：第一个逗号前有多余的空格，第二个逗号后未加空格\r\nvoid Foo(int x ,int y,int z);\r\n```\r\n\r\n##### 场景4：#include 后无空格\r\n- 错误示例：\r\n\r\n```cpp\r\n#include<stdio.h>  // 不符合：#include指令后无空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.67 dalvik",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.17 ART",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CMT.04 不写空有格式的函数头注释【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：空注释头\r\n- 修复示例：函数头注释应当删除无用的信息，将重要、有用的信息表达清楚。\r\n\r\n```c++\r\n /*\r\n * 返回实际写入的字节数，-1表示写入失败\r\n * 注意，内存 buf 由调用者负责释放\r\n */\r\n int WriteString(char *buf, int len);\r\n```",
        "错误示例": "##### 场景1：空注释头\r\n- 错误示例：参数项、返回值项为空\r\n\r\n```c++\r\n/*\r\n * 函数名：WriteString\r\n * 功能：写入字符串\r\n * 参数：\r\n * 返回值：\r\n */\r\nint WriteString(char *buf, int len);\r\n```",
        "修改建议": "补充内容或者删除空有格式的注释。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1116"
    },
    {
        "规则名称": "G.PRE.04 禁止把带副作用的表达式作为参数传递给函数式宏",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "代码做如下修改：\n\n```c\na++; // 结果：a = 6，只自增了一次\nb = SQUARE(a);\n```",
        "错误示例": "如下所示，宏SQUARE本身没有问题，但是使用时将带副作用的表达式a++传入导致a的值在SQUARE执行后的结果跟预期不符：\n\n```c\n#define SQUARE(a) ((a) * (a))\n\nint a = 5;\nint b = SQUARE(a++); // 不符合： 展开后表达式中有2个 \"a++\"，其结果可能是非预期的。\n```\n\nSQUARE(a++)展开后为((a++) * (a++))，变量a自增了两次，其值为7，而不是预期的6。",
        "修改建议": "不要将副作用表达式作为宏的参数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "G.FUU.05 禁止调用kill、TerminateProcess函数直接终止其他进程【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用atexit函数\r\n- 修复示例：重构代码，禁止使用atexit()\r\n\r\n  ```c\r\n  void ProcessExit(void)\r\n  {\r\n      if (g_someResource == 0) {\r\n          ... // 在这里清理程序资源，代码略\r\n      }\r\n      return;\r\n  }\r\n\r\n  int main(void)\r\n  {\r\n      ...\r\n      // main函数退出\r\n      ProcessExit(); // 符合：主动调用资源清理函数\r\n      return 0;\r\n  }\r\n  ```\r\n##### 场景2：调用kill、TerminateProcess函数直接终止其他进程\r\n- 修复示例：正确的做法是通知对方进程停止，在等待一定时间内如果对方仍然未退出，再强行终止目标进程。\r\n\r\n  ```c\r\n  if (isFatalStatus) {\r\n      ...\r\n      kill(pid, SIGUSR1); // 符合：目标进程将SIGUSR1定义为停止命令\r\n\r\n      ...\r\n\r\n      if (WaitForRemoteProcessExit() == TIME_OUT) {\r\n          kill(pid, SIGKILL); // 目标进程在限定时间内仍然未退出，强行结束目标进程\r\n      }\r\n  }\r\n  ```\r\n##### 场景3：使用pthread_exit、ExitThread函数\r\n- 修复示例：\r\n\r\n  ```c\r\n  int TestCaseGood02()\r\n  {\r\n      ...\r\n      // POTENTIAL FLAW GOOD：线程执行完毕后自动退出，注意清理资源\r\n      return 0;\r\n  }\r\n  ```",
        "错误示例": "##### 场景1：使用atexit函数\r\n- 错误示例：ProcessExit()函数由atexit()事先注册，在程序终止时执行必要的资源清理操作。但是如果`g_someResource == 0`条件为真，则exit()被第二次调用，造成程序产生未定义行为。\r\n\r\n  ```c\r\n  int g_someResource = 1;\r\n\r\n  void ProcessExit(void)\r\n  {\r\n      if (g_someResource == 0) {\r\n          ...     // 在这里清理程序资源，代码略\r\n          exit(0); // 不符合：在本例程中调用exit，导致程序产生未定义行为\r\n      }\r\n      return;\r\n  }\r\n\r\n  int main(void)\r\n  {\r\n      // 不符合：使用atexit()注册ProcessExit()，清理资源\r\n      if (atexit(ProcessExit) != 0) {\r\n          ... // 错误处理\r\n      }\r\n      ...\r\n      // main函数退出\r\n      return 0;\r\n  }\r\n  ```\r\n##### 场景2：调用kill、TerminateProcess函数直接终止其他进程\r\n- 错误示例：\r\n\r\n  ```C\r\n  if (isFatalStatus) {\r\n      ...\r\n      kill(pid, SIGKILL); // 不符合：直接调用kill强行结束目标进程\r\n  }\r\n  ```\r\n##### 场景3：使用pthread_exit、ExitThread函数\r\n- 错误示例：\r\n\r\n  ```c\r\n  int TestCaseBad02()\r\n  {\r\n      int err = 0;\r\n      // POTENTIAL FLAW：禁止使用退出线程函数\r\n      ExitThread(err);\r\n  }\r\n  ```",
        "修改建议": "禁止调用kill、TerminateProcess函数直接终止其他进程。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "459"
    },
    {
        "规则名称": "WordsTool.302 宗教",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.66 d8",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.181 TelephonyManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CNS.04-CPP 对于指针和引用类型的参数，如果不需要修改其引用的对象，应使用const修饰",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "WhiteListFuncs:\"\";WhiteListFuncs:\"\";IgnoreOnError:1;IgnoreOnError:1",
        "正确示例": "##### 场景1：函数本意是不需要修改入参指针指向的对象，但未加const保护\r\n- 修复示例：将指针参数声明为const\r\n```cpp\r\nvoid Log(const int32_t *val) // 符合\r\n{\r\n    std::cout << \"val = \" << *val << std::endl;\r\n}\r\n```\r\n\r\n##### 场景2：引用类型参数未被修改\r\n- 修复示例：将参数声明为const\r\n```cpp\r\nvoid Log(const int32_t &val) // 符合\r\n{\r\n    std::cout << \"val = \" << val << std::endl;\r\n}\r\n```",
        "错误示例": "##### 场景1：函数本意是不需要修改入参指针指向的对象，但未加const保护\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Log(int32_t *val) // 不符合\r\n{\r\n    std::cout << \"val = \" << *val << std::endl;\r\n}\r\n```\r\n\r\n##### 场景2：引用类型参数未被修改\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Log(int32_t &val) // 不符合\r\n{\r\n    std::cout << \"val = \" << val << std::endl;\r\n}\r\n```",
        "修改建议": "1. 如果函数设计上该参数引用的对象不需要修改，将对应参数声明为`const`。\r\n2. 避免将const限定的对象强制转换为非const对象，转换后，该非const对象被修改时，程序的行为是未定义的。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "471"
    },
    {
        "规则名称": "WordsTool.36 canvasViewDrawingDidChange",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.143 NDK",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.NAM.01-CPP C++文件以.cpp为扩展名，头文件以.h为扩展名",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：头文件扩展名不是.h\r\n- 修复示例：推荐使用.h作为头文件的扩展名。\r\n\r\n```cpp\r\n// 符合：使用推荐的头文件扩展名.h\r\n// head.h\r\n```\r\n##### 场景2：源文件扩展名不是.cpp\r\n- 修复示例：推荐使用.cpp作为源文件的扩展名。\r\n\r\n```cpp\r\n// 符合：使用推荐的源文件扩展名.cpp\r\n// source.cpp\r\n```",
        "错误示例": "##### 场景1：头文件扩展名不是.h\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：头文件扩展名是.hxx\r\n// head.hxx\r\n```\r\n##### 场景2：源文件扩展名不是.cpp\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：源文件扩展名是.cc\r\n// source.cc\r\n```",
        "修改建议": "1. 修改头文件文件扩展名为.h，修改源文件扩展名为.cpp。\r\n2. 如果当前老项目中已经使用了`.hh, .hpp, .hxx`， `.cc, .cxx, .C`扩展名，可以继续使用。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.57 CTCellularData",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.19 atrace",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.14 禁止用宏重命名安全函数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\n#define area(x) x*x;\n```",
        "错误示例": "以下代码的宏定义都是错误的。\n```C\n#define XXX_memcpy_s memcpy_s // 重定义安全函数\n#define SEC_MEM_CPY memcpy_s // 重定义安全函数\n#define XX_memset_s(dst, dstMax, val, n) memset_s((dst), (dstMax), (val), (n)) // 重定义安全函数\n#define XX_memset_s(dst, dstMax, val, n) (void)memset_s((dst), (dstMax), (val), (n)) // 重定义安全函数\n```",
        "修改建议": "禁止在宏定义中重定义安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.3 aar",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.270 永远",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.301 台湾",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.160 quick application",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.03-CPP 单参数构造函数声明为explicit",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：类的构造函数单参数时未添加explicit声明\r\n- 修复示例：\r\n\r\n```cpp\r\nclass MyTest {\r\npublic:\r\n    explicit MyTest(int Var);                    // 符合\r\n    explicit MyTest(double Var, int VarDef = 0); // 符合\r\n    explicit MyTest(int *Var);\r\n};\r\n```",
        "错误示例": "##### 场景1：类的构造函数单参数时未添加explicit声明\r\n- 错误示例：\r\n\r\n```cpp\r\nclass MyTest {\r\npublic:\r\n    MyTest(int Var);                    // 不符合\r\n    MyTest(double Var, int VarDef = 0); // 不符合\r\n    explicit MyTest(int *Var);\r\n};\r\n```",
        "修改建议": "以下函数应该加上explicit声明。\r\n- 类的构造函数只有一个参数时。如`A(int i)`、`A(int i = 1)`。\r\n- 类的构造函数中除了第一个参数以外，其他参数都有默认值的时候。(第一个参数可以有默认值，也可以没有)。如`A(int i, int j = 0)`、`A(int i = 1, int j = 0)`。\r\n- 自定义的类型转换函数。如`operator 类型()`。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.208 nodejs",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.72 DebugD",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.164 ReleaseAndAnswer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CMT.02-CPP 代码注释置于对应代码的上方或右边",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：注释符与代码之间没有空格\r\n- 修复示例：\r\n\r\n```cpp\r\nint x; // 符合：注释符与代码之间至少留有1个空格\r\n\r\nint y; /* 符合：注释符与代码之间至少留有1个空格 */\r\n```\r\n\r\n##### 场景2：注释位于代码中间\r\n- 修复示例1：\r\n\r\n```cpp\r\nint y = 1; // 注释          // 符合：注释位于代码右侧\r\n```\r\n\r\n- 修复示例2：\r\n\r\n```cpp\r\nint y = 1; /* 注释 */       // 符合：注释位于代码右侧\r\n```\r\n\r\n- 修复示例3：\r\n\r\n```cpp\r\n/*\r\n * 注释\r\n * 第二行\r\n */\r\nint y = 1;                  // 符合：注释位于代码上方\r\n```",
        "错误示例": "##### 场景1：注释符与代码之间没有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint x;// 不符合：注释符与代码之间无空格\r\n\r\nint y;/* 不符合：注释符与代码之间无空格 */\r\n```\r\n\r\n##### 场景2：注释位于代码中间\r\n- 错误示例：\r\n\r\n```cpp\r\nint y /* 注释 */ = 1;       // 不符合：注释位于代码中间\r\n```",
        "修改建议": "按照要求放置代码注释。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1113"
    },
    {
        "规则名称": "G.CTL.07 switch语句要有default分支--没有default分支【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：没有default分支\r\n- 修复示例1：\r\n\r\n```c++\r\nswitch (paraName) {\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n    default: // 符合：增加default分支并放在switch语句块的最后位置\r\n        break;\r\n}\r\n```",
        "错误示例": "##### 场景1：没有default分支\r\n- 错误示例：\r\n\r\n```c++\r\nswitch (paraName) { // 不符合：没有default分支\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n}\r\n```",
        "修改建议": "1. 增加default分支。\r\n2. 统一将default分支放到switch语句块的最后位置。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "478"
    },
    {
        "规则名称": "WordsTool.274 专供",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.65 CXTransaction",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.RES.02-CPP 内存申请前，必须对申请内存大小进行合法性校验",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，动态分配size大小的内存前，进行了符合程序需要的合法性校验。\n```c\n// 这里的size在传入DoSomething函数之前还未做过合法性校验 \nint DoSomething(size_t size)\n{\n    // 本函数内，对size做合法性校验，FOO_MAX_LEN被定义为符合程序设计预期的最大内存空间\n    if (size == 0 || size > FOO_MAX_LEN) {\n      ... // 错误处理 \n    }\n    char* buffer = new char[size];\n    ...\n    delete[] buffer;\n}\n```",
        "错误示例": "如下代码中，将动态分配size大小的内存。但是未对size做合法性校验。\n```C\n// 这里的size在传入DoSomething函数之前还未做过合法性校验 \nint DoSomething(size_t size)\n{\n    ...\n    char* buffer = new char[size]; // 本函数内，size使用前未做校验 \n    ...\n    delete[] buffer;\n}\n```",
        "修改建议": "申请内存之前，对申请大小的变量做校验。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "789"
    },
    {
        "规则名称": "WordsTool.20 AudioFlinger",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.04-CPP #if 或 #elif 预处理指令中的常量表达式被求值前应确保其使用的标识符已定义",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1",
        "正确示例": "```cpp\n#if defined(VERSION) && VERSION == 4000 // 符合  \n...\n#endif\n\n#ifdef VERSION                          // 符合\n#if VERSION == 4000                     // 符合  \n...\n#endif\n#endif\n```",
        "错误示例": "```cpp\n#if VERSION == 4000                     // 不符合, VERSION 可能未定义\n...\n#endif\n```",
        "修改建议": "增加对标识符的检查",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "456"
    },
    {
        "规则名称": "WordsTool.28 blacklist",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.304 战争",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.13-CPP 禁止重新定义public继承而来的非虚函数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1;IgnoreDeleteFromDerived:false",
        "正确示例": "##### 场景1：在派生类中重定义public继承而来的非虚函数\r\n- 修复示例：如果要在派生类中新增行为，请使用新的函数名。\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    void Fun() { std::cout << \"Call Base Fun\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    void Bar() { std::cout << \"Call Derived Bar\" << std::endl; } // 符合\r\n};\r\n```",
        "错误示例": "##### 场景1：在派生类中重定义public继承而来的非虚函数\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    void Fun() { std::cout << \"Call Base Fun\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    void Fun() { std::cout << \"Call Derived Fun\" << std::endl; } // 不符合\r\n};\r\n```",
        "修改建议": "如果要在派生类中新增行为，请使用新的函数名，而不是重定义基类中的非虚函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1062"
    },
    {
        "规则名称": "WordsTool.204 libc++",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.05-CPP 所有#else、#elif、#endif和与之对应的#if、#ifdef、#ifndef预处理指令应出现在同一文件中",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，在相同文件中闭合预处理块。\n\n```cpp\n// sample.h 开始  \n#if defined(__VXWORKS__)    // 在相同文件中闭合该预处理块  \n#include \"vx_config.h\"\n#endif\n// sample.h 结束  \n```",
        "错误示例": "如下代码中，未在相同文件中闭合预处理块。\n\n```cpp\n// sample.h 开始  \n#if defined(__VXWORKS__)  // 未在相同文件中闭合该预处理块\n#include \"vx_config.h\"\n\n// 这里结束前，本应当有 #endif 与前面的 #if defined 形成闭合  \n// sample.h 结束  \n```",
        "修改建议": "预处理指令在同一个文件中闭合。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "152"
    },
    {
        "规则名称": "WordsTool.308 恐怖袭击",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "超大函数[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "新增阈值:50;修改阈值:50",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "G.FUU.14 禁止用宏重命名安全函数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：代码中未直接调用安全函数，而是以宏的方式调用安全函数。\r\n- 修复示例：不要以宏的方式调用安全函数，直接调用安全函数。\r\n\r\n```c\r\n略\r\n```\r\n##### 场景2：使用#define重命名安全函数并且destMax与count两个参数一致，导致安全函数失效的情况。\r\n- 修复示例：不要以宏的方式调用安全函数，直接调用安全函数。\r\n\r\n```c\r\n略\r\n```\r\n##### 场景3：使用类似安全函数接口的宏，重定义安全函数，destMax与count参数使用相同参数\r\n- 修复示例：不要以宏的方式调用安全函数，直接调用安全函数。\r\n\r\n```c\r\n略\r\n```",
        "错误示例": "##### 场景1：代码中未直接调用安全函数，而是以宏的方式调用安全函数。\r\n- 错误示例：\r\n\r\n```c\r\n#define XXX_memcpy_s  memcpy_s // 不符合\r\n#define SEC_MEM_CPY   memcpy_s // 不符合\r\n#define XX_memset_s(dst, dstMax, val, n) memset_s((dst), (dstMax), (val), (n))          // 不符合\r\n#define SEC_memset_s(dst, dstMax, val, n) (void)memset_s((dst), (dstMax), (val), (n))   // 不符合\r\n```\r\n##### 场景2：使用#define重命名安全函数并且destMax与count两个参数一致，导致安全函数失效的情况。\r\n- 错误示例：\r\n\r\n```c\r\n#define XXX_memcpy(dst, src, count) memcpy_s(dst, count, src, count)                // 不符合\r\n#define XXX_MemCpy_s(dest, destMax, src, count) memcpy_s(dest, count, src,count)    // 不符合\r\n```\r\n##### 场景3：使用类似安全函数接口的宏，重定义安全函数，destMax与count参数使用相同参数\r\n- 错误示例：\r\n\r\n```c\r\n#define XXX_memcpy_s(dst, destMax, src, count) memcpy_s(dst, count, src, count) // 不符合\r\n```",
        "修改建议": "不要以宏的方式调用安全函数，直接调用安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.189 uuDeJava",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.05 函数式宏定义中慎用 return、goto、continue、break 等改变程序流程的语句",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "如下是宏封装`return`容易引发内存泄漏的场景：\n\n```c\n#define CHECK_PTR(ptr, ret) do { \\\n    if ((ptr) == NULL) { \\\n        return (ret); \\\n    } \\\n} while (0)\n\n...\n\nmem1 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem1, ERR_CODE_XXX);\n\nmem2 = MemAlloc(STR_SIZE_MAX);\nCHECK_PTR(mem2, ERR_CODE_XXX); // 内存泄漏问题\n```\n\n如果 mem2 申请内存失败了，CHECK_PTR 会直接返回，而没有释放 mem1。\n除此之外，CHECK_PTR 宏命名也不好，宏名只反映了检查动作，没有指明结果。只有看了宏实现才知道指针为空时返回失败。",
        "修改建议": "重构代码逻辑，避免安全隐患。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "705"
    },
    {
        "规则名称": "G.EXP.09-CPP 变量被使用时才声明并初始化",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：变量声明和初始化分离\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func(int x)\r\n{\r\n    if (x == 1) {\r\n        int num = 5; // 符合：变量使用时才声明并初始化\r\n        set(num);\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：变量声明和初始化分离\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func(int x)\r\n{\r\n    if (x == 1) {\r\n        int num; // 不符合\r\n        num = 5;\r\n        set(num);\r\n    }\r\n}\r\n```",
        "修改建议": "变量使用时才声明并初始化。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "453,456,457,1126"
    },
    {
        "规则名称": "WordsTool.284 万人疯抢",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.12 保持代码紧凑，避免过多空行【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：大括号内代码块行首空行\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo(int x, int y)\r\n{\r\n    x = 1; // 符合\r\n}\r\n```\r\n##### 场景2：函数内使用连续空行\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int x;\r\n    int y; // 符合\r\n}\r\n```\r\n##### 场景3：函数返回值判断没有紧跟返回值，两者之间有多余的空行\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int num = GetNumber();\r\n    if (num == 0) { // 符合\r\n        // ...\r\n    }\r\n}\r\n```\r\n##### 场景4：函数外连续3个空行\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo1()\r\n{\r\n    // ...\r\n}\r\n\r\nvoid Foo2()  // 符合\r\n{\r\n    // ...\r\n}\r\n```",
        "错误示例": "##### 场景1：大括号内代码块行首空行\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(int x, int y)\r\n{\r\n\r\n    x = 1; // 不符合：上方多余空行\r\n}\r\n```\r\n##### 场景2：函数内使用连续空行\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int x;\r\n\r\n    int y; // 不符合：函数内连续空行\r\n}\r\n```\r\n##### 场景3：函数返回值判断没有紧跟返回值，两者之间有多余的空行\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int num = GetNumber();\r\n\r\n    if (num == 0) { // 不符合：函数返回值判断需要紧跟返回值\r\n        // ...\r\n    }\r\n}\r\n```\r\n##### 场景4：函数外连续3个空行\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo1()\r\n{\r\n    // ...\r\n}\r\n\r\nvoid Foo2()  // 不符合：函数外连续三个空行\r\n{\r\n    // ...\r\n}\r\n```",
        "修改建议": "删除多余空行",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.FUU.12 正确设置安全函数中的destMax参数--检查destMax参数是否设置正确",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "以下代码，destBuff跨越到不可访问内存，属于误用：\n\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nmemcpy_s(destBuff, 0x7fffffff, src, srcLen); // 不符合\n```\ndestMax参数设置原则：\n\n（为聚焦于说明destMax的用法，示例代码中省略了安全函数的返回值检查以及其他检查）\n\n1. destBuff 为 char destBuff[BUFF_SIZE] 形式的局部变量的情况\n\n1.1 使用时，destMax必须设置为 sizeof(destBuff) 或 BUFF_SIZE\n【反例】\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\n...\nmemcpy_s(destBuff, 100, src, srcLen);       // 不符合\nmemcpy_s(destBuff, srcLen, src, srcLen);     // 不符合\n```\n【正例】\n```c\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nchar strDest[BUFF_SIZE];\n...\nmemcpy_s(destBuff, sizeof(destBuff), src, srcLen);   // 符合\nmemcpy_s(destBuff, BUFF_SIZE, src, srcLen);           // 符合\nsprintf_s(strDest, sizeof(strDest), \"Hello, world\"); // 符合\n...\nmemset_s(strDest, BUFF_SIZE, 0, BUFF_SIZE);           // 符合\nscanf_s(\"%s\", strDest, sizeof(strDest));             // 符合\n```\n1.2 如果 destBuff 作为参数跨函数传递，必须将 destBuff 的实际大小作为参数进行传递\n\n【反例】\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, 100);   // 不符合\n    ParseBuff2(destBuff);       // 不符合：必须增加destMax参数\n    ...\n}\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, BUFF_SIZE, src, srcLen);         // 不符合\n    memcpy_s(destBuff, sizeof(destBuff), src, srcLen); // 不符合\n    memcpy_s(destBuff, 100, src, srcLen);               // 不符合\n    memcpy_s(destBuff, srcLen, src, srcLen);           // 不符合\n  ...\n}\n```\n\n【正例】\n\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, BUFF_SIZE); // 符合：传递BUFF_SIZE\n    ...\n}\n\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, destMax, src, srcLen);   // 符合\n    ...\n}\n```",
        "修改建议": "安全函数的destMax参数设置应当准确、有效。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--二元表达式",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：二元操作符至少一边没加空格\r\n- 修复示例：二元操作符两边加上空格\r\n```cpp\r\nc = a + b;      // 符合\r\n```",
        "错误示例": "##### 场景1：二元操作符至少一边没加空格\r\n- 错误示例：\r\n\r\n```cpp\r\nc = a+b;        // 不符合：'+' 左右没有空格\r\nc = a +b;       // 不符合：'+' 右边没有空格\r\nc = a+ b;       // 不符合：'+' 左边没有空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.184 ToneGenerator",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.07-CPP 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：把一个派生类对象直接赋值给基类对象导致切片。\r\n- 修复示例：为了防止出现切片问题，多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数。\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    virtual ~Base() = default;\r\n    ...\r\n    // 符合：拷贝构造函数和拷贝赋值操作符声明为delete\r\n    Base(const Base&) = delete;\r\n    Base& operator=(const Base&) = delete;\r\n    ...\r\n    virtual void Fun() { std::cout << \"Base\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\n    ...\r\n    void Fun() override { std::cout << \"Derived\" << std::endl; }\r\n};\r\n\r\nvoid Foo(const Base& base)\r\n{\r\n    Base other = base;  // 编译报错\r\n    other.Fun();\r\n}\r\n\r\nvoid Func()\r\n{\r\n    Derived d;\r\n    Foo(d);             // 传入的是派生类对象\r\n}\r\n```\r\n##### 场景2：把一个派生类对象移动给基类对象导致切片。\r\n- 修复示例：为了防止出现切片问题，多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数。\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    virtual ~Base() = default;\r\n\r\n    // 符合：移动构造函数、移动赋值操作符声明为delete\r\n    Base(Base &&) = delete;\r\n    Base &operator=(Base &&) = delete;\r\n    ...\r\n    virtual void Fun() { std::cout << \"Base\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\n    ...\r\n    void Fun() override { std::cout << \"Derived\" << std::endl; }\r\n};\r\n\r\nvoid Call()\r\n{\r\n    Derived d;\r\n    Base b = std::move(d);  // 编译报错\r\n    b.Fun();\r\n}\r\n```",
        "错误示例": "##### 场景1：把一个派生类对象直接赋值给基类对象导致切片。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    virtual ~Base() = default;\r\n    ...\r\n    virtual void Fun() { std::cout << \"Base\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\n    ...\r\n    void Fun() override { std::cout << \"Derived\" << std::endl; }\r\n};\r\n\r\nvoid Foo(const Base& base)\r\n{\r\n    Base other = base;  // 不符合：发生切片\r\n    other.Fun();        // 调用的是Base类的Fun函数\r\n}\r\n\r\nvoid Func()\r\n{\r\n    Derived d;\r\n    Foo(d);             // 传入的是派生类对象\r\n}\r\n```\r\n##### 场景2：把一个派生类对象移动给基类对象导致切片。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    virtual ~Base() = default;\r\n    ...\r\n    virtual void Fun() { std::cout << \"Base\" << std::endl; }\r\n};\r\n\r\nclass Derived : public Base {\r\n    ...\r\n    void Fun() override { std::cout << \"Derived\" << std::endl; }\r\n};\r\n\r\nvoid Call()\r\n{\r\n    Derived d;              // 派生类对象\r\n    Base b = std::move(d);  // 不符合：发生切片\r\n    b.Fun();                // 调用的是Base类的Fun函数\r\n}\r\n```",
        "修改建议": "为了防止出现切片问题，多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者为delete函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.AST.02 避免在代码中直接使用assert()【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用自定义断言宏时，在发布版本中使用打印替换断言。\r\n- 修复示例：使用自定义断言宏时，在发布版本中不能使用打印。\r\n\r\n    ```c\r\n    #ifdef DEBUG\r\n    #define ASSERT(f)  assert(f)\r\n    #else\r\n    #define ASSERT(f)  ((void)0)    // 符合\r\n    #endif\r\n    ```\r\n##### 场景2：在代码中直接使用assert()。\r\n- 修复示例：在代码中不应直接使用assert()，应该使用自定义断言宏。\r\n\r\n    ```c\r\n    // 例如以下宏定义\r\n    #ifdef DEBUG\r\n    #define ASSERT(f)  assert(f)\r\n    #else\r\n    #define ASSERT(f)  ((void)0)\r\n    #endif\r\n\r\n    int Foo(int *array, size_t size)\r\n    {\r\n        ASSERT(array != NULL);  // 符合\r\n        ...\r\n    }\r\n    ```",
        "错误示例": "##### 场景1：使用自定义断言宏时，在发布版本中使用打印替换断言。\r\n- 错误示例：在发布版本中使用打印替换断言，生成了实际代码，是不正确的设计。\r\n\r\n    ```c\r\n    #ifdef DEBUG\r\n    #define ASSERT(f)  assert(f)\r\n    #else\r\n    #define ASSERT(f)  do { \\\r\n        if (!(f)) { \\\r\n            printf(\"Error in function=%s, Line=%d\\n\", __FUNCTION__, __LINE__); \\    // 不符合\r\n        } \\\r\n    } while (0)\r\n    #endif\r\n    ```\r\n##### 场景2：在代码中直接使用assert()。\r\n- 错误示例：\r\n\r\n    ```c\r\n    int Foo(int *array, size_t size)\r\n    {\r\n        assert(array != NULL);  // 不符合\r\n        ...\r\n    }\r\n    ```",
        "修改建议": "断言必须使用宏定义，且只能在调试版本中生效。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.192 Vehicle Network Service",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.INT.09 确保枚举常量映射到唯一值",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "为了防止出现错误代码示例中的问题，枚举类型声明可以采用以下形式之一：\n\n- 不提供显式的整数赋值，如下示例所示\n\n```c\ntypedef enum {\n    ERR_SYS_ARG_ERR,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n```\n\n- 只对第一个成员赋值，如下示例所示\n\n```c\ntypedef enum {\n    ERR_SYS_ARG_ERR      = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,\n    ERR_SYS_CHECK_ERR,\n\n    ERR_EMG_INVALID_ERR,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n```\n\n在上面的两个选项中，除非第一个枚举数必须具有非零值，否则第一种做法是最简单的方法，因此也是首选方法。",
        "错误示例": "如下代码示例中，在枚举类型`SomeModuleErrCodes`中定义错误码的时候，为两个枚举常量分配了显式值，造成 `ERR_SYS_MODIFY_ERR` 和 `ERR_EMG_INVALID_ERR` 被隐式声明为相同的值（0x3a020010），对于程序员来说，可能并不明显。\n这种定义可能导致的错误是尝试将枚举常量用于 `switch` 语句的标签。由于 `switch` 语句中的所有标签都必须是唯一的，因此如下代码违反了此语义约束。\n\n```c\ntypedef enum {\n    ERR_SYS_ARG_ERR = 0x3a020000,\n    ERR_SYS_SET_ERR,\n    ERR_SYS_OCCUPIED_ERR,\n    ERR_SYS_REQFREE_ERR,\n    ERR_SYS_NO_REC_ERR,\n    ERR_SYS_ACTIVED_ERR,\n    ERR_SYS_NO_FILE_ERR,\n    ERR_SYS_OPEN_ERR,\n    ERR_SYS_ASSIGN_ERR,\n    ERR_SYS_ALLOC_ERR,\n    ERR_SYS_GET_LIST_ERR,\n    ERR_SYS_IGNORE_ERR,\n    ERR_SYS_REG_ERR,\n    ERR_SYS_CALC_ERR,\n    ERR_SYS_SNED_ERR,\n    ERR_SYS_RECV_ERR,\n    ERR_SYS_MODIFY_ERR,    // 不符合：值与ERR_EMG_INVALID_ERR相同\n    ERR_SYS_CHECK_ERR,     // 不符合：值与ERR_EMG_TYPE_ERR相同\n\n    ERR_EMG_INVALID_ERR = 0x3a020010,\n    ERR_EMG_TYPE_ERR,\n    ...\n} SomeModuleErrCodes;\n```",
        "修改建议": "修复建议\n\n（1）纠正编码错误，或者（2）显式指定枚举值",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "462"
    },
    {
        "规则名称": "G.CNS.01 禁止使用小写字母“l”作为数值型常量后缀【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码示例通过使用大写字母 L 而不是小写字母 l 来消除视觉上的错觉：\n\n```c\n#define CONSTANT_BARRETT_REDUCTION 0x1F7011641LL\n```",
        "错误示例": "如下代码示例中，宏 CONSTANT_BARRETT_REDUCTION 的值为 0x1F7011641，但是视觉上像是 0x1F701164111：\n\n```c\n#define CONSTANT_BARRETT_REDUCTION 0x1F7011641ll\n```",
        "修改建议": "小写\"l\"替换成大写\"L\"。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1107"
    },
    {
        "规则名称": "G.AST.04 禁止在断言内改变运行环境【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在断言内改变运行环境。\r\n- 修复示例：在断言中不能有任何赋值、修改变量、资源操作、内存申请等操作。\r\n\r\n```c\r\np1 = p2;\r\nASSERT(p1);             // 符合\r\n\r\nASSERT(i > 1000);       // 符合\r\ni++;\r\n\r\nint ret = close(fd);\r\nif (ret != 0) {         // 符合：可能发生的错误且必须处理的情况要用错误处理代码来处理\r\n    ...\r\n}\r\n\r\nval <<= offset;\r\nif (val == 0) {         // 符合：可能发生的错误且必须处理的情况要用错误处理代码来处理\r\n    ...\r\n}\r\n\r\nASSERT(ptr != NULL);    // 符合\r\nptr--;\r\n\r\nptr = (char *)malloc(SIZE);\r\nif (ptr == NULL) {      // 符合：可能发生的错误且必须处理的情况要用错误处理代码来处理\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：在断言内改变运行环境。\r\n- 错误示例：\r\n\r\n```c\r\nASSERT(p1 = p2);        // 不符合：p1被修改\r\nASSERT(i++ > 1000);     // 不符合：i被修改\r\nASSERT(close(fd) == 0); // 不符合：fd被关闭\r\nASSERT(val <<= offset); // 不符合：val被赋值\r\nASSERT(ptr--);          // 不符合：ptr递减\r\nASSERT(ptr = (char *)malloc(SIZE)); // 不符合：ptr被赋值\r\n```",
        "修改建议": "调用ASSERT，入参中不能使用赋值（例如 =、+=、-= 或<<=）、递增和递减（例如++或—）、修改堆（例如 ASSERT(new xxx)）。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.128 Logcat",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.1 aab",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "超大源文件[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "新增阈值:2000;修改阈值:2000",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "G.FUU.10 禁止使用alloca()函数申请栈上内存【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：调用realloc()函数。\r\n- 修复示例：使用malloc()函数代替realloc()函数。\r\n\r\n```c\r\nchar *newPtr = (char *)malloc(NEW_SIZE); // 符合：使用malloc()函数代替realloc()函数\r\nif (newPtr == NULL) {\r\n    ... // 错误处理\r\n}\r\n\r\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\r\n\r\n... // 校验ret，确保安全函数执行成功\r\n\r\n... // 返回前，释放oldPtr和newPtr\r\n```\r\n##### 场景2：调用alloca()函数。\r\n- 修复示例：使用malloc()函数代替alloca()函数。\r\n\r\n```c\r\nchar *p = (char *)malloc(ALLOC_SIZE); // 符合：使用malloc()函数代替alloca()函数\r\nif (p == NULL) {\r\n    ... // 错误处理\r\n}\r\n... // 返回前，释放p\r\n```",
        "错误示例": "##### 场景1：调用realloc()函数。\r\n- 错误示例：\r\n\r\n```c\r\n...\r\nchar *ptr = ...;    // ptr指向一段已经申请成功的内存\r\nptr = (char *)realloc(ptr, NEW_SIZE); // 不符合：当realloc()分配内存失败时会返回NULL，导致内存泄漏\r\nif (ptr == NULL) {\r\n    ... // 错误处理\r\n}\r\n```\r\n##### 场景2：调用alloca()函数。\r\n- 错误示例：\r\n\r\n```c\r\nchar *p = (char *)alloca(ALLOC_SIZE) // 不符合\r\n...\r\n```",
        "修改建议": "禁止调用alloca函数，请使用malloc从堆中动态分配内存。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.229 No.1",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.280 机关检测",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "检查通过代码注释屏蔽coverity告警的方式",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\nbool test_good1()\n{\n\n    /* dead_error_line */\n    if (Role != SECY_ROLE_INGRESS)\n        return false;\n}\n```",
        "错误示例": "```C\nbool test_bad1()\n{\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    /* coverity[dead_error_line] */\n    if (Role != SECY_ROLE_INGRESS)\n        return false;\n}\n\nbool test_bad2()\n{\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    if (Role != SECY_ROLE_INGRESS) // coverity[dead_error_line]\n        return false;\n}\n\nbool test_bad3()\n{\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    /* MaskCoverityID13633 */ /* coverity[dead_error_line] */\n    if (Role != SECY_ROLE_INGRESS)\n        return false;\n}\n\nbool test_bad4()\n{\n    bool falg = true;\n    if (Role != SECY_ROLE_INGRESS\n        // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n        /* coverity[dead_error_line] */\n        && flag)\n        return false;\n}\n\nbool test_bad5()\n{\n    bool falg = true;\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    if (Role != SECY_ROLE_INGRESS /* coverity[dead_error_line] */\n        && flag)\n        return false;\n}\n\nbool test_bad6()\n{\n    bool falg = true;\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    /* coverity[dead_error_line] */ if (Role != SECY_ROLE_INGRESS && flag)\n        return false;\n}\n\nbool test_bad7()\n{\n    bool falg = true;\n    if (Role != SECY_ROLE_INGRESS\n        // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n        /* *\n         * coverity[RESOURCE_LEAK]\n         */\n        && flag)\n        return false;\n}\n\nbool test_bad8()\n{\n    // Coverity发现的缺陷可能会被评论屏蔽，这是禁止的，请删除评论。\n    // [false alarm]:....\n    if (Role != SECY_ROLE_INGRESS)\n        return false;\n}\n```",
        "修改建议": "不要通过代码注释屏蔽coverity告警。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "546"
    },
    {
        "规则名称": "G.FUD.05 函数要简短--函数嵌套层次【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "max_nesting_level:4",
        "正确示例": "##### 场景1：函数的代码块嵌套超过4层\r\n- 修复示例1：\r\n\r\n```cpp\r\n// 符合：使用卫语句\r\nvoid Foo(const TestData *data)\r\n{\r\n    if (data->ma <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->mb <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->mc <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->md <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：函数的代码块嵌套超过4层\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合\r\nvoid Foo(const TestData *data)\r\n{\r\n    if (data->ma > 0) {\r\n        ...\r\n        if (data->mb > 0) {\r\n            ...\r\n            if (data->mc > 0) {\r\n                ...\r\n                if (data->md > 0) {\r\n                    ...\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
        "修改建议": "函数的代码块嵌套不要超过4层，修改方法参考如下：\r\n\r\n1. 用卫语句来减少嵌套深度。\r\n\r\n2. 重构函数：如果嵌套过深，可能意味着函数功能过于复杂，可以考虑将函数拆分成多个小函数，每个函数只处理部分功能，使函数更加简单易懂。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080,1124"
    },
    {
        "规则名称": "G.RES.08-CPP 使用RAII技术管理资源的生命周期",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "FuncNeedRAIIs:\"std::mutex::lock-std::lock_guard\";NewOpCheck:0",
        "正确示例": "##### 场景1：未使用RAII管理资源\r\n- 修复示例1：\r\n\r\n```c++\r\nData* data = nullptr;\r\nstd::mutex dataMutex;\r\nData& GetData()\r\n{\r\n    std::lock_guard<std::mutex> lock(dataMutex);  // 符合\r\n    if (data != nullptr) {\r\n        return *data;      // return时lock析构，自动unlock\r\n    }\r\n    ...\r\n    return *data;          // return时lock析构，自动unlock\r\n}\r\n```",
        "错误示例": "##### 场景1：未使用RAII管理资源\r\n- 错误示例：\r\n\r\n```c++\r\nData* data = nullptr;\r\nstd::mutex dataMutex;\r\n\r\nData& GetData()\r\n{\r\n    dataMutex.lock(); // 不符合\r\n    if (data != nullptr) {\r\n        return *data;      // 忘记unlock\r\n    }\r\n    ...\r\n    dataMutex.unlock();\r\n    return *data;\r\n}\r\n```",
        "修改建议": "使用RAII技术管理生命周期。如：\r\n1. 比如new/delete，可使用智能指针。\r\n2. 比如lock/unlock，可使用std::lock_guard。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "762"
    },
    {
        "规则名称": "WordsTool.157 proguard",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.121 JD-IntelliJ",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.19-CPP 禁止使用std::move操作const对象",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用`std::move`操作`const`对象。\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func1()\r\n{\r\n    const std::string str{\"String content\"};\r\n    std::string name = str;             // 符合：进行复制\r\n}\r\n\r\nvoid Func2()\r\n{\r\n    std::string str{\"String content\"};\r\n    std::string name = std::move(str);  // 符合：移动非const对象\r\n}\r\n\r\nvoid Func3()\r\n{\r\n    const std::string str{\"String content\"};\r\n    std::vector<std::string> names;\r\n    names.push_back(str);               // 符合：进行复制\r\n}\r\n```",
        "错误示例": "##### 场景1：使用`std::move`操作`const`对象。\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func1()\r\n{\r\n    const std::string str{\"String content\"};\r\n    std::string name = std::move(str);       // 不符合：并没有移动str，而是进行了复制\r\n}\r\n\r\nvoid Func2()\r\n{\r\n    const std::string str{\"String content\"};\r\n    std::vector<std::string> names;\r\n    names.push_back(std::move(str));         // 不符合：并没有移动str，而是进行了复制\r\n}\r\n```",
        "修改建议": "禁止`std::move`操作`const`对象。\r\n1. 如果对象不需要移动且不能修改，则不需要使用移动操作，使用拷贝操作。\r\n2. 如果对象需要移动，则对象不需要const修饰，这时可使用`std::move`进行数据移动操作。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "471"
    },
    {
        "规则名称": "G.FUN.01-CPP 函数功能要单一--函数嵌套层次",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\r\n函数的代码块嵌套超过4层\r\n// 符合：使用卫语句\r\nvoid Foo(const TestData *data)\r\n{\r\n    if (data->ma <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->mb <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->mc <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n    if (data->md <= 0) {\r\n        return;\r\n    }\r\n    ...\r\n}\r\n```",
        "错误示例": "```cpp\r\n函数的代码块嵌套超过4层\r\n// 不符合\r\nvoid Foo(const TestData *data)\r\n{\r\n    if (data->ma > 0) {\r\n        ...\r\n        if (data->mb > 0) {\r\n            ...\r\n            if (data->mc > 0) {\r\n                ...\r\n                if (data->md > 0) {\r\n                    ...\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
        "修改建议": "对代码进行重构，减少函数复杂度。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "G.PRE.07 宏的名称不应与关键字相同【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：宏名和int重名\r\n- 修复示例：\r\n\r\n```cpp\r\n#define DevId OTHER_TYPE // 符合：不要和关键字相同\r\n#include <cstdlib>\r\n```\r\n##### 场景2：宏名和while重名\r\n- 修复示例：\r\n\r\n```cpp\r\n#define Traverse(x) for (; (x);) // 符合：不要和关键字相同\r\n```\r\n##### 场景3：宏名和const重名\r\n- 修复示例：\r\n\r\n```cpp\r\n#define OTHER_DEFINE    // 符合：不要和关键字相同\r\n\r\nint main()\r\n{\r\n    const int i = 0;\r\n    i++;                // 编译报错\r\n\r\n    return 0;\r\n}\r\n```",
        "错误示例": "##### 场景1：宏名和int重名\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：改变了int的行为，导致后面包含标准头文件时，程序出现未定义的行为\r\n#define int OTHER_TYPE\r\n#include <cstdlib>\r\n```\r\n##### 场景2：宏名和while重名\r\n- 错误示例：\r\n\r\n```cpp\r\n#define while(x) for (; (x);) // 不符合：重定义关键字\r\n```\r\n##### 场景3：宏名和const重名\r\n- 错误示例：\r\n\r\n```cpp\r\n#define const           // 不符合：重定义关键字\r\n\r\nint main()\r\n{\r\n    const int i = 0;    // 期望是定义常量，但实际是变量\r\n    i++;                // 这里编译不报错\r\n\r\n    return 0;\r\n}\r\n```",
        "修改建议": "修改宏名，不要和关键字相同，如：\r\n\r\n```c\r\nbreak：用于跳出循环或switch语句。\r\nelse：用于定义if语句中的否定分支。\r\ncase：用于定义switch语句中的分支。\r\nenum：用于定义枚举类型。\r\nchar：用于声明字符类型。\r\nextern：用于声明外部变量或函数。\r\nconst：用于声明常量。\r\nfloat：用于声明单精度浮点数类型。\r\ncontinue：用于跳过当前循环的剩余部分。\r\nfor：用于定义for循环。\r\ndefault：用于定义switch语句中的默认分支。\r\ngoto：用于无条件跳转到指定的标签。\r\ndo：用于定义do-while循环。\r\nif：用于定义条件语句。\r\ndouble：用于声明双精度浮点数类型。\r\ninline：用于声明内联函数。\r\nint：用于声明整数类型。\r\nlong：用于声明长整数类型。\r\nregister：用于声明寄存器变量。\r\nreturn：用于从函数中返回值。\r\nshort：用于声明短整数类型。\r\nsigned：用于声明有符号类型。\r\nsizeof：用于获取变量或类型的大小。\r\nstatic：用于声明静态变量或函数。\r\nstruct：用于定义结构体类型。\r\nswitch：用于定义多分支选择语句。\r\ntypedef：用于定义类型别名。\r\nunion：用于定义联合类型。\r\nunsigned：用于声明无符号类型。\r\nvoid：用于声明无类型。\r\nvolatile：用于声明易变变量。\r\n...\r\n```",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "G.PRE.08 禁止宏调用参数中出现预编译指令",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```c\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n#ifdef PLATFORM1\n    WRITE_LOG(\"Notice: Something error.\");\n#else\n    WRITE_LOG(\"Code: 4567\");\n#endif\n}\n```",
        "错误示例": "如下代码可能会导致程序出现未定义行为。\n```c\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\nint Foo(void)\n{\n    WRITE_LOG(\n#ifdef PLATFORM1\n    \"Notice: Something error.\"\n#else\n    \"Code: 4567\"\n#endif\n    );\n}\n```",
        "修改建议": "预处理指令在宏调用之外进行保护",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "758"
    },
    {
        "规则名称": "G.STD.04-CPP 不要保存std::string类型的c_str和data成员函数返回的指针",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：保存std::string类型的c_str()的结果\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    std::string s{\"hello\"};\r\n    ...\r\n    s = \"world\";\r\n    std::cout << s.c_str();     // 符合：在每次需要时直接调用c_str\r\n}\r\n```\r\n##### 场景2：返回局部变量的c_str，会导致使用无效指针\r\n- 修复示例：\r\n\r\n```cpp\r\nstd::string Foo()\r\n{\r\n    std::string s{\"hello\"};\r\n    ...\r\n    return s;           // 符合：返回字符串\r\n}\r\n```\r\n##### 场景3：保存std::string类型的data()的结果\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo(bool cond)\r\n{\r\n    std::string s;\r\n    if (cond) {\r\n        s = \"hello\";\r\n    }\r\n\r\n    Bar(s.data());      // 符合：在每次需要时直接调用data\r\n}\r\n```",
        "错误示例": "##### 场景1：保存std::string类型的c_str()的结果\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    std::string s{\"hello\"};\r\n    const char *p = s.c_str();  // 不符合：保存c_str()的结果\r\n    s = \"world\";\r\n    std::cout << p;             // 对象s已`修改`，指针p已失效\r\n}\r\n```\r\n##### 场景2：返回局部变量的c_str，会导致使用无效指针\r\n- 错误示例：\r\n\r\n```cpp\r\nconst char *Foo()\r\n{\r\n    std::string s{\"hello\"};\r\n    ...\r\n    return s.c_str();   // 不符合：局部变量会被析构，返回的指针无效\r\n}\r\n```\r\n##### 场景3：保存std::string类型的data()的结果\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(bool cond)\r\n{\r\n    const char *p = nullptr;\r\n    if (cond) {\r\n        std::string s{\"hello\"};\r\n        p = s.data();   // 不符合：保存data()的结果\r\n    }\r\n\r\n    Bar(p);             // 对象s已`销毁`，指针p已失效\r\n}\r\n```",
        "修改建议": "1. 不要保存std::string类型的c_str()和data()的结果，而是在每次需要时直接调用。\r\n2. 不要返回局部变量的c_str()和data()的结果。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "825"
    },
    {
        "规则名称": "WordsTool.148 perfeto",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.01-CPP 非纯ASCII码源文件使用UTF-8编码",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "使用UTF-8编码。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "174"
    },
    {
        "规则名称": "WordsTool.278 领导人推荐",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.15 Applets",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.151 PKCanvasView",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.281 再不抢就没了",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.10-CPP 不要在嵌套作用域中重用名称",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "```cpp\nvoid Fun()\n{\n    std::string msg;\n    ...\n    if (condition) {\n         std::string msg;        // 不符合：外层局部变量被遮盖\n         ...\n    }\n    ...\n}\n```\n\n```cpp\nvoid Fun(const std::string& msg)\n{\n    ...\n    if (condition) {\n        std::string msg;         // 不符合：函数入参被遮盖\n        ...\n    }\n}\n```\n\n```cpp\nclass SomeClass {\npublic:\n    void Fun()\n    {\n        std::string msg;         // 不符合：类成员变量被遮盖\n        ...\n    }\n\nprivate:\n   std::string msg;\n};\n```",
        "修改建议": "重命名变量",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "WordsTool.260 领袖",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.213 小程序 ",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.4 版权头",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "重复文件[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1092"
    },
    {
        "规则名称": "G.FMT.12-CPP 避免将if/else/else if写在同一行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：else 与 if 在同一行\r\n- 修复示例：\r\n\r\n```c++\r\nif (someConditions) {\r\n    DoSomething();\r\n    ...\r\n} else {                                 // 符合：else 与 if 在不同行\r\n    ...\r\n}\r\n```\r\n##### 场景2：else if 与 if 在同一行\r\n- 修复示例：\r\n\r\n```c++\r\nif (someConditions) {\r\n    DoSomething();\r\n    ...\r\n} else if (...) { // 符合：else if 与 if 在不同行\r\n    ...\r\n} else {          // 符合：else 与 if 在不同行                       \r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：else 与 if 在同一行\r\n- 错误示例：\r\n\r\n```c++\r\nif (someConditions) { ... } else { ... } // 不符合：else 与 if 在同一行\r\n```\r\n##### 场景2：else if 与 if 在同一行\r\n- 错误示例：\r\n\r\n```c++\r\nif (someConditions) { ... } else if (...) { ... } else { ... } // 不符合：else 与 if 在同一行\r\n```",
        "修改建议": "将`else`、`else if`语句拆分到多行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "G.INC.07 禁止通过声明的方式引用外部函数接口、变量【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：通过声明的方式引用外部函数和变量\r\n- 修复示例：\r\n\r\n```c\r\n// b.h\r\nint Foo(void);\r\nextern int g_bar;\r\n\r\n// a.c\r\n#include \"b.h\"        // 符合：通过包含头文件的方式使用其他.c提供的接口\r\nint Func(void)\r\n{\r\n    int i = Foo();    // 这里使用了外部接口\r\n    ...\r\n    return g_bar;     // 这里使用了外部变量\r\n}\r\n\r\n// b.c\r\nint Foo(void)\r\n{\r\n    // 执行某些操作\r\n}\r\nint g_bar;\r\n```",
        "错误示例": "##### 场景1：通过声明的方式引用外部函数和变量\r\n- 错误示例：\r\n\r\n```c\r\n// a.c\r\nextern int Foo(void); // 不符合：通过声明的方式引用外部函数\r\nextern int g_bar;     // 不符合：通过声明的方式引用外部全局变量\r\nint Func(void)\r\n{\r\n    int i = Foo();    // 这里使用了外部接口\r\n    ...\r\n    return g_bar;     // 这里使用了外部变量\r\n}\r\n```",
        "修改建议": "修改为通过头文件引入外部变量和函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "646"
    },
    {
        "规则名称": "WordsTool.29 broadcastreceiver",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.9 AMS",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUN.03-CPP 禁止函数有未被使用的参数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1;IgnoredFunctions:\"\"",
        "正确示例": "##### 场景1：参数未使用\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo(int a) // 符合：删除冗余的参数\r\n{\r\n    Bar(a);\r\n}\r\n```\r\n##### 场景2：参数实际未使用，但该函数按照接口实现，必须有该参数\r\n- 修复示例1：将参数filename、lineNo注释掉\r\n\r\n```cpp\r\nvoid LogInfo(const char* /* fileName */, int /* lineNo */, std::string_view content) // 符合\r\n{\r\n    g_logFile << content << std::endl;\r\n}\r\n```\r\n- 修复示例2：在C++17可以显式指定该参数是未被使用的\r\n\r\n```cpp\r\nvoid LogInfo([[maybe_unused]] const char* fileName, [[maybe_unused]] int lineNo, std::string_view content) // 符合\r\n{\r\n    g_logFile << content << std::endl;\r\n}\r\n```",
        "错误示例": "##### 场景1：参数未使用\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(int a, int b) // 不符合：参数b未使用\r\n{\r\n    Bar(a);\r\n}\r\n```\r\n##### 场景2：参数实际未使用，但该函数按照接口实现，必须有该参数\r\n- 错误示例：参数filename、lineNo未使用\r\n\r\n```cpp\r\nvoid LogInfo(const char* fileName, int lineNo, std::string_view content) // 不符合\r\n{\r\n    g_logFile << content << std::endl;\r\n}\r\n```",
        "修改建议": "1. 请删除冗余的函数参数。\r\n2. 如果此未被使用的参数由于某些原因需要保留，应通过注释的方式将该参数修改为未命名参数，或者显式指定出该参数是未被使用的（C++17中提供了`[[maybe_unused]]`属性）。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "563,1041"
    },
    {
        "规则名称": "G.EXP.05-CPP 禁止通过声明的方式引用外部函数接口和变量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "ForbidExternExternalsCheckHeaderFile:",
        "正确示例": "在Foo.cpp中通过包含头文件Bar.h的方式使用Bar.cpp中的函数。\n\n```cpp\n// Foo.cpp\n#include \"Bar.h\"   // 符合： 通过包含头文件的方式使用其他.cpp提供的接口\n\nvoid Foo() \n{\n    int i = Bar();\n    ...\n}\n```\n\n```cpp\n// Bar.h\nint Bar();\n...\n```\n\n```cpp\n// Bar.cpp\n#include \"Bar.h\"\n\nint Bar()\n{\n    ...\n    return 0;\n}\n...\n```\n\n**【例外】**  \n有些场景需要引用其内部函数，但并不想侵入代码时，可以通过 extern 声明方式引用。如：\n- 针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数\n- 当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数",
        "错误示例": "在Foo.cpp中使用extern声明的方式使用了Bar.cpp中的函数。\n\n```cpp\n// Foo.cpp\nextern int Bar();  // 不符合：通过extern的方式使用外部函数\n\nvoid Foo() \n{\n    int i = Bar();\n    ...\n}\n```\n\n```cpp\n// Bar.cpp\nint Bar()\n{\n    ...\n    return 0;\n}\n...\n```",
        "修改建议": "通过头文件包含来使用接口。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "646"
    },
    {
        "规则名称": "WordsTool.161 QuickApp",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ARR.03 禁止通过对指针变量进行sizeof操作来获取数组大小【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：将指针当做数组进行sizeof操作时，返回的是指针的内存大小，而不是指针指向对象的大小。\r\n- 修复示例：使用buffer缓冲区申请时，设置的内存大小。\r\n```cpp\r\n#define SIZE 1000\r\n\r\nvoid TestGoodCase1()\r\n{\r\n    char path[MAX_PATH];\r\n    char *buffer = (char *)malloc(SIZE);\r\n    ...\r\n    memset(path, 0, sizeof(path));\r\n\r\n    // 符合：使用申请buffer缓冲区的大小\r\n    memset(buffer, 0, SIZE);\r\n}\r\n```\r\n\r\n##### 场景2：在sizeof的操作数内，对变量进行赋值或自增自减的操作。\r\n- 修复示例：在sizeof操作数外对变量做赋值或者自增自减。\r\n```cpp\r\n#define INIT_NUM 1000\r\n\r\nvoid TestGoodCase2()\r\n{\r\n    int32_t data = INIT_NUM;\r\n    data++;\r\n    size_t size = sizeof(data);             // 符合\r\n    printf(\"%zu\\n\", size);\r\n}\r\n```",
        "错误示例": "##### 场景1：将指针当做数组进行sizeof操作时，返回的是指针的内存大小，而不是指针指向对象的大小。\r\n- 错误示例：\r\n```C\r\n#define SIZE 1000\r\n\r\nvoid TestBadCase1()\r\n{\r\n    char path[MAX_PATH];\r\n    char *buffer = (char *)malloc(SIZE);\r\n    ...\r\n    memset(path, 0, sizeof(path));\r\n\r\n    // 不符合：错误使用指针的内存大小\r\n    memset(buffer, 0, sizeof(buffer));\r\n}\r\n```\r\n\r\n##### 场景2：在sizeof的操作数内，对变量进行赋值或自增自减的操作。\r\n- 错误示例：\r\n```C\r\n#define INIT_NUM 1000\r\n\r\nvoid TestBadCase2()\r\n{\r\n    int32_t data;\r\n    size_t size1 = sizeof(data = INIT_NUM); // 不符合：这里data没有被赋值\r\n    size_t size2 = sizeof(data++);          // 不符合：这里data不会自增\r\n    printf(\"%zu, %zu\\n\", size1, size2);\r\n}\r\n```",
        "修改建议": "禁止通过对指针变量进行sizeof操作来获取数组大小。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "467"
    },
    {
        "规则名称": "WordsTool.288 全网最低价",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.247 首选",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.92 GatewayInfo",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.10-CPP 函数的返回类型及修饰符与函数名同行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "函数返回值及修饰符与函数名调整到同一行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.41 CarProperty",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.37 CarAppFocusManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "超大圈复杂度[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "新增阈值:20;修改阈值:20",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1121"
    },
    {
        "规则名称": "WordsTool.315 黄赌毒",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.292 纯天然",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.294 全面",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.144 NEURALA",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.259 至尊",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.10-CPP 通过基类指针释放派生类时，必须将基类中析构函数声明为虚函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：基类的析构函数声明为`非虚函数`，导致派生类数据的内存泄漏。\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    // 符合：基类的析构函数声明为`虚函数`\r\n    virtual ~Base()\r\n    {\r\n        std::cout << \"~Base\" << std::endl;\r\n    }\r\n    virtual std::string GetVersion() = 0;\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    Derived()\r\n    {\r\n        constexpr size_t numberCount = 100;\r\n        numbers = new int[numberCount];\r\n    }\r\n\r\n    // 在重写虚函数时应明确指定override或final\r\n    ~Derived() override\r\n    {\r\n        delete[] numbers;\r\n        std::cout << \"~Derived\" << std::endl;\r\n    }\r\n\r\n    std::string GetVersion() override\r\n    {\r\n        return std::string(\"hello!\");\r\n    }\r\n\r\nprivate:\r\n    int* numbers;\r\n};\r\n\r\nvoid Foo()\r\n{\r\n    Base* base = new Derived();\r\n    delete base; // 先调用基类的析构函数，再调用派生类的析构函数，不存在内存泄漏\r\n}\r\n```",
        "错误示例": "##### 场景1：基类的析构函数声明为`非虚函数`，导致派生类数据的内存泄漏。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    Base() = default;\r\n    // 不符合：基类的析构函数声明为`非虚函数`\r\n    ~Base()\r\n    {\r\n        std::cout << \"~Base\" << std::endl;\r\n    }\r\n    virtual std::string GetVersion() = 0;\r\n};\r\n\r\nclass Derived : public Base {\r\npublic:\r\n    Derived()\r\n    {\r\n        constexpr size_t numberCount = 100;\r\n        numbers = new int[numberCount];\r\n    }\r\n\r\n    ~Derived()\r\n    {\r\n        delete[] numbers;\r\n        std::cout << \"~Derived\" << std::endl;\r\n    }\r\n\r\n    std::string GetVersion() override\r\n    {\r\n        return std::string(\"hello!\");\r\n    }\r\n\r\nprivate:\r\n    int* numbers;\r\n};\r\n\r\nvoid Foo()\r\n{\r\n    Base* base = new Derived();\r\n    delete base;                // 调用的是 Base 的析构函数，造成资源泄漏\r\n}\r\n```",
        "修改建议": "如果类作为多态基类使用，析构函数需声明为虚函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1079"
    },
    {
        "规则名称": "G.STD.15-CPP 禁止外部可控数据作为进程启动函数的参数或者作为dlopen/LoadLibrary等模块加载函数的参数",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，使用C++17提供的文件复制函数实现了文件复制的功能，避免了对 cp 或 cat 命令的调用。需要注意的是，为简化描述，下面代码仅供参考。\n\n```c\nbool WriteDataToFile(const std::string& dstFilePath, const std::string& srcFilePath)\n{\n  std::error_code errorCode;\n  bool success = std::filesystem::copy_file(srcFilePath, dstFilePath, errorCode);\n  if (!success) {\n   ... // 错误处理\n }\n  return success;\n}\n```\n\n如果确实需要调用单个命令，应使用exec*函数来实现参数化调用，并对调用的命令实施白名单管理。同时应避免使用execlp、execvp、execvpe函数，因为这几个函数依赖外部的PATH环境变量。此时，外部输入的fileName仅作为some_tool命令的参数，没有命令注入的风险。\n\n```c\npid_t pid;\nchar* const envp[] = {nullptr};\n...\nstd::string fileName = GetDirNameFromRemote();\n...\npid = fork();\nif (pid < 0) {\n  ... // 错误处理\n} else if (pid == 0) {\n  // 使用some_tool对指定文件进行加工\n  execle(\"/bin/some_tool\", \"some_tool\", fileName.c_str(), nullptr, envp);\n  _Exit(-1);\n}\n...\n```\n\n在必须使用system等命令解析器执行命令时，应对输入的命令字符串基于合理的白名单检查，避免命令注入。\n\n```c\nstd::string cmd = GetCmdFromRemote();\n\n// 使用白名单检查命令是否合法，仅允许\"some_tool_a\", \"some_tool_b\"命令，外部无法随意控制\nif (!IsValidCmd(cmd.c_str())) {\n   ... // 错误处理\n}\nsystem(cmd.c_str());\n...\n```",
        "错误示例": "如下代码中，从外部获取数据后直接作为LoadLibrary函数的参数，有可能导致程序被植入木马。\n\n```C\nchar* msg = GetMsgFromRemote();\nLoadLibrary(msg);\n```\n\n如下代码中，使用 system() 函数执行 cmd 命令串来自外部，攻击者可以执行任意命令：\n```C\nstd::string cmd = GetCmdFromRemote();\nsystem(cmd.c_str());\n```\n如下代码中，使用 system() 函数执行 cmd 命令串的一部分来自外部，攻击者可能输入  some dir;reboot 字符串，创造成系统重启：\n```C\nstd::string name = GetDirNameFromRemote();\nstd::string cmd{\"ls \" + name};\nsystem(cmd.c_str());\n```\n\n使用exec系列函数来避免命令注入时，注意exec系列函数中的path、file参数禁止使用命令解析器(如/bin/sh)。\n\n```C\nint execl(const char* path, const char* arg, ...);\nint execlp(const char* file, const char* arg, ...);\nint execle(const char* path, const char* arg, ...);\nint execv(const char* path, char* const argv[]);\nint execvp(const char* file, char* const argv[]);\nint execvpe(const char* file, char* const argv[], char* const envp[]);\n```\n\n例如，禁止如下使用方式：\n```C\nstd::string cmd = GetDirNameFromRemote();\nexecl(\"/bin/sh\", \"sh\", \"-c\", cmd.c_str(), nullptr);\n```\n在Linux下可以使用库函数，或者可以通过编写少量的代码来避免使用system函数调用命令，如mkdir() 函数可以实现 mkdir 命令的功能。\n\n如下代码中，应该避免使用 cp 命令实现文件内容复制的功能。\n\n```C\nint WriteDataToFile(const char* dstFile, const char* srcFile)\n{\n  ...  // 入参的合法性校验\n  std::ostringstream oss;\n  oss << \"cp \" << srcFile << \" \" << dstFile;\n  std::string cmd{oss.str()};\n  system(cmd.c_str());\n  ...\n}\n```",
        "修改建议": "优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "78"
    },
    {
        "规则名称": "WordsTool.126 libunwindstack",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.21 禁止使用内存操作类不安全函数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "调用安全函数memcpy_s\n```c\nvoid riskyFunc_good(char* src)\n{\n    char dest[16] = {0};\n    // 推荐使用安全函数，增加destMax参数，对目的缓冲区做保护\n    memcpy_s(dest, sizeof(dest), p, strlen(src));\n}\n```",
        "错误示例": "调用危险函数memcpy\n```C\nvoid riskyFunc_bad(char* src)\n{\n    char dest[16] = {0};\n    // 使用危险函数，目的缓冲区未做保护，若src的长度大于16，则会造成dest拷贝越界\n    memcpy(dest, p, strlen(src));\n}\n```",
        "修改建议": "使用安全函数替代危险函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "242"
    },
    {
        "规则名称": "WordsTool.197 VoiceCallManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.2 aapt2",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.299 香港",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ARR.07 声明一个带有外部链接的数组时，必须显式指定它的大小【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "SuppressByComment:0",
        "正确示例": "##### 场景1：没有显式指定数组大小\r\n- 修复示例：\r\n\r\n```c\r\n// in foo.h\r\nextern int g_array[MAX_LEN];   // 符合：显式指定了数组大小\r\n```\r\n- 修复示例：\r\n\r\n```c\r\n// in foo.h\r\nconst char g_array[];\r\nconst size_t g_arrayLen; // 符合：显式指定了数组大小，且和数组声明之间无间隔\r\n```",
        "错误示例": "##### 场景1：没有显式指定数组大小\r\n- 错误示例：\r\n\r\n```c\r\n// in foo.h\r\nextern int g_array[];     // 不符合：没有显式指定数组大小\r\n```",
        "修改建议": "数组声明时，同时显式指定其大小，如：\r\n1. 固定长度数组\r\n```c\r\nextern int g_array[MAX_LEN]; \r\n```\r\n2. 需要通过计算的数组长度，注意**数组和数组长度参数**的声明放一起，中间不要有间隔。\r\n```c\r\nconst char g_array[];\r\nconst size_t g_arrayLen;\r\n```",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "129"
    },
    {
        "规则名称": "G.FUU.03 调用格式化输入/输出函数时，使用有效的格式字符串【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "正确的做法是确保printf()函数的实参匹配format的转换指示符。\n```c\nvoid Foo(void)\n{\n  const char *infoMsg = \"Information seed to user.\";\n  int infoLevel = 3;\n  ...\n  printf(\"infoLevel: %d, infoMsg: %s\\n\", infoLevel, infoMsg);\n  ...\n}\n```",
        "错误示例": "如下代码示例中，printf()的实参infoLevel类型与对应的转换指示符's'不匹配，正确的转换指示符要使用'd'。同样，实参infoMsg类型与对应的转换指示符'd'不匹配，正确的转换指示符要使用's'。\n\n这些用法会使程序产生未定义行为，比如：printf()将把infoLevel实参解释为指针，试图从infoLevel包含的地址中读取一个字符串，从而发生非法访问。\n\n```C\nvoid Foo(void)\n{\n  const char *infoMsg = \"Information seed to user.\";\n  int infoLevel = 3;\n  ...\n  printf(\"infoLevel: %s, infoMsg: %d\\n\", infoLevel, infoMsg);\n  ...\n}\n```",
        "修改建议": "确保format函数参数个数和实际参数个数一致。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "628"
    },
    {
        "规则名称": "G.EXP.04 用括号明确表达式的操作顺序，避免过分依赖默认优先级【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：位操作符没有加括号\r\n- 修复示例：\r\n\r\n```cpp\r\nc = (a & 0xFF) + b; // 符合：涉及位操作符，需要括号\r\n```",
        "错误示例": "##### 场景1：位操作符没有加括号\r\n- 错误示例：\r\n\r\n```cpp\r\nc = a & 0xFF + b; // 不符合\r\n```",
        "修改建议": "添加括号来明确表达式的操作顺序。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "783"
    },
    {
        "规则名称": "WordsTool.84 EuiccConnector",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.183 tombstone",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.223 最先进",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.AST.05 一个断言只用于检查一个错误【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：断言同时校验多个错误。\r\n- 修复示例：如果要校验多个错误，应该将每个错误分开，一个断言只用于检查一个错误。\r\n\r\n    ```c\r\n    int Foo(int *array, size_t size)\r\n    {\r\n        ASSERT(array != NULL);          // 符合：一个断言只用于检查一个错误\r\n        ASSERT(size > 0);               // 符合：一个断言只用于检查一个错误\r\n        ASSERT(size <= ARRAY_SIZE_MAX); // 符合：一个断言只用于检查一个错误\r\n        ...\r\n    }\r\n    ```",
        "错误示例": "##### 场景1：断言同时校验多个错误。\r\n- 错误示例：\r\n\r\n    ```c\r\n    int Foo(int *array, size_t size)\r\n    {\r\n        ASSERT(array != NULL && size > 0 && size <= ARRAY_SIZE_MAX); // 不符合：在断言触发的时候，无法判断到底是哪一个错误触发了断言\r\n        ...\r\n    }\r\n    ```",
        "修改建议": "一个断言只用于检查一个错误。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.314 地图",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.309 妖魔鬼怪",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.298 Atomic Ability",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.DCL.01 不要声明或定义保留的标识符【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：定义双下划线开头的标识符\r\n- 修复示例：\r\n\r\n```cpp\r\n#define FUNC // 符合\r\n```\r\n##### 场景2：定义单下划线加一个大写字母开头\r\n- 修复示例：\r\n\r\n```cpp\r\n#ifndef HEADER // 符合\r\n#define HEADER\r\n\r\n#endif\r\n```",
        "错误示例": "##### 场景1：定义双下划线开头的标识符\r\n- 错误示例：\r\n\r\n```cpp\r\n#define __FUNC__ // 不符合：双下划线的，或者以单下划线加一个大写字母开头的标识符，为实现保留\r\n```\r\n##### 场景2：定义单下划线加一个大写字母开头\r\n- 错误示例：\r\n\r\n```cpp\r\n#ifndef _HEADER_ // 不符合：单下划线加一个大写字母开头\r\n#define _HEADER_\r\n\r\n#endif\r\n```",
        "修改建议": "修改标识符名称。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "WordsTool.194 VM Reboot VM WatchDog",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.OTH.01 删除无效或永不执行的代码",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：return之后的代码永不执行\r\n- 修复示例：\r\n```cpp\r\n// 符合\r\nint Foo() {\r\n    return 0;\r\n}\r\n```\r\n\r\n##### 场景2：goto之后的代码永不执行\r\n- 修复示例：\r\n```cpp\r\n// 符合\r\nint Foo(int x, int y)\r\n{\r\n    y++;\r\n    if (x < 10) {\r\n        y++;\r\n        return y;\r\n    }\r\n    return x;\r\n}\r\n```\r\n\r\n##### 场景3：无条件的break导致循环只执行一次\r\n- 修复示例：\r\n```cpp\r\n// 符合\r\nvoid Foo(const char *array, uint32_t len)\r\n{\r\n    for (uint32_t i = 0; i < len; i++) {\r\n        if (array[i] > LEN_MAX) {\r\n            array[i] = 0;\r\n        }\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：return之后的代码永不执行\r\n- 错误示例：\r\n\r\n```cpp\r\nint Foo() {\r\n    return 0;\r\n    Bar(); // 不符合：该行及以下代码永不执行\r\n    return x;\r\n}\r\n```\r\n\r\n##### 场景2：goto之后的代码永不执行\r\n- 错误示例：\r\n\r\n```cpp\r\nint Foo(int x, int y)\r\n{\r\n    y++;\r\n    goto out;\r\n    if (x < 10) { // 不符合：该行及以下代码永不执行\r\n        y++;\r\n        return y;\r\n    }\r\nout:\r\n    return x;\r\n}\r\n```\r\n\r\n##### 场景3：无条件的break导致循环只执行一次\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(const char *array, uint32_t len)\r\n{\r\n    for (uint32_t i = 0; i < len; i++) {\r\n        if (array[i] > LEN_MAX) {\r\n            array[i] = 0;\r\n        }\r\n        break; // 不符合：循环只执行一次就退出，循环递增i++没有执行过\r\n    }\r\n}\r\n```",
        "修改建议": "删除不可执行代码",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "561,1041"
    },
    {
        "规则名称": "G.FUU.10 禁止使用alloca()函数申请栈上内存",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "使用malloc()函数\n```c\n// 使用malloc()函数\nchar *newPtr = (char *)malloc(NEW_SIZE);\nif (newPtr == NULL) {\n  ... // 错误处理\n}\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\n... // 校验ret，确保安全函数执行成功\n... // 返回前，释放oldPtr\n```",
        "错误示例": "使用了alloca函数\n```C\nvoid use_alloca()\n{\n    /* POTENTIAL FLAW: Forbid use alloca() */\n    int *p = (int *)alloca(sizeof(int) * 10); \n    free(p); \n    return;\n}\n```",
        "修改建议": "禁止调用alloca函数，请使用malloc从堆中动态分配内存。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.94 GMV",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.15 只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数--检查用户自定义类安全函数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景2：自定义安全函数strncpy_s。\r\n- 修复示例：不能自定义安全函数，只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数。\r\n```cpp\r\n略\r\n```\r\n\r\n##### 场景1：自定义安全函数。\r\n- 修复示例：不能自定义安全函数，只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数。\r\n```c\r\n略\r\n```",
        "错误示例": "##### 场景1：自定义安全函数memcpy_s。\r\n- 错误示例：\r\n```c\r\n// 不符合：和华为安全函数同名\r\nvoid memcpy_s(char *dest, size_t destMax, char *src, size_t count)\r\n{\r\n    ...\r\n}\r\n\r\n// 不符合：包含华为安全函数名\r\nvoid CUS_memcpy_s(char *dest, size_t destMax, char *src, size_t count)\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景2：自定义安全函数strncpy_s。\r\n- 错误示例：\r\n```c\r\n// 不符合：和华为安全函数同名\r\nvoid strncpy_s(char *strDest, const char *strSrc, size_t count)\r\n{\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景3：自定义安全函数。\r\n- 错误示例：\r\n\r\n```c\r\n// 不符合：自定义安全函数\r\nvoid Memcpy_s(void *dest, unsigned int destMax, const void *src, unsigned int count)\r\n{\r\n    if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN) {\r\n        return;\r\n    }\r\n    if (dest == NULL || src == NULL) {\r\n        return;\r\n    }\r\n    if (count > destMax) {\r\n        return;\r\n    }\r\n    if (dest == src) {\r\n        return;\r\n    }\r\n    if (((uint32_t)dest > (uint32_t)src && (uint32_t)dest < (uint32_t)((uint8_t *)src + count)) ||\r\n        ((uint32_t)src > (uint32_t)dest && (uint32_t)src < (uint32_t)((uint8_t *)dest + count))) {\r\n        return;\r\n    }\r\n    memcpy(dest, src, count);\r\n    return;\r\n}\r\n```",
        "修改建议": "不要自定义安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.PRE.10 宏定义不应依赖宏外部的局部变量名【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：宏依赖外部局部变量\r\n- 修复示例1：\r\n\r\n```cpp\r\n// 符合：将需要引用的局部变量作为宏参数传递进来\r\n#define INIT(ret, x) do { \\\r\n    ret = (x)->y->length; \\\r\n} while (0)\r\n\r\n...\r\nINIT(count, msg);\r\n```\r\n- 修复示例2：\r\n\r\n```cpp\r\n// 符合：将宏定义中引用外部局部变量的代码分离出去\r\n#define INIT(x) ((x)->y->length)\r\n\r\n...\r\nint count = INIT(msg);\r\n```",
        "错误示例": "##### 场景1：宏依赖外部局部变量\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：宏依赖外部局部变量count\r\n#define INIT(x) do { \\\r\n    count = (x)->y->length; \\\r\n} while (0)\r\n\r\n...\r\nint count;\r\nINIT(msg);\r\n```",
        "修改建议": "1. 将需要引用的局部变量作为宏参数传递进来。\r\n2. 将宏定义中引用外部局部变量的代码分离出去。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "WordsTool.234 世界级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.04 一行只有一条语句【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：多个变量声明放在同一行\r\n- 修复示例：\r\n\r\n```cpp\r\nint count = 10;                          // 符合\r\nbool isCompleted = false;                // 符合\r\n\r\nint a = 0;                               // 符合\r\nint b = 0;                               // 符合\r\n\r\nchar *str = nullptr;                     // 符合\r\nchar ch;                                 // 符合\r\nchar arr[10];                            // 符合\r\n\r\nint x;\r\nint y;\r\n...\r\nx = 1;                                   // 符合\r\ny = 2;                                   // 符合\r\n```\r\n##### 场景2：一行多个语句\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func(int a, int b)\r\n{\r\n    if (b > 6) {\r\n        a = b; // 符合\r\n        b--;   // 符合\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：多个变量声明放在同一行\r\n- 错误示例：\r\n\r\n```cpp\r\nint count = 10; bool isCompleted = false; // 不符合：多个变量初始化需要分开放在多行\r\n\r\nchar *str, ch, arr[10];                   // 不符合：多个变量定义且类型不同，容易产生误解\r\nint a = 0, b = 0;                         // 不符合：多个变量定义需要分开放在多行\r\n\r\nint x;\r\nint y;\r\n...\r\nx = 1; y = 2;                             // 不符合：一行中存在多个赋值语句\r\n```\r\n##### 场景2：一行多个语句\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func(int a, int b)\r\n{\r\n    if (b > 6) {\r\n        a = b; b--; // 不符合\r\n    }\r\n}\r\n```",
        "修改建议": "将语句拆分到多行，一行只有一条语句。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.76 dex2oat",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.311 枪杀",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.08 禁止宏调用参数中出现预编译指令【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：宏调用参数中出现预编译指令`#ifdef`\r\n- 修复示例：\r\n\r\n```cpp\r\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\r\n\r\nint Foo(void)\r\n{\r\n#ifdef PLATFORM1\r\n    WRITE_LOG(\"Notice: Something error.\");  // 符合：改为在每个预编译指令下均调用一次宏\r\n#else\r\n    WRITE_LOG(\"Code: 4567\");                // 符合\r\n#endif\r\n}\r\n```\r\n##### 场景2：宏调用参数中出现预编译指令`#define`\r\n- 修复示例：\r\n\r\n```cpp\r\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\r\n#define ERR_INFO \"Notice: Something error.\" // 宏在函数外定义\r\n\r\nint Foo(void)\r\n{\r\n    WRITE_LOG(ERR_INFO); // 符合\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：宏调用参数中出现预编译指令`#ifdef`\r\n- 错误示例：\r\n\r\n```cpp\r\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\r\n\r\nint Foo(void)\r\n{\r\n    // 不符合：宏调用参数中出现预编译指令\r\n    WRITE_LOG(\r\n#ifdef PLATFORM1\r\n    \"Notice: Something error.\"\r\n#else\r\n    \"Code: 4567\"\r\n#endif\r\n    );\r\n}\r\n```\r\n##### 场景2：宏调用参数中出现预编译指令`#define`\r\n- 错误示例：\r\n\r\n```cpp\r\n#define WRITE_LOG(X)  printf(\"%s\\n\", #X)\r\n\r\nint Foo(void)\r\n{\r\n    // 不符合：宏调用参数中出现预编译指令\r\n    WRITE_LOG(\r\n#define ERR_INFO \"Notice: Something error.\"\r\n        ERR_INFO\r\n    );\r\n    ...\r\n}\r\n```",
        "修改建议": "宏参数不要出现预编译指令，可改为在每个预编译指令下均调用一次宏。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "758"
    },
    {
        "规则名称": "WordsTool.25 bicdriod",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.268 前所未见",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.5 Accessibility",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.44 Carservice",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.78 DriverCall",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.219 最美",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.266 史无前例",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.174 SoundTrigger",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.15-CPP 声明中的非类型描述符应该在类型描述符左边",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：非类型描述符放在类型描述符右边\r\n- 修复示例：\r\n\r\n```cpp\r\nstatic int i;       // 符合：static 放在 int 左边\r\nvirtual void Fun(); // 符合：virtual 放在 void 左边\r\nvolatile int k;     // 符合\r\nextern void Bar();  // 符合\r\n```",
        "错误示例": "##### 场景1：非类型描述符放在类型描述符右边\r\n- 错误示例：\r\n\r\n```cpp\r\nint static i;       // 不符合\r\nvoid virtual Fun(); // 不符合\r\nint volatile k;     // 不符合\r\nvoid extern Bar();  // 不符合\r\n```",
        "修改建议": "非类型描述符（如：static、virtual、volatile、extern）放在类型描述符的左边。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.300 澳门",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.10 特殊词汇",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐--操作符换行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：换行时二元操作符放在行首\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Func(int32_t val1, int32_t val2)\r\n{\r\n    int32_t sum = val1 + // 符合：换行时'+'位于行末\r\n        val2;\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：换行时二元操作符放在行首\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Func(int32_t val1, int32_t val2)\r\n{\r\n    int32_t sum = val1\r\n        + val2; // 不符合：换行时'+'位于行首\r\n    ...\r\n}\r\n```",
        "修改建议": "按要求进行对齐。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "OAT.1 二进制文件",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.RES.12-CPP 自定义new/delete操作符需要配对定义，且行为与被替换的操作符一致",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1",
        "正确示例": "##### 场景1：自定义了`operator new`，但是没有自定义对应的`operator delete`\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合：配对定义new和delete\r\nstruct S {\r\n    static void* operator new(size_t size)\r\n    {\r\n        ... // 自定义操作\r\n    }\r\n\r\n    static void operator delete(void* ptr) noexcept\r\n    {\r\n        ... // 自定义操作\r\n    }\r\n\r\n    static void operator delete(void* ptr, size_t size) noexcept  // C++14\r\n    {\r\n        ... // 自定义操作\r\n    }\r\n};\r\n```",
        "错误示例": "##### 场景1：自定义了`operator new`，但是没有自定义对应的`operator delete`\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：如果自定义了 operator new，必须同时自定义对应的 operator delete\r\nstruct S {\r\n    static void* operator new(size_t size)\r\n    {\r\n        ... // 自定义操作\r\n    }\r\n};\r\n```",
        "修改建议": "1. 如果自定义了`operator new`，必须同时自定义对应的`operator delete`。\r\n2. 如果自定义了`operator new[]`，必须同时自定义对应的`operator delete[]`。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "401,762"
    },
    {
        "规则名称": "WordsTool.198 VUE",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.12 正确设置安全函数中的destMax参数--检查destMax和count参数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "以下代码，destBuff跨越到不可访问内存，属于误用：\n\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nmemcpy_s(destBuff, 0x7fffffff, src, srcLen); // 不符合\n```\ndestMax参数设置原则：\n\n（为聚焦于说明destMax的用法，示例代码中省略了安全函数的返回值检查以及其他检查）\n\n1. destBuff 为 char destBuff[BUFF_SIZE] 形式的局部变量的情况\n\n1.1 使用时，destMax必须设置为 sizeof(destBuff) 或 BUFF_SIZE\n【反例】\n```C\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\n...\nmemcpy_s(destBuff, 100, src, srcLen);       // 不符合\nmemcpy_s(destBuff, srcLen, src, srcLen);     // 不符合\n```\n【正例】\n```c\n#define BUFF_SIZE 100\n...\nchar destBuff[BUFF_SIZE];\nchar *src = ...\nsize_t srcLen = ...\nchar strDest[BUFF_SIZE];\n...\nmemcpy_s(destBuff, sizeof(destBuff), src, srcLen);   // 符合\nmemcpy_s(destBuff, BUFF_SIZE, src, srcLen);           // 符合\nsprintf_s(strDest, sizeof(strDest), \"Hello, world\"); // 符合\n...\nmemset_s(strDest, BUFF_SIZE, 0, BUFF_SIZE);           // 符合\nscanf_s(\"%s\", strDest, sizeof(strDest));             // 符合\n```\n1.2 如果 destBuff 作为参数跨函数传递，必须将 destBuff 的实际大小作为参数进行传递\n\n【反例】\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, 100);   // 不符合\n    ParseBuff2(destBuff);       // 不符合：必须增加destMax参数\n    ...\n}\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, BUFF_SIZE, src, srcLen);         // 不符合\n    memcpy_s(destBuff, sizeof(destBuff), src, srcLen); // 不符合\n    memcpy_s(destBuff, 100, src, srcLen);               // 不符合\n    memcpy_s(destBuff, srcLen, src, srcLen);           // 不符合\n  ...\n}\n```\n\n【正例】\n\n```c\n#define BUFF_SIZE 100\nint Foo(void)\n{\n    char destBuff[BUFF_SIZE];\n    ...\n    ParseBuff(destBuff, BUFF_SIZE); // 符合：传递BUFF_SIZE\n    ...\n}\n\nint ParseBuff(char *destBuff, size_t destMax)\n{\n    char *src = ...\n    size_t srcLen = ...\n    memcpy_s(destBuff, destMax, src, srcLen);   // 符合\n    ...\n}\n```",
        "修改建议": "正确设置memcpy_s、strcpy_s等函数的destMax和count参数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "G.EXP.14-CPP 使用由C++提供的类型转换操作",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用C风格强转，将基类转换为派生类\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Base { ... };\r\nclass Derived : public Base { ... };\r\n\r\nvoid Foo(Base *b)\r\n{\r\n    Derived *d = dynamic_cast<Derived *>(b);  // 符合：dynamic_cast 主要用于继承体系下行转换\r\n}\r\n```\r\n##### 场景2：使用C风格的强转，将整型转换成另一种整型\r\n- 修复示例：\r\n\r\n```cpp\r\ndouble a = 1.5;\r\nint i = static_cast<int>(a); // 符合：static_cast 可做值的强制转换\r\n```",
        "错误示例": "##### 场景1：使用C风格强转，将基类转换为派生类\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base { ... };\r\nclass Derived : public Base { ... };\r\n\r\nvoid Foo(Base *b)\r\n{\r\n    Derived *d = (Derived *)b;  // 不符合：C风格强转，不安全\r\n}\r\n```\r\n##### 场景2：使用C风格的强转，将整型转换成另一种整型\r\n- 错误示例：\r\n\r\n```cpp\r\ndouble a = 1.5;\r\nint i = (int)a; // 不符合\r\n```",
        "修改建议": "C++转换操作符用法说明参考如下，请根据业务场景合理选择：\r\n- dynamic_cast：主要用于继承体系下行转换，该转换具有类型检查的功能。应做好基类和派生类的设计，合理使用dynamic_cast:\r\n    1. dynamic_cast的出现一般说明基类和派生类设计出现了问题，派生类破坏了基类的契约，不得不通过dynamic_cast转换到派生类进行特殊处理，这个时候更希望来改善类的设计，而不是通过dynamic_cast来解决问题。\r\n    2. 如果强制转换不可避免，则应优先使用dynamic_cast，而不是使用static_cast，因为编译器将在运行时检查强制转换的有效性。\r\n- static_cast：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。如果是纯粹的算术转换，那么可以使用大括号初始化方式转换。\r\n- reinterpret_cast：用于转换不相关的类型，是一种不安全的转换，应尽量少用reinterpret_cast。\r\n- const_cast：用于移除对象的const属性，使对象变得可修改，这样会破坏数据的不变性，应尽量少用const_cast。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "704,1076"
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--一元表达式",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：! 和变量之间有空格\r\n- 修复示例1：\r\n```cpp\r\nif (!bool_value) {           // 符合：移除多余的空格\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景2：& 和变量之间有空格\r\n- 修复示例1：\r\n```cpp\r\nchar c;\r\nchar *p = &c;               // 符合：移除多余的空格\r\n```",
        "错误示例": "##### 场景1：! 和变量之间有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nif (! bool_value) {          // 不符合：'!' 和 bool_value 之间有空格\r\n    ...\r\n}\r\n```\r\n\r\n##### 场景2：& 和变量之间有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nchar c;\r\nchar *p = & c;              // 不符合：'&' 和 c 之间有空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.166 RN",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "超大深度函数[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "修改阈值:4;新增阈值:4",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1124"
    },
    {
        "规则名称": "G.FMT.02-CPP 使用空格进行缩进，每次缩进4个空格",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "按要求进行缩进。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.CLS.08-CPP delete操作符、移动构造函数、移动赋值操作符、swap函数应该有noexcept声明",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "添加noexcept声明",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.263 引领者",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.69 DcController",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.271 最强",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.61 CXCallController",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.240 绝佳",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ERR.03-CPP 以左值引用的形式捕获异常",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：按值捕获基类，导致派生类对象被切片。\r\n- 修复示例：按引用捕获。\r\n\r\n```cpp\r\ntry {\r\n    throw BarException();\r\n} catch (const FooException& e) {            // 符合：按引用捕获，此时不会切片\r\n    ...\r\n}\r\ntry {\r\n    throw BarException();\r\n} catch (FooException& e) {                  // 符合：按非const引用捕获\r\n    e.AddMoreInformation(\"some info\");\r\n    throw;\r\n}\r\n```",
        "错误示例": "##### 场景1：按值捕获基类，导致派生类对象被切片。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass FooException : public std::exception {\r\n    ...\r\n};\r\nclass BarException : public FooException {\r\n    ...\r\n};\r\n\r\ntry {\r\n    throw BarException();\r\n} catch (FooException e) {                   // 不符合：被切片\r\n    ...\r\n}\r\n```",
        "修改建议": "改成以左值引用形式捕获异常。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "754,755"
    },
    {
        "规则名称": "WordsTool.123 JetPlayer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--关键信息【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：行尾有空格\r\n- 修复示例1：\r\n\r\n```cpp\r\n// 符合：清除行尾空格\r\nvoid Foo(int x);\r\n```\r\n##### 场景2：小括号内两侧有空格\r\n- 修复示例1：\r\n\r\n```cpp\r\nvoid Foo(int x);    // 符合：清除小括号内部两侧的空格\r\n```\r\n##### 场景3：逗号，分号，冒号前有空格\r\n- 修复示例1：\r\n\r\n```cpp\r\n// 符合：逗号，分号，冒号（不含三元操作符和表示位域的冒号）前无需空格，后需要空格\r\nvoid Foo(int x, int y, int z);\r\n```\r\n##### 场景4：#include 后无空格\r\n- 修复示例1：\r\n\r\n```cpp\r\n#include <stdio.h>  // 符合：#include指令后加上空格\r\n```",
        "错误示例": "##### 场景1：行尾有空格\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：行尾有空格\r\nvoid Foo(int x); \r\n```\r\n##### 场景2：小括号内两侧有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo( int x );  // 不符合：小括号内两侧有空格\r\n```\r\n##### 场景3：逗号，分号，冒号前有空格\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：第一个逗号前有多余的空格，第二个逗号后未加空格\r\nvoid Foo(int x ,int y,int z);\r\n```\r\n##### 场景4：#include 后无空格\r\n- 错误示例：\r\n\r\n```cpp\r\n#include<stdio.h>  // 不符合：#include指令后无空格\r\n```",
        "修改建议": "1. 清除行尾空格，IDE可设置**保存文件自动删除行尾多余空格**。\r\n2. 清除小括号内部两侧的空格。\r\n3. 逗号，分号，冒号（不含三元操作符和表示位域的冒号）前的空格清除，其后需有空格。\r\n4. `#include`指令与文件路径之间需要有空格。\r\n\r\n建议通过格式化工具自动修复。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.225 最高优惠",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.STD.10-CPP 在不需要修改迭代器指向的对象时，应使用const_iterator",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：没有对元素的内容进行修改\r\n- 修复示例1：使用C++11开始提供的cbegin()、cend()方法。\r\n\r\n```c++\r\nfor (auto iter = c.cbegin(); iter != c.cend(); ++iter) { // 符合\r\n    std::cout << *iter << std::endl;\r\n}\r\n```\r\n- 修复示例2：使用C++17提供了std::as_const\r\n\r\n```c++\r\nfor (auto& item : std::as_const(c)) { // 符合\r\n    std::cout << item << std::endl;\r\n}\r\n```",
        "错误示例": "##### 场景1：没有对元素的内容进行修改\r\n- 错误示例：\r\n\r\n```c++\r\n// 不符合：代码没有对元素的内容进行修改，应使用cbegin()和cend()\r\nfor (auto iter = c.begin(); iter != c.end(); ++iter) {\r\n    std::cout << *iter << std::endl;\r\n}\r\n```",
        "修改建议": "在不需要修改迭代器指向的对象时（如只读取对象的值，且仅使用对象的const方法），应使用`const_iterator`，如：C++11开始提供的cbegin()、cend()方法。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.212 quick application",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.58 CTSubscriber",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FIL.03 不要在共享目录中创建临时文件【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在系统共享目录中创建临时文件。\r\n- 修复示例：\r\n\r\n```c\r\n// 临时文件名不硬编码\r\nchar *filename = GetFileName();\r\n...\r\nsprintf_s(path, sizeof(path), \"/home/zhangsanproject/%s\", filename);\r\n// 符合：临时文件不能在共享目录中创建，应该在进程的独享目录中\r\nFILE *fp = fopen(path, \"wb+\");\r\nif (fp == NULL) {\r\n    ... // 错误处理\r\n}\r\n...\r\n```",
        "错误示例": "##### 场景1：在系统共享目录中创建临时文件。\r\n- 错误示例：\r\n\r\n```c\r\n// 不符合：1.在系统共享目录中创建临时文件；2.临时文件名硬编码\r\nFILE *fp = fopen(\"/tmp/data\", \"wb+\");\r\nif (fp == NULL) {\r\n    ... // 错误处理\r\n}\r\n...\r\n```",
        "修改建议": "不要在共享目录中创建临时文件。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "379"
    },
    {
        "规则名称": "G.OTH.03 禁用rand函数产生用于安全用途的伪随机数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "在类Unix平台上，可以使用/dev/random文件得到随机数。需要注意的是，设备刚启动时，由于硬件输入的熵可能不足，读取该接口可能产生阻塞问题。",
        "错误示例": "程序员期望生成一个唯一的不可被猜测的HTTP会话ID，但该ID是通过调用rand()函数产生的数字随机数，它的ID是可猜测的，并且随机性有限。",
        "修改建议": "1. 加解密场景必须使用安全随机数（非加解密场景可按误报处理）；\n2. IPSI组件的CRYPT_random，须确保开启了NIST SP 800-90A标准的DRBG后才可使用。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "338"
    },
    {
        "规则名称": "WordsTool.255 王牌",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.89 firebase",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.111 iOS Background Modes",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.11 用空格突出关键字和重要信息--一元表达式【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：`!` 和变量之间有空格\r\n- 修复示例1：\r\n\r\n```cpp\r\nif (!bool_value) {           // 符合：移除多余的空格\r\n    ...\r\n}\r\n```\r\n##### 场景2：`&` 和变量之间有空格\r\n- 修复示例1：\r\n\r\n```cpp\r\nchar c;\r\nchar *p = &c;               // 符合：移除多余的空格\r\n```",
        "错误示例": "##### 场景1：`!` 和变量之间有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nif (! bool_value) {          // 不符合：'!' 和 bool_value 之间有空格\r\n    ...\r\n}\r\n```\r\n##### 场景2：`&` 和变量之间有空格\r\n- 错误示例：\r\n\r\n```cpp\r\nchar c;\r\nchar *p = & c;              // 不符合：'&' 和 c 之间有空格\r\n```",
        "修改建议": "一元操作符（`&`，`*`，`+`，`‐`，`~`，`!`）之后不加空格，移除多余的空格。\r\n\r\n建议通过格式化工具自动修复。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.FMT.05 行宽不超过 120 个字符【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：一行超过120个字符\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int resultFileNumbersX = resultFileNumbers1 + resultFileNumbers2 + resultFileNumbers3 +\r\n        resultFileNumbers4 + resultFileNumbers5 + resultFileNumbers6 + resultFileNumbers7; // 符合，未超过120个字符\r\n    int resultFileNumbersY = resultFileNumbers1 + resultFileNumbers2; // 符合，未超过120个字符\r\n}\r\n```",
        "错误示例": "##### 场景1：一行超过120个字符\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    int resultFileNumbersX = resultFileNumbers1 + resultFileNumbers2 + resultFileNumbers3 + resultFileNumbers4 + resultFileNumbers5 + resultFileNumbers6 + resultFileNumbers7; // 不符合，超过120个字符\r\n    int resultFileNumbersY = resultFileNumbers1 + resultFileNumbers2; // 符合，未超过120个字符\r\n}\r\n```",
        "修改建议": "行宽超过120个字符要进行换行，换行请参考[G.FMT.06 换行时将操作符留在行末，新行缩进一层或进行同类对齐]。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "G.NAM.01 使用统一的命名风格【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：选择驼峰命名风格，但是使用时没有遵循\r\n- 修复示例：遵循驼峰命名风格。\r\n\r\n```cpp\r\nstruct StrType {                            // 符合：结构体类型使用“大驼峰”\r\n    int typeMember;                         // 符合：结构体中字段使用“小驼峰”\r\n};\r\n\r\nvoid Compare(int leftVal, int rightVal);    // 符合：函数大驼峰，参数小驼峰\r\n\r\nchar * const VERSION = \"V100\";              // 符合：常量用全大写下划线分割\r\n```\r\n\r\n##### 场景2：全局变量选择驼峰命名风格，但是使用时没有遵循\r\n- 修复示例：\r\n\r\n```cpp\r\nint g_variable;             // 符合：全局变量，带g_前缀的小驼峰\r\n```",
        "错误示例": "##### 场景1：选择驼峰命名风格，但是使用时没有遵循\r\n- 错误示例：\r\n\r\n```cpp\r\nstruct strType {                            // 不符合\r\n    int Type_Member;                        // 不符合\r\n};\r\n\r\nvoid compare(int left_val, int right_val);  // 不符合\r\n\r\nchar * const version = \"V100\";              // 不符合\r\n```\r\n\r\n##### 场景2：全局变量选择驼峰命名风格，但是使用时没有遵循\r\n- 错误示例：\r\n\r\n```cpp\r\nint Global_variable = 7;    // 不符合\r\n```",
        "修改建议": "修改标识符名称。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "G.CLS.15-CPP 禁止重载逗号操作符、&&操作符和||操作符",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：重载逗号操作符\r\n- 修复示例：禁止重载逗号操作符。\r\n略\r\n##### 场景2：重载&&操作符和||操作符\r\n- 修复示例：禁止重载&&操作符和||操作符。\r\n略",
        "错误示例": "##### 场景1：重载逗号操作符\r\n- 错误示例：\r\n```cpp\r\nA operator , (const A &other) const // 不符合\r\n{\r\n    return other;\r\n}\r\n```\r\n##### 场景2：重载&&操作符和||操作符\r\n- 错误示例：\r\n```cpp\r\nclass A {\r\npublic:\r\n    explicit A(int a) : m(a) {}\r\n    ~A() = default;\r\n    bool operator && (const A &other) const // 不符合\r\n    {\r\n        return m && other.m;\r\n    }\r\n    bool operator || (const A &other) const // 不符合\r\n    {\r\n        return m || other.m;\r\n    }\r\n\r\nprivate:\r\n    int m;\r\n};\r\n```",
        "修改建议": "不要重载逗号操作符、&&操作符和||操作符",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "480,768"
    },
    {
        "规则名称": "WordsTool.290 无敌",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.MEM.04 内存中的敏感信息使用完毕后立即清0【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：内存中的敏感信息使用完毕后没有清零\r\n\r\n使用含有敏感信息的局部变量（指针或数组），在退出该变量作用域前没有清除敏感信息的情况。\r\n- 修复示例：使用`memset_s`对敏感信息清零\r\n\r\n  ```c\r\n  void TestGood()\r\n  {\r\n      char psw[10] = {0};\r\n      Use(psw);\r\n      memset_s(psw, sizeof(psw), 0, sizeof(psw)); // 符合\r\n  }\r\n  ```",
        "错误示例": "##### 场景1：内存中的敏感信息使用完毕后没有清零\r\n\r\n使用含有敏感信息的局部变量（指针或数组），在退出该变量作用域前没有清除敏感信息的情况。\r\n- 错误示例：敏感信息`psw`使用完毕后没有立即清零\r\n\r\n  ```c\r\n  void TestBad()\r\n  {\r\n      char psw[10] = { 0 }; // 敏感信息相关变量\r\n      Use(psw);\r\n      /* POTENTIAL FLAW: the local variable 'psw' is sensitive information, it should be cleard by memset_s or VOS_memset_s\r\n      before function end. */\r\n  }\r\n  ```",
        "修改建议": "内存中的敏感信息使用完毕后立即清零，关键字包括password、psw、pwd、passwd",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "226"
    },
    {
        "规则名称": "WordsTool.31 Build Variant",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.22 AudioState",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.AST.03 禁止用断言检测程序在运行期间可能导致的错误，可能发生的错误要用错误处理代码来处理【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：用断言检测程序在运行期间可能导致的错误。\r\n- 修复示例：可能发生的错误且必须处理的情况要用错误处理代码来处理。\r\n\r\n```c\r\nFILE *fp = fopen(path, \"r\");\r\nif (fp == NULL) {   // 符合\r\n    ... // 错误处理\r\n}\r\n\r\nchar *str = (char *)malloc(MAX_LINE);\r\nif (str == NULL) {   // 符合\r\n    ... // 错误处理\r\n}\r\n\r\nReadLine(fp, str);\r\nchar *p = strstr(str, \"age=\");\r\nif (p == NULL) {   // 符合\r\n    ... // 错误处理\r\n}\r\n\r\nchar *end = NULL;\r\nlong age = strtol(p + 4, &end, 10);\r\nif (age <= 0) {   // 符合\r\n    ... // 错误处理\r\n}\r\n```",
        "错误示例": "##### 场景1：用断言检测程序在运行期间可能导致的错误。\r\n- 错误示例：\r\n\r\n```c\r\nFILE *fp = fopen(path, \"r\");\r\nASSERT(fp != NULL);  // 不符合：文件有可能打开失败\r\n\r\nchar *str = (char *)malloc(MAX_LINE);\r\nASSERT(str != NULL); // 不符合：内存有可能分配失败\r\n\r\nReadLine(fp, str);\r\nchar *p = strstr(str, \"age=\");\r\nASSERT(p != NULL);   // 不符合：文件中不一定存在该字符串\r\n\r\nchar *end = NULL;\r\nlong age = strtol(p + 4, &end, 10);\r\nASSERT(age > 0);     // 不符合：文件内容不一定符合预期\r\n```",
        "修改建议": "不要在发布版本上使用assert检查程序运行过程中发生的错误。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "617"
    },
    {
        "规则名称": "WordsTool.211 快应用 ",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "查不同分支分别调用了危险函数和对应的安全函数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\n// good\nvoid test_good1(int a, char *deststr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    } else {\n        snprintf_s(deststr, 100, \"%s\", \"ccc\");\n    }\n}\n\n// good\nvoid test_good2(int a, char *deststr, char *srcstr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    } else {\n        memcpy(deststr, srcstr, 10);\n    }\n}\n\n// good\nvoid test_good3(int a, char *deststr, char *srcstr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    } else {\n        memcpy(deststr, srcstr, 10);\n    }\n\n    if (a > 10) {\n        memcpy_s(deststr, 10, srcstr, 10);\n    } else {\n        snprintf(deststr, \"%s\", \"ych\");\n    }\n}\n\n// good\nvoid test_good4(int a, char *deststr, char *srcstr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n        if (b > 2) {\n            memcpy(deststr, srcstr, 10);\n        } else {\n            snprintf(deststr, \"%s\", \"ych\");\n        }\n    }\n}\n\nint main()\n{\n    return 0;\n}\n\n```",
        "错误示例": "```C\n#include <stdio.h>\n\nvoid test_bad1(int a, char *srcstr)\n{\n    char *deststr;\n    if (a > 10) {\n        memcpy(deststr, srcstr, 10);\n        memcpy_s(deststr, 10, srcstr, 10);\n    } else {\n        /* if分支中使用了危险函数 */\n        memcpy_s(deststr, 10, srcstr, 10); // error\n        memcpy(deststr, srcstr, 10);\n    }\n}\n\nvoid test_bad2(int a, char *deststr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    } else {\n        /* if分支中使用了危险函数 */\n        snprintf(deststr, 100, \"%s\", \"ych\"); // error\n    }\n}\n\nvoid test_bad3(int a, char *deststr)\n{\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    }\n\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n    } else {\n        /* if分支中使用了危险函数 */\n        snprintf(deststr, 100, \"%s\", \"ych\"); // error\n    }\n}\n\n// error\nvoid test_bad4(int a, int b, char *deststr, char *srcstr)\n{\n    // int b =0;\n    if (a > 10) {\n        snprintf_s(deststr, 100, \"%s\", \"ych\");\n        if (b > 2) {\n            memcpy(deststr, srcstr, 10);\n        } else {\n            /* if分支中使用了危险函数 */\n            memcpy_s(deststr, 10, srcstr, 10); // error\n        }\n    } else {\n        /* if分支中使用了安全函数 */\n        snprintf(deststr, \"%s\", \"ych\");\n    }\n}\n\ntypedef int (*PFUNC_MEMCPY)(void *dest, size_t destMax, const void *src, size_t count);\n\n// error\nvoid test_bad5(PFUNC_MEMCPY a, char *deststr)\n{\n    if (a == NULL) {\n        snprintf(deststr, 100, \"%s\", \"ych\");\n    } else if (a == snprintf_s) {\n        /* if分支中使用了危险函数 */\n        snprintf_s(deststr, 100, \"%s\", \"ccc\"); // error\n        memcpy_s(deststr, 10, srcstr, 10);\n    } else if (b == 1) {\n        /* 分支 c == 2 使用了安全函数 */\n        memcpy(deststr, srcstr, 10); // error\n    } else if (c == 2) {\n        /* 分支 b == 1 使用了危险函数 */\n        memcpy_s(deststr, 10, srcstr, 10); // error\n    } else {\n        /* 分支 a == snprintf_s使用了危险函数 */\n        snprintf(deststr, 100, \"%s\", \"ych\");\n    }\n}\n\n// error\nvoid test_bad6(int a, int b, char *deststr, char *srcstr)\n{\n    if (a > 0) {\n        for (int i = 0; i < 10; i++) {\n            memcpy_s(deststr, 10, srcstr, 10);\n        }\n    } else {\n        /* 分支if 中使用了安全函数 */\n        b = memcpy(deststr, srcstr, 10);\n    }\n}\n\n```",
        "修改建议": "不同分支禁止同时调用危险函数和对应的安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "242"
    },
    {
        "规则名称": "WordsTool.237 尖端",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.175 Stagefright",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "弱加密算法",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "使用了不安全的随机算法MD5、EVP_sha、xx_ecb、RSA_padding_add_XXX\n```C\nvoid weakEncryption_bad_01()\n{\n    char* ptr = xy_DES_C;\n    // POTENTIAL FLAW:Insecure algorithm 'MD5' is called. It is recommended to use strong encryption algorithm.\n    MD5(A, B, C);\n    // POTENTIAL FLAW:Insecure algorithm 'EVP_sha' is called. It is recommended to use strong encryption algorithm.\n    EVP_sha(xy_DES_C, y, z);\n    // POTENTIAL FLAW:Insecure algorithm 'xx_ecb' is called. It is recommended to use strong encryption algorithm.\n    xx_ecb(a, b, c);\n    // POTENTIAL FLAW:Insecure algorithm 'RSA_padding_add_XXX' is called. It is recommended to use strong encryption\n    // algorithm.\n    RSA_padding_add_XXX(ptr, ptr);\n}\n```",
        "修改建议": "使用安全的加密函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1240"
    },
    {
        "规则名称": "WordsTool.98 HIDL",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.178 systrace",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.218 最佳",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.93 GMS",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.13 apk",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.267 绝无仅有",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.242 极致",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.245 超薄",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.235 顶级",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FIL.03 不要在共享目录中创建临时文件",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```\nLinux下的/tmp目录是一个所有用户都可以访问的共享目录，不应在该目录下创建仅由程序自身使用的临时文件。\n```",
        "错误示例": "如下代码示例，程序在Linux系统的共享目录/tmp下创建临时文件来保存临时数据，且文件名是硬编码的。\n\n由于文件名是硬编码的，因此是可预测的，攻击者只需用符号链接替换文件，然后链接所引用的目标文件就会被打开并写入新内容。\n```C\nvoid ProcData(const char *filename)\n{\n  FILE *fp = fopen(filename, \"wb+\");\n  if (fp == NULL) {\n   ... // 错误处理\n }\n  ... // 写文件\n  fclose(fp);\n}\nint main(void)\n{\n  // 不符合：1.在系统共享目录中创建临时文件；2.临时文件名硬编码\n  char *pFile = \"/tmp/data\";\n ...\n  ProcData(pFile);\n ...\n  return 0;\n}\n```",
        "修改建议": "不要在共享目录中创建临时文件。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "379"
    },
    {
        "规则名称": "WordsTool.doc1",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "敏感词配置:鸿蒙,HarmonyOS,首个,卓越,杰出,优秀,之星,我,他,你,L0,L1,宗教,党,黑人,人脸识别,个人信息,认证,国家项目,国产,自主可控,纯自研,信创",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.246 首个",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.106 InCallService",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.307 末日",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.8 无README",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.56 CTCarrier",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.102IIccPhoneBook",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ERR.04-CPP 多个catch子句，前者不能隐藏后者",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：catch的顺序不正确，使得某些catch子句被隐藏。\r\n- 修复示例：调整顺序，以便精确地处理各种异常.\r\n\r\n```cpp\r\ntry {\r\n    DoSomething()\r\n} catch (const BarException& e) {       // 符合：先捕获派生类\r\n    ...\r\n} catch (const FooException& e) {       // 符合：后捕获基类\r\n    ...\r\n} catch (const SomeOtherException& e) {\r\n    ...\r\n} catch (...) {                         // 符合：最后是catch(...)\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：catch的顺序不正确，使得某些catch子句被隐藏。\r\n- 错误示例：\r\n\r\n```cpp\r\nclass FooException : public std::exception {\r\n    ...\r\n};\r\nclass BarException : public FooException {\r\n    ...\r\n};\r\nclass SomeOtherException : public std::exception {\r\n    ...\r\n};\r\n\r\ntry {\r\n    DoSomething()\r\n} catch (const FooException& e) {       // 不符合：使用基类会捕获所有的BarException\r\n    ...\r\n} catch (const BarException& e) {       // 这个子句永远不会被执行到\r\n    ...\r\n} catch (...) {                         // 不符合：这里会捕获所有的异常\r\n    ...\r\n} catch (const SomeOtherException& e) { // 这个子句也永远不会被执行到\r\n    ...\r\n}\r\n```",
        "修改建议": "1. catch先捕获派生类，后捕获基类。\r\n2. catch (...)放最后。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "544,754"
    },
    {
        "规则名称": "G.INC.09-CPP 头文件中禁止向全局命名空间中导入符号",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在头文件中的全局命名空间中导入命名空间\r\n- 修复示例1：\r\n\r\n```cpp\r\n// foo.h\r\nnamespace NS1 {\r\nvoid NsCall();\r\n...\r\n}\r\n\r\nnamespace Foo {\r\nvoid Foo()\r\n{\r\n    ...\r\n    NS1::NsCall(); // 符合：不导入命名空间或符号，通过命名空间的名称访问\r\n    ...\r\n}\r\n}\r\n```\r\n##### 场景2：在头文件中的全局命名空间中导入单个符号\r\n- 修复示例1：\r\n\r\n```cpp\r\n// foo.h\r\nnamespace NS1 {\r\nvoid NsCall();\r\n...\r\n}\r\n\r\nnamespace Foo {\r\nvoid Foo()\r\n{\r\n    ...\r\n    NS1::NsCall(); // 符合：不导入命名空间或符号，通过命名空间的名称访问\r\n    ...\r\n}\r\n}\r\n```",
        "错误示例": "##### 场景1：在头文件中的全局命名空间中导入命名空间\r\n- 错误示例：\r\n\r\n```cpp\r\n// foo.h\r\nnamespace NS1 {\r\nvoid NsCall();\r\n...\r\n}\r\n\r\nusing namespace NS1; // 不符合：向全局命名空间导入命名空间\r\n\r\nnamespace Foo {\r\nvoid Foo()\r\n{\r\n    ...\r\n    NsCall();\r\n    ...\r\n}\r\n}\r\n```\r\n##### 场景2：在头文件中的全局命名空间中导入单个符号\r\n- 错误示例：\r\n\r\n```cpp\r\n// foo.h\r\nnamespace NS1 {\r\nvoid NsCall();\r\n...\r\n}\r\n\r\nusing NS1::NsCall; // 不符合：向全局命名空间导入单个符号\r\n\r\nnamespace Foo {\r\nvoid Foo()\r\n{\r\n    ...\r\n    NsCall();\r\n    ...\r\n}\r\n}\r\n```",
        "修改建议": "1. 不要向头文件的全局命名空间导入命名空间，例如`using namespace xx;`。\r\n2. 不要向头文件的全局命名空间导入单个符号，例如`using xx::yy;`。\r\n3. 可以在局部作用域（例如类、函数、自定义命名空间等）中导入命名空间或单个符号。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.159 PSI",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.86 eventlog",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐--函数声明参数换行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数声明时参数列表换行时未缩进对齐\r\n- 修复示例1：\r\n\r\n```cpp\r\nVOS_UINT32 Download(VOS_UINT32 type, VOS_CHAR *pData,\r\n    VOS_UINT32 dataLen, VOS_UINT32 dataNum) // 符合：相对上一行缩进4空格\r\n```\r\n\r\n- 修复示例2：\r\n\r\n```cpp\r\nVOS_UINT32 Download(VOS_UINT32 type, VOS_CHAR *pData,\r\n                    VOS_UINT32 dataLen, VOS_UINT32 dataNum) // 符合：与上方参数对齐\r\n```",
        "错误示例": "##### 场景1：函数声明时参数列表换行时未缩进对齐\r\n- 错误示例：\r\n\r\n```cpp\r\nVOS_UINT32 Download(VOS_UINT32 type, VOS_CHAR *pData,\r\n VOS_UINT32 dataLen, VOS_UINT32 dataNum) // 不符合：换行时没有缩进对齐\r\n```",
        "修改建议": "按要求进行对齐。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.FUU.12 正确设置安全函数中的destMax参数--检查destMax参数是否设置正确【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：destMax参数是魔鬼数字。\r\n- 修复示例：destMax参数不能是魔鬼数字，destMax参数应设置为destBuff操作范围的内存大小。\r\n\r\n```c\r\n#define BUFF_SIZE 100\r\n\r\nchar *src = ...\r\nsize_t srcLen = ...\r\nerrno_t ret;\r\n...\r\n\r\nchar destBuff1[BUFF_SIZE];\r\nret = memcpy_s(destBuff1, BUFF_SIZE, src, srcLen);          // 符合\r\nret = memcpy_s(destBuff1, sizeof(destBuff1), src, srcLen);  // 符合\r\n\r\nunsigned char *destBuff2 = (unsigned char *)malloc(BUFF_SIZE);\r\n...\r\nret = memcpy_s(destBuff2, BUFF_SIZE, src, srcLen);          // 符合\r\n```\r\n##### 场景2：destBuff是动态分配的内存指针时，destMax参数设置不正确。\r\n- 修复示例：如果destBuff是动态分配的内存指针，那destMax应设置为分配时的内存大小。\r\n\r\n```c\r\n#define BUFF_SIZE 100\r\n...\r\nunsigned char *destBuff = (unsigned char *)malloc(BUFF_SIZE);\r\nif (destBuff == NULL) {\r\n    ... // 错误处理\r\n}\r\n...\r\nunsigned char *src = ...\r\nsize_t srcLen = ...\r\n\r\nerrno_t ret = memcpy_s(destBuff, BUFF_SIZE, src, srcLen); // 符合\r\n```\r\n##### 场景3：destBuff是struct结构类型的单一对象的地址时，destMax参数设置不正确。\r\n- 修复示例：如果destBuff是struct结构类型的单一对象的地址，那destMax应设置为struct结构类型的内存大小。\r\n\r\n```c\r\ntypedef struct {\r\n    int a;\r\n    int b;\r\n    int c;\r\n} SomeStru;\r\n...\r\nSomeStru destBuff;\r\nunsigned char *src = ...\r\nsize_t srcLen = ...\r\n\r\nerrno_t ret = memcpy_s(&destBuff, sizeof(SomeStru), src, srcLen);  // 符合\r\n```",
        "错误示例": "##### 场景1：destMax参数是魔鬼数字。\r\n- 错误示例：\r\n\r\n```c\r\n#define BUFF_SIZE 100\r\n\r\nchar *src = ...\r\nsize_t srcLen = ...\r\nerrno_t ret;\r\n...\r\n\r\nchar destBuff1[BUFF_SIZE];\r\nret = memcpy_s(destBuff1, 100, src, srcLen);    // 不符合：魔鬼数字100\r\n\r\nunsigned char *destBuff2 = (unsigned char *)malloc(BUFF_SIZE);\r\n...\r\nret = memcpy_s(destBuff2, 100, src, srcLen);    // 不符合：魔鬼数字100\r\n```\r\n##### 场景2：destBuff是动态分配的内存指针时，destMax参数设置不正确。\r\n- 错误示例：\r\n\r\n```c\r\n#define BUFF_SIZE 100\r\n...\r\nunsigned char *destBuff = (unsigned char *)malloc(BUFF_SIZE);\r\nif (destBuff == NULL) {\r\n    ... // 错误处理\r\n}\r\n...\r\nunsigned char *src = ...\r\nsize_t srcLen = ...\r\n\r\nerrno_t ret = memcpy_s(destBuff, srcLen, src, srcLen);    // 不符合：destMax参数是srcLen，和destBuff无关\r\n```\r\n##### 场景3：destBuff是struct结构类型的单一对象的地址时，destMax参数设置不正确。\r\n- 错误示例：\r\n\r\n```c\r\ntypedef struct {\r\n    int a;\r\n    int b;\r\n    int c;\r\n} SomeStru;\r\n...\r\nSomeStru destBuff;\r\nunsigned char *src = ...\r\nsize_t srcLen = ...\r\n\r\nerrno_t ret = memcpy_s(&destBuff, srcLen, src, srcLen); // 不符合：destMax参数是srcLen，和destBuff无关\r\n```",
        "修改建议": "安全函数的destMax参数设置应当准确、有效。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "687"
    },
    {
        "规则名称": "G.PRE.03-CPP #if或#elif预处理指令中的常量表达式的值应为布尔值",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1",
        "正确示例": "```cpp\n#define OLD_VERSION 1000\n#define VERSION 3320\n#define ENABLE_MMX   1    // 定义开关用途的宏\n#define ENABLE_FLOAT 0    // 定义开关用途的宏\n\n#if ENABLE_MMX            // 符合\n...\n#endif\n\n#if ENABLE_FLOAT          // 符合\n...\n#endif\n\n#if defined(VERSION)      // 符合\n...\n#endif\n\n#if VERSION > OLD_VERSION // 符合\n...\n#endif\n```",
        "错误示例": "```cpp\n#define VERSION 3320\n\n#if 3320                  // 不符合\n...\n#endif\n\n#if 0                     // 不符合\n...\n#endif\n\n#if 1                     // 不符合\n...\n#endif\n\n#if VERSION               // 不符合\n...\n#endif\n```",
        "修改建议": "使用defined方法判断是否定义标识符，或者使用数值0或1的开关宏",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "241"
    },
    {
        "规则名称": "WordsTool.305 疫情",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.137 monkytest",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.09 宏定义不应以分号结尾【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：宏定义结尾有分号\r\n- 修复示例：\r\n\r\n```cpp\r\n#define LOOP(count)  for (int i = 0; i < (count); i++) // 符合：删除宏定义结尾分号\r\n\r\nint count = ...;\r\nLOOP(5) {\r\n    puts(\"In a loop\\n\");\r\n}\r\n```",
        "错误示例": "##### 场景1：宏定义结尾有分号\r\n- 错误示例：\r\n\r\n```cpp\r\n#define LOOP(count)  for (int i = 0; i < (count); i++); // 不符合，结尾有分号\r\n\r\nint count = ...;\r\nLOOP(5) { // 宏LOOP定义加分号导致空循环，执行结果不符合预期\r\n    puts(\"In a loop\\n\");\r\n}\r\n```",
        "修改建议": "删除宏定义结尾分号，将是否使用分号的决定权交给宏的使用者。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "152"
    },
    {
        "规则名称": "WordsTool.216 Cursor",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.11-CPP 选择、循环语句使用大括号",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nif (objectIsNotExist) {               // 单行选择语句需要加大括号\n    return CreateNewObject();\n}\n```\n\n```cpp\nfor (int i = 0; i < someRange; i++) { // 单行循环语句需要加大括号\n    DoSomething();\n}\n```\n\n```cpp\nwhile (condition) {}                  // 空循环体需要加大括号\n```",
        "错误示例": "```cpp\nfor (int i = 0; i < someRange; i++)   // 不符合： 应该加上括号\n    DoSomething();\n```\n\n```cpp\nwhile (condition); // 不符合：容易让人误解循环体是 DoSomething() 调用  \nDoSomething();\n\nwhile (condition); // 不符合：容易让人误解分号是while语句中的一部分\n```",
        "修改建议": "对条件或循环语句加大括号",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.100 huawei",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.283 错过就没机会了",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.296 权威",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.269 永恒",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.9 三方软件版本",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.17 禁止外部可控数据作为dlopen/LoadLibrary等模块加载函数的参数【C】",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "在下面的代码中，使用C++17提供的文件复制功能来复制文件，避免了调用cp或cat命令。请注意，以下代码仅供参考。 \r\n\r\n```C\r\nbool WriteDataToFile(const std::string& dstFilePath, const std::string& srcFilePath)\r\n{\r\n  std::error_code errorCode;\r\n  bool success = std::filesystem::copy_file(srcFilePath, dstFilePath, errorCode);\r\n  if (!success) {\r\n   ... // Handle the error.\r\n }\r\n  return success;\r\n}\r\n```\r\n\r\n如果需要调用单个命令，请使用exec（）*函数进行参数化调用，并对调用的命令执行白名单管理。此外，请避免使用execlp（）、execvp（）和execvpe（）函数，因为这些函数依赖于外部PATH环境变量。在这种情况下，外部输入的fileName仅用作some_tool命令的参数，不存在命令注入风险。 \r\n\r\n```C\r\npid_t pid;\r\nchar* const envp[] = {nullptr};\r\n...\r\nstd::string fileName = GetDirNameFromRemote();\r\n...\r\npid = fork();\r\nif (pid < 0) {\r\n  ... // Handle the error.\r\n} else if (pid == 0) {\r\n  // Use some_tool to process the specified file.\r\n  execle(\"/bin/some_tool\", \"some_tool\", fileName.c_str(), nullptr, envp);\r\n  _Exit(-1);\r\n}\r\n...\r\n```\r\n\r\n如果需要使用系统命令解析器（如系统）来执行命令，则必须根据适当的白名单检查输入的命令字符串，以防止命令注入。\r\n\r\n```C\r\nstd::string cmd = GetCmdFromRemote();\r\n\r\n// Use the whitelist to check whether the command is valid. Only the some_tool_a and some_tool_b commands are allowed, which cannot be controlled by external systems\r\nif (!IsValidCmd(cmd.c_str())) {\r\n   ... // Handle the error.\r\n}\r\nsystem(cmd.c_str());\r\n...\r\n```",
        "错误示例": "以下代码从外部获取数据后直接作为LoadLibrary函数的参数，有可能导致程序被植入木马。\n\n```C\nchar *msg = GetMsgFromRemote();\nLoadLibrary(msg);\n```",
        "修改建议": "优先考虑使用C标准函数实现需要的功能。如果确实需要使用这些函数，请使用白名单机制确保这些函数的参数不受任何外来数据的影响",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "78"
    },
    {
        "规则名称": "WordsTool.code1",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "敏感词配置:",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.03-CPP 使用统一的大括号换行风格",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "StyleOfBrace:K&R;c_coding_standard_v5.0:true",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "使用相应的大括号换行风格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.64 CXProvider",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.09-CPP 构造函数初始化列表放在同一行或按4空格缩进并排多行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：初始化列表换行时格式错误\r\n- 修复示例1：\r\n\r\n```cpp\r\n// 符合：如果所有变量能放在同一行:\r\nSomeClass::SomeClass(int var) : someVar(var)\r\n{\r\n    DoSomething();\r\n}\r\n```\r\n- 修复示例2：\r\n\r\n```cpp\r\n// 符合：如果需要换行, 将冒号放置新行, 并缩进4个空格\r\nSomeClass::SomeClass(int var)\r\n    : someVar(var), someOtherVar(var + 1)\r\n{\r\n    DoSomething();\r\n}\r\n```\r\n- 修复示例3：\r\n\r\n```cpp\r\n// 符合：如果初始化列表需要多行, 需要逐行对齐\r\nSomeClass::SomeClass(int var)\r\n    : someVar(var),           // 缩进4个空格\r\n      someOtherVar(var + 1)   // 与上一行的成员变量对齐\r\n{  \r\n    DoSomething();\r\n}\r\n```",
        "错误示例": "##### 场景1：初始化列表换行时格式错误\r\n- 错误示例1：\r\n\r\n```cpp\r\nSomeClass::SomeClass(int var) : // 不符合：冒号没有换行\r\n    someVar(var)\r\n{\r\n    DoSomething();\r\n}\r\n```\r\n\r\n- 错误示例2：\r\n\r\n```cpp\r\nSomeClass::SomeClass(int var)\r\n    : someVar(var),\r\n    someOtherVar(var + 1)   // 不符合：没有与上一行的成员变量对齐\r\n{\r\n    DoSomething();\r\n}\r\n```",
        "修改建议": "构造函数初始化列表放在同一行，如果需要换行，则将冒号放置新行，首行缩进4空格，其余多行与首行的成员变量对齐缩进。\r\n请参考如下修复示例。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "G.FUU.04 禁用atexit函数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "重构代码，禁止使用atexit()函数\n```C\n...\nvoid ProcessExit(void)\n{\n    if (g_someResource == 0) {\n       ... // g_someResource，在这里清理程序资源，代码省略\n    }\n    return;\n}\nint main(void)\n{\n    // main函数退出\n    ProcessExit(); // 符合：主动调用资源清理函数\n    return 0;\n}\n```",
        "错误示例": "在如下代码示例中，ProcessExit()函数由atexit()事先注册，在程序终止时执行必要的资源清理操作。但是如果g_someResource条件为真，则exit()被第二次调用，造成程序产生未定义行为。\n```C\n...\nint g_someResource = 1;\nvoid ProcessExit(void)\n{\n    if (g_someResource == 0) {\n       ... // g_someResource，在这里清理程序资源，代码省略\n       exit(0); // 不符合：在本例程中调用exit，导致程序产生未定义行为\n    }\n    return;\n}\nint main(void)\n{\n    // 不符合：注册atexit()例程ProcessExit()，清理资源\n    if (atexit(ProcessExit) != 0) {\n        ... // 错误处理\n    }\n    ...\n    // main函数退出\n    return 0;\n}\n```",
        "修改建议": "禁止调用atexit函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.CTL.08 switch语句中至少有两个条件分支【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：switch中条件少于两个\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo(int x, int y)\r\n{\r\n    if (x == 1) { // 符合\r\n        y++;\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：switch中条件少于两个\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(int x, int y)\r\n{\r\n    switch (x) { // 不符合，只有一个case语句\r\n        case 1:\r\n            y++;\r\n            break;\r\n    }\r\n}\r\n```",
        "修改建议": "修改为if语句",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.STD.13-CPP 调用格式化输入/输出函数时，使用有效的格式字符串",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，使用%hhx确保格式串与相应的实参类型严格匹配。\n```c\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%hhx:%hhx:%hhx:%hhx:%hhx:%hhx\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...\n```\n注：在C++中不推荐使用sscanf, sprintf等C库函数，可以替换为：std::istringstream, std::ostringstream, std::stringstream等。",
        "错误示例": "如下代码中，格式化输入一个整数到macAddr变量中，但是macAddr为unsigned char类型，而%x对应的是unsigned int类型参数，函数执行完成后会发生写越界。\n```C\nunsigned char macAddr[6];\n...\n// macStr中的数据格式为 e2:42:a4:52:1e:33\nint ret = sscanf_s(macStr, \"%x:%x:%x:%x:%x:%x\\n\",\n                  &macAddr[0], &macAddr[1],\n                  &macAddr[2], &macAddr[3],\n                  &macAddr[4], &macAddr[5]);\n...\n```",
        "修改建议": "确保format函数参数个数和实际参数个数一致。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "628"
    },
    {
        "规则名称": "WordsTool.16 ARCore_stub",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.286 疯抢",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.209 WEEX",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.47 Codec2",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.265 前所未有",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.313 洪水",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.06-CPP 换行时将操作符留在行末，新行缩进一层或进行同类对齐--函数调用参数换行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "c_coding_standard_v5.0:true",
        "正确示例": "##### 场景1：函数调用参数列表换行时未缩进对齐\r\n- 修复示例1：\r\n\r\n```cpp\r\nvoid Fun(int ret)\r\n{\r\n    WriteLog(FWM_ETH_LOG_ERROR, FWM_ETH_CATEGORY_DEFAULT, FWM_ETH_MID_VLAN,\r\n        \"[DOWNLOAD] ret:%u\", ret); // 符合：相对上一行缩进4空格\r\n}\r\n```\r\n\r\n- 修复示例2：\r\n\r\n```cpp\r\nvoid Fun(int ret)\r\n{\r\n    WriteLog(FWM_ETH_LOG_ERROR, FWM_ETH_CATEGORY_DEFAULT, FWM_ETH_MID_VLAN,\r\n             \"[DOWNLOAD] ret:%u\", ret); // 符合：与上方参数对齐\r\n}\r\n```",
        "错误示例": "##### 场景1：函数调用参数列表换行时未缩进对齐\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Fun(int ret)\r\n{\r\n    WriteLog(FWM_ETH_LOG_ERROR, FWM_ETH_CATEGORY_DEFAULT, FWM_ETH_MID_VLAN,\r\n         \"[DOWNLOAD] ret:%u\", ret); // 不符合：换行时缩进5空格\r\n}\r\n```",
        "修改建议": "按要求进行对齐。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.FUU.15 只能使用华为安全函数库中的安全函数或经华为认可的其他安全函数--检查用户自定义类安全函数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "在下面的拷贝安全函数实现中，由于不恰当的进行了类转换，因此缺乏在64位系统上的可移植性，同时，该函数的返回值也不兼容C11标准中的安全拷贝函数memcpy_s。\n```C\n#define SECUREC_MEM_MAX_LEN (0x7fffffffUL)\nvoid MemcpySafe(void *dest, unsigned int destMax, const void *src, unsigned int count)\n{\n  if (destMax == 0 || destMax > SECUREC_MEM_MAX_LEN ) {\n    return;\n }\n  if (dest == NULL || src == NULL) {\n    return;\n }\n  if (count > destMax) {\n    return;\n }\n  if (dest == src) {\n    return;\n }\n  if (((uint32_t)dest > (uint32_t)src &&\n    (uint32_t)dest < (uint32_t)(void *)((uint8_t *)src + count)) ||\n   ((uint32_t)src > (uint32_t)dest &&\n    (uint32_t)src < (uint32_t)(void *)((uint8_t *)dest + count))) {\n    return;\n }\n  memcpy(dest, src, count);\n}\n```",
        "修改建议": "不要自定义安全函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.INC.08 禁止在 extern \"C\" 中包含头文件【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：extern \"C\"中包含头文件\r\n- 修复示例：\r\n\r\n```cpp\r\n// a.h的内容\r\n...\r\n#ifdef __cplusplus\r\nvoid Foo(int);\r\n#define A(value) Foo(value)\r\n#else\r\nvoid A(int);\r\n#endif\r\n\r\n// b.h的内容\r\n...\r\n#include \"a.h\" // 符合\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\nvoid B(void);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n```",
        "错误示例": "##### 场景1：extern \"C\"中包含头文件\r\n- 错误示例：\r\n\r\n```cpp\r\n// a.h的内容\r\n...\r\n#ifdef __cplusplus\r\nvoid Foo(int);\r\n#define A(value) Foo(value)\r\n#else\r\nvoid A(int);\r\n#endif\r\n\r\n// b.h的内容\r\n...\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#include \"a.h\" // 不符合\r\nvoid B(void);\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n```",
        "修改建议": "修改include位置，不要在extern \"C\"中include头文件。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.FUU.08 禁用abort函数【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：调用abort()函数\r\n- 修复示例1：当异常发生后，不调用abort()，处理错误后，通过函数返回的错误值告知上游运行异常，逐层处理异常，最后在main函数正常退出。\r\n\r\n```c\r\nint32_t TestGoodCase01()\r\n{\r\n    int32_t age;\r\n    scanf(\"%d\", &age);\r\n\r\n    // 外部输入数据不合法\r\n    if (age < 0 || age > 150) {\r\n        ... // 错误处理\r\n        // 符合：用返回值逐层退出并处理错误\r\n        return -1;\r\n    }\r\n\r\n    ...\r\n    return 0;\r\n}\r\n```\r\n- 修复示例2：只有发生致命错误，程序无法继续执行的时候，在错误处理函数中使用abort退出程序。但必须在模型中配置错误处理函数的名称，详见下方的[模型/参数配置]。\r\n\r\n```c\r\nvoid FatalError(int sig)\r\n{\r\n    ... // 错误处理\r\n    // 必须在模型中，将FatalError函数配置成程序无法继续执行时的错误处理函数\r\n    abort();\r\n}\r\n\r\nint32_t TestGoodCase02()\r\n{\r\n    int32_t age;\r\n    scanf(\"%d\", &age);\r\n    ...\r\n    signal(SIGSEGV, FatalError);\r\n    ...\r\n    return 0;\r\n}\r\n```",
        "错误示例": "##### 场景1：调用abort()函数\r\n- 错误示例：\r\n\r\n```c\r\nint32_t TestBadCase01()\r\n{\r\n    int32_t age;\r\n    scanf(\"%d\", &age);\r\n\r\n    // 外部输入数据不合法\r\n    if (age < 0 || age > 150) {\r\n        // 不符合：禁止在非错误处理函数中，调用abort函数\r\n        abort();\r\n    }\r\n\r\n    ...\r\n    return 0;\r\n}\r\n```",
        "修改建议": "禁用abort函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.12 AOSP",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.40 CarPackageManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.37-CPP switch语句要有default分支--default不是最后一个分支",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：default分支没有放在switch语句块的最后位置\r\n- 修复示例：\r\n\r\n```cpp\r\nswitch (paraName) {\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n    default: // 符合：default分支放在switch语句块的最后位置\r\n        break;\r\n}\r\n```",
        "错误示例": "##### 场景1：default分支没有放在switch语句块的最后位置\r\n- 错误示例：\r\n\r\n```cpp\r\nswitch (paraName) {\r\n    default: // 不符合\r\n        break;\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n}\r\n```",
        "修改建议": "添加default分支，或者将default分支移到最后",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "478"
    },
    {
        "规则名称": "WordsTool.168 simpleperf",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.STD.16-CPP 禁用程序与线程的退出函数和atexit函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "正确的做法可以通过错误值传递机制返回上一层调用者。\n```C\n...\nbool LoadFile(const std::string& fileName)\n{\n  std::ifstream file(fileName);\n  if (file.fail()) {\n    ... // 错误处理\n    return false;\n  }\n  ...\n  return true;\n}\n```",
        "错误示例": "如下代码中，在文件加载过程中如果出错，直接调用exit退出，可能会造成调用者申请的资源未被清理。\n```C\nvoid LoadFile(const std::string& fileName)\n{\n  std::ifstream file(fileName);\n  if (file.fail()) {\n    exit(0); // 不符合\n  }\n  ...\n}\n```",
        "修改建议": "禁止调用atexit函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "G.INC.08-CPP 不要在#include之前使用using导入namespace",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在#include之前使用using namespace\r\n- 修复示例1：\r\n\r\n```cpp\r\n// foo.cpp\r\n#include \"foo.h\"\r\n\r\nvoid Foo()\r\n{\r\n    ...\r\n    std::cout << \"Foo\"; // 符合：使用std::方式\r\n    ...\r\n}\r\n```\r\n- 修复示例2：\r\n\r\n```cpp\r\n// foo.cpp\r\n#include \"foo.h\"\r\nusing std::cout; // 符合：只引入特定符号\r\n\r\nvoid Foo()\r\n{\r\n    ...\r\n    cout << \"Foo\";\r\n    ...\r\n}\r\n```\r\n- 修复示例3：\r\n\r\n```cpp\r\n// foo.cpp\r\n#include \"foo.h\"\r\nusing namespace std; // 符合\r\n\r\nvoid Foo()\r\n{\r\n    ...\r\n    cout << \"Foo\";\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：在#include之前使用using namespace\r\n- 错误示例：\r\n\r\n```cpp\r\n// foo.cpp\r\nusing namespace std; // 不符合\r\n#include \"foo.h\"\r\n\r\nvoid Foo()\r\n{\r\n    ...\r\n    cout << \"Foo\";\r\n    ...\r\n}\r\n```",
        "修改建议": "不要在#include之前使用`using namespace`。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.FUD.05 函数要简短--函数参数个数【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数的参数个数超过5个\r\n- 修复示例1：\r\n\r\n```cpp\r\nclass PersonInfo {\r\n    ...\r\n    char *name;\r\n    uint8_t age;\r\n    char *gender;\r\n    char *address;\r\n    char *phone;\r\n    char *email;\r\n};\r\n\r\n// 符合\r\nvoid ProtectInfo(const PersonInfo *info)\r\n{\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：函数的参数个数超过5个\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：函数参数过多\r\nvoid ProtectInfo(char *name, int age, char *gender, char *address, char *phone, char *email)\r\n{\r\n    ...\r\n}\r\n```",
        "修改建议": "函数的参数个数不应超过5个，修改方法参考如下：\r\n\r\n1. 使用结构体：将多个参数封装成一个结构体，作为函数的参数传递。\r\n\r\n2. 重构函数：如果函数参数过多，可能意味着函数功能过于复杂，可以考虑将函数拆分成多个小函数，每个函数只处理部分参数，使函数更加简单易懂。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1064,1080,1124"
    },
    {
        "规则名称": "WordsTool.162 react native",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.163 Reko",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.145 NinePatchChunk   ",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.39 CarInfoManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.49 ConnectionRequest",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.133 Mediametrics",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.295 全金属机身",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.02-CPP 使用函数代替函数式宏",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "将函数式宏修改为函数。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.287 限时限量",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.RES.09-CPP 使用std::make_unique 而不是new 创建std::unique_ptr",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用new创建std::unique_ptr\r\n- 修复示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    std::unique_ptr<int> p1 = std::make_unique<int>(); // 符合\r\n}\r\n\r\nstd::unique_ptr<Base> GetPointer()\r\n{\r\n    return std::make_unique<Base>(); // 符合\r\n}\r\n```",
        "错误示例": "##### 场景1：使用new创建std::unique_ptr\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo()\r\n{\r\n    std::unique_ptr<int> p1 = std::unique_ptr<int>(new int()); // 不符合\r\n}\r\n\r\nstd::unique_ptr<Base> GetPointer()\r\n{\r\n    return std::unique_ptr<Base>(new Base); // 不符合\r\n}\r\n```",
        "修改建议": "使用`make_unique`创建`unique_ptr` 。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.PRE.10 宏定义不应依赖宏外部的局部变量名",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```c\n#define INIT(x) ((x)->y->length)\n\n...\nint count = INIT(msg);\n```",
        "错误示例": "```c\n#define INIT(x) do { \\\n    count = (x)->y->length; \\\n} while (0)\n\n...\nint count;\nINIT(msg);\n```",
        "修改建议": "将需要引用的局部变量作为参数传递进来",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "WordsTool.167 Shell.APK",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.243 至薄",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.116 Java Decompiler",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CNS.02 不要使用难以理解的字面量【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：使用整型字面量，无法明确业务含义\r\n- 修复示例：使用能表达含义的宏或常量。\r\n\r\n```cpp\r\nenum class ServType {\r\n    SERV_TYPE_RESERVED,\r\n    SERV_TYPE_SET,\r\n    SERV_TYPE_QUERY,\r\n    ...\r\n};\r\n\r\n...\r\nServType currentType = psInParam->GetValue(\"servType\");\r\nif (currentType == ServType::SERV_TYPE_SET) { // 符合\r\n    ...\r\n} else if (currentType == ServType::SERV_TYPE_QUERY) { // 符合\r\n    ...\r\n} else {\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：使用整型字面量，无法明确业务含义\r\n- 错误示例：\r\n\r\n```cpp\r\nint currentType = psInParam->GetValue(\"servType\");\r\n\r\nif (currentType == 1) { // 不符合\r\n    ...\r\n} else if (currentType == 2) { // 不符合\r\n    ...\r\n} else {\r\n    ...\r\n}\r\n```",
        "修改建议": " - 如果某个字面量经常使用到，在使用的上下文中具有固定的含义，应该定义为宏或常量\r\n- 宏或常量的命名应是自注释的，不能自注释的，必要时可以添加注释加以说明。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "G.FMT.07 函数的返回类型及修饰符与函数名同行【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数返回值类型和函数名不同行\r\n- 修复示例：\r\n\r\n```cpp\r\nstatic inline int ShortFunc(int a, int b);         // 符合\r\n\r\nstatic inline int LongFuncName(int longParamName1, // 符合\r\n                               int longParamName2,\r\n                               int longParamName3,\r\n                               int longParamName4);\r\n```",
        "错误示例": "##### 场景1：函数返回值类型和函数名不同行\r\n- 错误示例：\r\n\r\n```cpp\r\nstatic inline int\r\nShortFunc(int a, int b);         // 不符合\r\n\r\nstatic inline int\r\nLongFuncName(int longParamName1, // 不符合\r\n             int longParamName2,\r\n             int longParamName3,\r\n             int longParamName4);\r\n```",
        "修改建议": "函数声明和定义时，将函数的**返回类型**及**修饰符**和**函数名**放在同一行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.186 Treble",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.293 全新",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CNS.02-CPP 不要使用难以理解的字面量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，使用了能表达含义的常量。\n\n```cpp\nconstexpr int SERV_TYPE_SET = 1;\nconstexpr int SERV_TYPE_QUERY = 4;\nconstexpr int ADULT_AGE = 18;\n```\n\n```cpp\nint currentType = psInParam->GetValue(\"servType\");\n\nif (currentType == SERV_TYPE_SET) {\n    ...\n} else if (currentType == SERV_TYPE_QUERY) {\n    ...\n} else {\n    ...\n}\n\nif (age >= ADULT_AGE) {\n    ...\n} else {\n    ...\n}\n```",
        "错误示例": "如下代码中，使用了难以理解的字面量。\n\n```cpp\nint currentType = psInParam->GetValue(\"servType\");\n\n// 下面使用的整数字面量，不容易理解其具体含义  \nif (currentType == 1) {\n    ...\n} else if (currentType == 4) {\n    ...\n} else {\n    ...\n}\n\nif (age >= 18) {\n    ...\n} else {\n    ...\n}\n```",
        "修改建议": "对于单点使用的难以理解的常量，按需增加注释说明。对于多处使用的难以理解的常量，应该定义宏或 const 变量，并通过符号命名自注释 。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1099"
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--类型转换",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：类型转换(<>)和类型之间存在空格\r\n- 修复示例1：\r\n```cpp\r\nchar* ch = reinterpret_cast<char*>(s);      // 符合\r\n```\r\n\r\n##### 场景2：被强制转换的变量与类型之间存在空格\r\n- 修复示例1：\r\n```cpp\r\ndouble a = 1.5;\r\nint i = static_cast<int>(a); // 符合：使用由C++提供的类型转换操作，且没有多余空格\r\n```",
        "错误示例": "##### 场景1：类型转换(<>)和类型之间存在空格\r\n- 错误示例：\r\n\r\n```cpp\r\nchar* ch = reinterpret_cast< char* >(s);    // 不符合：<> 中有多余空格\r\n```\r\n\r\n##### 场景2：被强制转换的变量与类型之间存在空格\r\n- 错误示例：\r\n\r\n```cpp\r\ndouble a = 1.5;\r\nint i = (double) a; // 不符合：'(double)'和a之间存在空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.RES.07-CPP 指向资源句柄或描述符的变量，在资源释放后立即赋予新值",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码中，立即对释放后的指针设置为nullptr，避免重复释放指针。\n```C\nint Fun()\n{\n    SomeStruct *msg = ...         // 使用new分配msg、msg->body的内存空间并初始化msg\n    if (msg->type == MESSAGE_A) {\n      ...\n        delete msg->body;\n        msg->body = nullptr;\n    }\n    ...\n    if (!InsertMsgToQueue(msg)) { // 将msg存入全局队列\n        delete msg->body;         // 马上离开作用域，不必赋值 nullptr\n        delete msg;               // 马上离开作用域，不必赋值 nullptr\n        return -1;\n    }\n    return 0;\n}\n\n```\n注：默认的内存释放函数针对空指针不执行任何动作。",
        "错误示例": "如下代码中，根据消息类型处理消息，处理完后释放掉body指向的内存，但是释放后未将指针设置为nullptr。如果还有其他函数再次处理该消息结构体时，可能出现重复释放内存或访问已释放内存的问题。\n```C\nint Fun()\n{\n    SomeStruct *msg = ...         // 使用new分配msg、msg->body的内存空间并初始化msg\n    if (msg->type == MESSAGE_A) {\n      ...\n        delete msg->body;         // 不符合：释放内存后，未置空\n    }\n    ...\n    if (!InsertMsgToQueue(msg)) { // 将msg存入全局队列，后续可能使用已释放的body成员\n        delete msg->body;         // 可能重复释放了body的内存\n        delete msg;\n        return -1;\n    }\n    return 0;\n}\n```",
        "修改建议": "对于局部变量，调用closesocket、free、close、delete等函数释放资源后，需要重新赋值后再继续使用；对于全局变量，释放后在函数结束前需要被重新赋值",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "416"
    },
    {
        "规则名称": "WordsTool.71 DDMS",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.OTH.05 禁止代码中包含公网地址",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "变量赋值中包含公网IP\n```C\nvoid IP_Hard_Coded()\n{\n   /* POTENTIAL FLAW: 禁止使用Ipv4公网IP */\n   const char *data = \"189.179.169.159\";\n   printf(\"%s\", data);\n}\n```",
        "修改建议": "宏定义中、变量赋值中、特定函数（*strcmp、*strncmp、*memcmp）中禁止使用硬编码公网IP",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "547"
    },
    {
        "规则名称": "WordsTool.103 InboundSmsHandler",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.34 canvasViewDidEndUsingTool",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.17-CPP 合理安排空行",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "```cpp\nret = DoSomething();\n\nif (ret != OK) {     // 不符合：返回值判断应该紧跟函数调用  \n    return -1;\n}\n```\n\n如下代码中，Foo与Bar函数体之间的空行多于2个空行\n\n```cpp\nint Foo()\n{\n    ...\n}\n\nint Bar()     \n{\n    ...\n}\n```\n\n如下代码中，函数体内行首和行尾不应该加入空行。\n\n```cpp\nint Foo()\n{\n\n    ...\n\n}\n```\n\n如下代码中，大括号内的代码块行首和行尾不应该加入空行。\n```cpp\nif (...) {\n\n    ...\n\n}\n```",
        "修改建议": "删除多余空行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "OAT.7 无README.OpenSource",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.02 表达式的比较，应当遵循左侧倾向于变化、右侧倾向于不变的原则【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：比较表达式中，将常量放在了左边，不符合阅读习惯\r\n- 修复示例：\r\n\r\n  ```cpp\r\n  if (len < MAX_SIZE) { // 符合\r\n    ...\r\n  }\r\n\r\n  if (len > MIN_SIZE) { // 符合\r\n    ...\r\n  }\r\n  ```",
        "错误示例": "##### 场景1：比较表达式中，将常量放在了左边，不符合阅读习惯\r\n- 错误示例：\r\n\r\n  ```cpp\r\n  if (MAX_SIZE >= len) { // 不符合\r\n    ...\r\n  }\r\n\r\n  if (MIN_SIZE <= len) { // 不符合\r\n    ...\r\n  }\r\n  ```",
        "修改建议": "比较表达式将常量放右边。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.INC.04-CPP 头文件必须采取保护措施，防止重复包含",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "HeaderFileExtensions:h,hh,hpp,hxx,inc,ph;CheckDuplicate:true;ProjectRootPath:",
        "正确示例": "假定VOS工程的timer模块的timer.h，其目录为VOS/include/timer/Timer.h，应按如下方式保护：\r\n\r\n```cpp\r\n#ifndef VOS_INCLUDE_TIMER_TIMER_H\r\n#define VOS_INCLUDE_TIMER_TIMER_H\r\n...\r\n#endif\r\n```\r\n\r\n也可以不用像上面添加路径，但是要保证当前工程内宏是唯一的。\r\n```cpp\r\n#ifndef TIMER_H\r\n#define TIMER_H\r\n...\r\n#endif\r\n```",
        "错误示例": NaN,
        "修改建议": "添加合适的#define保护头文件",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1041"
    },
    {
        "规则名称": "WordsTool.134 Minjava",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FMT.02 使用空格进行缩进，每次缩进4个空格【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：缩进不是四的倍数\r\n- 修复示例：\r\n\r\n```c++\r\nvoid Func()\r\n{\r\n    int num; // 符合，缩进为4\r\n}\r\n```",
        "错误示例": "##### 场景1：缩进不是四的倍数\r\n- 错误示例：\r\n\r\n```c++\r\nvoid Func()\r\n{\r\n int num; // 不符合，缩进为1\r\n}\r\n```",
        "修改建议": "改为缩进 4 个空格。不允许使用Tab键进行缩进。\r\nLinux内核缩进风格与本规则有冲突，请参考《华为Linux内核编程规范》。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "G.FMT.16-CPP 用空格突出关键字和重要信息--函数名",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：函数名后面多空格\r\n- 修复示例：移除函数名后的空格\r\n```cpp\r\nint main(int argc, char **argv);          // 符合\r\n```",
        "错误示例": "##### 场景1：函数名后面多空格\r\n- 错误示例：\r\n\r\n```cpp\r\nint main (int argc, char **argv);          // 不符合：main 和 ( 之间有空格\r\n```",
        "修改建议": "按要求增加/减少空格。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1114"
    },
    {
        "规则名称": "WordsTool.187 Trustlook",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.182 tensorflow",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.45 CarSetting",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.70 DcTracker",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.82 Espresso",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.23 AVD",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.191 Vehicle HAL",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.131 Luyten",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUN.01-CPP 函数功能要单一--函数参数个数",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "CheckCtorParameter:true;ParameterThreshold:5",
        "正确示例": "##### 场景1：函数的参数个数超过5个\r\n- 修复示例1：\r\n```cpp\r\nclass PersonInfo {\r\n    ...\r\n    char *name;\r\n    uint8_t age;\r\n    char *gender;\r\n    char *address;\r\n    char *phone;\r\n    char *email;\r\n};\r\n\r\n// 符合\r\nvoid ProtectInfo(const PersonInfo *info)\r\n{\r\n    ...\r\n}\r\n```",
        "错误示例": "##### 场景1：函数的参数个数超过5个\r\n- 错误示例：\r\n\r\n```cpp\r\n// 不符合：函数参数过多\r\nvoid ProtectInfo(char *name, int age, char *gender, char *address, char *phone, char *email)\r\n{\r\n    ...\r\n}\r\n```",
        "修改建议": "对代码进行重构，减少函数复杂度。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "G.EXP.01-CPP 不要声明或定义保留标识符",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": "```cpp\n#undef __LINE__               // 不符合：__LINE__为保留宏，不允许#undef保留宏\n#define _MODULE_INCLUDE_      // 不符合：下划线加一个大写字母开头  \nenum { SIZE_MAX = 80 };       // 不符合：SIZE_MAX是<cstdint>中保留宏\nint errno;                    // 不符合：errno是标准库中的保留标识符  \nvoid* malloc(size_t nbytes);  // 不符合：malloc是标准库中的保留标识符  \n```\n\n**【例外】**  \n保留的标识符可以由编译器在标准库头文件，或标准库头文件包含的头文件中定义。",
        "修改建议": "修改标识符名称。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1109"
    },
    {
        "规则名称": "G.FMT.08 条件、循环语句使用大括号【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：条件语句没有使用大括号\r\n- 修复示例：\r\n\r\n```cpp\r\nif (condition) {  // 符合：增加大括号\r\n    DoSomethingA();\r\n    DoSomethingB();\r\n}\r\n```\r\n##### 场景2：循环语句没有使用大括号\r\n- 修复示例：\r\n\r\n```cpp\r\nfor (int i = 0; i < someRange; i++) {   // 符合：增加大括号\r\n    DoSomething();\r\n}\r\n\r\nwhile (condition) {   // 符合：增加大括号\r\n    DoSomething();\r\n}\r\n```",
        "错误示例": "##### 场景1：条件语句没有使用大括号\r\n- 错误示例：\r\n\r\n```cpp\r\nif (condition)    // 不符合：没有使用大括号\r\n    DoSomethingA();\r\n    DoSomethingB();\r\n```\r\n##### 场景2：循环语句没有使用大括号\r\n- 错误示例：\r\n\r\n```cpp\r\nfor (int i = 0; i < someRange; i++)     // 不符合：没有使用大括号\r\n    DoSomething();\r\n\r\nwhile (condition);      // 不符合：容易让人误解循环体是 DoSomething() 调用\r\n    DoSomething();\r\n```",
        "修改建议": "请给条件、循环语句增加大括号保护。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1078"
    },
    {
        "规则名称": "WordsTool.251 首发",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.193 VideoProfile",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.241 绝对",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.62 CXCallObserver",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.33-CPP 含有变量自增或自减运算的表达式中禁止再次引用该变量",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "将自增或自减运算单独放一行。\n\n```cpp\nx = b[i] + i;\ni++;            // 符合： 单独一行\n```\n\n```cpp\ni++;            // 符合： 单独一行\nx = Fun(i, i);\n```",
        "错误示例": "```cpp\nx = b[i] + i++; // 不符合： b[i]运算跟 i++，先后顺序并不明确\nFun(i++, i);    // 不符合： 传递第2个参数时，不确定自增运算有没有发生\n```",
        "修改建议": "自增或自减运算提到表达式之外。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "758"
    },
    {
        "规则名称": "WordsTool.272 中国驰名商标",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.OTH.01 删除无效或永不执行的代码【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：return之后的代码永不执行\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合\r\nint Foo() {\r\n    return 0;\r\n}\r\n```\r\n##### 场景2：goto之后的代码永不执行\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合\r\nint Foo(int x, int y)\r\n{\r\n    y++;\r\n    if (x < 10) {\r\n        y++;\r\n        return y;\r\n    }\r\n    return x;\r\n}\r\n```\r\n##### 场景3：无条件的break导致循环只执行一次\r\n- 修复示例：\r\n\r\n```cpp\r\n// 符合\r\nvoid Foo(const char *array, uint32_t len)\r\n{\r\n    for (uint32_t i = 0; i < len; i++) {\r\n        if (array[i] > LEN_MAX) {\r\n            array[i] = 0;\r\n        }\r\n    }\r\n}\r\n```",
        "错误示例": "##### 场景1：return之后的代码永不执行\r\n- 错误示例：\r\n\r\n```cpp\r\nint Foo() {\r\n    return 0;\r\n    Bar(); // 不符合：该行及以下代码永不执行\r\n    return x;\r\n}\r\n```\r\n##### 场景2：goto之后的代码永不执行\r\n- 错误示例：\r\n\r\n```cpp\r\nint Foo(int x, int y)\r\n{\r\n    y++;\r\n    goto out;\r\n    if (x < 10) { // 不符合：该行及以下代码永不执行\r\n        y++;\r\n        return y;\r\n    }\r\nout:\r\n    return x;\r\n}\r\n```\r\n##### 场景3：无条件的break导致循环只执行一次\r\n- 错误示例：\r\n\r\n```cpp\r\nvoid Foo(const char *array, uint32_t len)\r\n{\r\n    for (uint32_t i = 0; i < len; i++) {\r\n        if (array[i] > LEN_MAX) {\r\n            array[i] = 0;\r\n        }\r\n        break; // 不符合：循环只执行一次就退出，循环递增i++没有执行过\r\n    }\r\n}\r\n```",
        "修改建议": "删除无效或永不执行的代码。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "561,1041"
    },
    {
        "规则名称": "WordsTool.53 CreateML",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CMT.05-CPP 正式交付给客户的代码不应包含TODO/TBD/FIXME注释",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "ToDefSelf:TODO|FIXME|TBD;IgnoreCase:false",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": "改进代码或者删除注释。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "546"
    },
    {
        "规则名称": "WordsTool.107 IncomingLine",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "超大头文件[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "新增阈值:500;修改阈值:500",
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "WordsTool.127 LMK",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.297 AA",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.FUU.09 禁止使用realloc()函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "使用malloc()函数代替realloc()函数\n```c\n// 使用malloc()函数代替realloc()函数\nchar *newPtr = (char *)malloc(NEW_SIZE);\nif (newPtr == NULL) {\n  ... // 错误处理\n}\n\nerrno_t ret = memcpy_s(newPtr, NEW_SIZE, oldPtr, oldSize);\n... // 校验ret，确保安全函数执行成功\n\n... // 返回前，释放oldPtr\n```",
        "错误示例": "如下代码示例中，使用realloc不当导致内存泄漏。\n\n代码中希望对ptr的空间进行扩充，当realloc()分配失败的时候，会返回NULL。但是参数中的ptr的内存是没有被释放的，如果直接将realloc()的返回值赋给ptr，那么ptr原来指向的内存就会丢失，造成内存泄漏\n\n```C\n// 当realloc()分配内存失败时会返回NULL，导致内存泄漏\nchar *ptr = (char *)realloc(ptr, NEW_SIZE);\nif (ptr == NULL) {\n  .. // 错误处理\n}\n```",
        "修改建议": "禁止调用realloc函数",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "676"
    },
    {
        "规则名称": "WordsTool.59 CTTelephonyNetworkInfo",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.43 CarSensorManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.239 极佳",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.46 CarVendorExtensionManager",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "可查找对分配程序进行调用，并且在使用-或+运算符时将圆括号位置放错的很多情况",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\nvoid test_good_01(int a, int b)\n{\n\tchar *p1 = (char *)malloc(a + b);\n}\n```",
        "错误示例": "```C\nvoid test(int a, int b, int c)\n{\n    char *p1 = (char *)malloc(a) + b;             // 错误的内存算法，告警\n    char *p2 = (char *)VOS_SimpleAlloc(a, 2) - b; // 错误的内存算法，告警\n    int *p4 = (int *)malloc(a - b) + c;           // 错误的内存算法，告警\n    int *p3 = (int *)malloc(a + b); // good\n}\n```",
        "修改建议": "正确分配内存大小",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "789"
    },
    {
        "规则名称": "G.FUN.01-CPP 函数功能要单一--函数大小",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "函数体代码行数（非空非注释）不超过50行；",
        "错误示例": "函数体代码行数（非空非注释）不超过50行；",
        "修改建议": "对代码进行重构，减少函数复杂度。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    },
    {
        "规则名称": "WordsTool.108 installreferrer",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.ARR.03 禁止通过对指针变量进行sizeof操作来获取数组大小",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "如下代码示例中，将 sizeof(buffer) 修改为申请的缓冲区大小：\n```C\nchar path[MAX_PATH];\nchar *buffer = (char *)malloc(SIZE);\n...\n\n...\nmemset(path, 0, sizeof(path));\nmemset(buffer, 0, SIZE); // 使用申请的缓冲区大小\n```",
        "错误示例": "如下代码示例中，buffer和path分别是指针和数组，程序员想对这2个内存进行清0操作，但由于程序员的疏忽，将内存大小误写成了 sizeof(buffer) ，与预期不符。\n```C\nchar path[MAX_PATH];\nchar *buffer = (char *)malloc(SIZE);\n...\n\n...\nmemset(path, 0, sizeof(path));\n\n// sizeof与预期不符，其结果为指针本身的大小而不是缓冲区大小\nmemset(buffer, 0, sizeof(buffer));\n```",
        "修改建议": "禁止通过对指针变量进行sizeof操作来获取数组大小。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "467"
    },
    {
        "规则名称": "不安全IPSI算法检查",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```C\nvoid UnsafeIpsi_good_01()\n{\n    CRYPT_encrypt(1,1,\"1314\",ALGID_BF_CBC);\n}\n```",
        "错误示例": "```C\r\nvoid UnsafeIpsi_bad_01()\r\n{\r\n    // 潜在缺陷：算法函数CRYPT_encrypt的参数不安全。\r\n    CRYPT_encrypt(ALGID_BF_CBC,1,1,\"1314\");\r\n}\r\n\r\nvoid UnsafeIpsi_bad_02()\r\n{\r\n\t pstMeth = SSLv2_clientMethod();\r\n    if (SEC_NULL == pstMeth)\r\n    {\r\n        LOG_ERROR(\"Call SSL_method failed(err=%d).\", SSL_getLastError());\r\n        return SOAP_NULL_PTR;\r\n    }\r\n\r\n    SSL_CTX_S    *pstSslCtx = SEC_NULL;\r\n\t// 潜在缺陷:该函数的返回值是函数“SSL_ctxNew”的参数，并且它没有被函数“SSL_CTX_SET_OPTIONS”或“SL_SET_OPTIONS”禁用，\r\n\t// 因此它不安全。\r\n    pstSslCtx = SSL_ctxNew(pstMeth);\r\n}\r\n```",
        "修改建议": "禁止使用不安全IPSI算法检查，包括对称密码算法、非对称密码算法、哈希算法、消息认证码算法以及SSL/TLS配置协议版本和算法套件。\n建议使用安全的IPSI算法进行检查。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1240"
    },
    {
        "规则名称": "G.FMT.04-CPP 每个变量单独一行进行声明或赋值",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "check_multiple_var_dec:true",
        "正确示例": "```cpp\nint count = 10;\nbool isCompleted = false;\nint a = 0;\nint b = 0;\n\nint x;\nint y;\n...\nx = 1;\ny = 2;\n```",
        "错误示例": "```cpp\nint count = 10; bool isCompleted = false; // 不符合：多个变量初始化需要分开放在多行\n\nchar* str, ch, arr[10];                   // 不符合：多个变量定义且类型不同，容易产生误解\nint a = 0, b = 0;                         // 不符合：多个变量定义需要分开放在多行\n\nint x;\nint y;\n...\nx = 1; y = 2;                             // 不符合：一行中存在多个赋值语句\n```",
        "修改建议": "将语句拆分到多行。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "OAT.3 许可证头",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.MEM.01 内存申请前，必须对申请内存大小进行合法性校验【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：申请内存大小的变量可以明确值为0\r\n- 修复示例1：变量需要在使用前，判断值大于0，并小于一个符合业务预期的最大可申请内存值。\r\n\r\n```c++\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nint32_t GetZero()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid TestGoodCase01()\r\n{\r\n    int32_t size = GetZero();\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestGoodCase02()\r\n{\r\n    int32_t size = 0;\r\n    size++;\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestGoodCase03()\r\n{\r\n    int32_t size = 0;\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = new char[size];\r\n    ...\r\n    delete[] msg;\r\n}\r\n\r\nvoid TestGoodCase4()\r\n{\r\n    int32_t size = 0;\r\n    size++;\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = new char[size];\r\n    ...\r\n    delete[] msg;\r\n}\r\n```\r\n##### 场景2：申请内存大小的变量无法明确值为0时。\r\n\r\n本场景需在202209版本及以后需要模型中，配置checkSizeNotVerify项，开启enable=\"true\"，才会检查。\r\n在202206版本及以前会默认检查。\r\n- 修复示例1：变量需要在使用前，判断值大于0，并小于一个符合业务预期的最大可申请内存值。\r\n\r\n```c++\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nvoid TestGoodCase01(int32_t size)\r\n{\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestGoodCase02()\r\n{\r\n    int32_t size = (rand() - 1) * 1000;\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid FuncRet(int32_t *p);\r\n\r\n// 申请大小为入参引用\r\nvoid TestGoodCase03()\r\n{\r\n    int32_t size = 10;\r\n    FuncRet(&size);\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\n// 使用new申请内存未经校验\r\nvoid TestGoodCase04()\r\n{\r\n    int32_t size = 10;\r\n    FuncRet(&size);\r\n    // POTENTIAL FLAW GOOD: 申请的大小经过校验\r\n    if (size <= 0 || size > FOO_MAX_LEN) {\r\n        return;\r\n    }\r\n    char *msg = new char[size];\r\n    ...\r\n    delete[] msg;\r\n}\r\n```",
        "错误示例": "##### 场景1：申请内存大小的变量可以明确值为0\r\n- 错误示例：\r\n\r\n```c++\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nint32_t GetZero()\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid TestBadCase01()\r\n{\r\n    int32_t size = GetZero();\r\n    // POTENTIAL FLAW: 内存大小值一定为0\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestBadCase02()\r\n{\r\n    int32_t size = 0;\r\n    // POTENTIAL FLAW:  内存大小值一定为0\r\n    char *msg = (char *)malloc(size++);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestBadCase03()\r\n{\r\n    int32_t size = 0;\r\n    // POTENTIAL FLAW: 内存大小值一定为0\r\n    char *msg = new char[size];\r\n    ...\r\n    delete[] msg;\r\n}\r\n\r\nvoid TestBadCase4()\r\n{\r\n    int32_t size = 0;\r\n    // POTENTIAL FLAW: 内存大小值一定为0\r\n    char *msg = new char[size++];\r\n    ...\r\n    delete[] msg;\r\n}\r\n```\r\n##### 场景2：申请内存大小的变量无法明确值为0时。\r\n\r\n本场景需在202209版本及以后需要模型中，配置checkSizeNotVerify项，开启enable=\"true\"，才会检查。\r\n在202206版本及以前会默认检查。\r\n- 错误示例：\r\n\r\n```c++\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n\r\nvoid TestBadCase01(int32_t size)\r\n{\r\n    // POTENTIAL FLAW: 没有对内存大小变量的值进行校验\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid TestBadCase02()\r\n{\r\n    int32_t size = (rand() - 1) * 1000;\r\n    // POTENTIAL FLAW: 没有对内存大小变量的值进行校验\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\nvoid FuncRet(int32_t *p);\r\n\r\n// 申请大小为入参引用\r\nvoid TestBadCase03()\r\n{\r\n    int32_t size = 10;\r\n    FuncRet(&size);\r\n    // POTENTIAL FLAW: 没有对内存大小变量的值进行校验\r\n    char *msg = (char *)malloc(size);\r\n    if (msg == nullptr) {\r\n        return;\r\n    }\r\n    ...\r\n    free(msg);\r\n}\r\n\r\n// 使用new申请内存未经校验\r\nvoid TestBadCase04()\r\n{\r\n    int32_t size = 10;\r\n    FuncRet(&size);\r\n    // POTENTIAL FLAW: 没有对内存大小变量的值进行校验\r\n    char *msg = new char[size];\r\n    ...\r\n    delete[] msg;\r\n}\r\n```",
        "修改建议": "申请内存之前，对申请大小的变量做校验。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "789"
    },
    {
        "规则名称": "G.CLS.06-CPP 禁止在构造函数和析构函数中调用虚函数",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoreOnError:1",
        "正确示例": NaN,
        "错误示例": "如下代码中，在Base基类的构造函数中调用了Log虚函数。\n\n```cpp\nclass Base {\npublic:\n    Base();\n    virtual ~Base() = default;\n    virtual void Log();        // 不同的派生类调用不同的日志文件\n};\n\nBase::Base()                   // 基类构造函数\n{\n    Log();                     // 不符合：调用虚函数Log\n}\n\nclass Derived : public Base {\npublic:\n    void Log() override;\n};\n```\n\n当执行如下语句时，会先执行Derived的构造函数，但首先调用Base的构造函数，由于Base的构造函数调用虚函数Log，此时Log还是基类的版本，只有基类构造完成后，才会完成派生类的构造，从而导致未实现多态的行为。\n\n```cpp\nDerived d;\n```",
        "修改建议": "重构代码逻辑，避免安全隐患",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.14 ApnContext",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "OAT.6 冗余或未定义的LICENSE文件",
        "问题级别": "致命",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "oat",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.273 特供",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.310 车祸",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.EXP.36-CPP 控制表达式的结果应是布尔值",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": "IgnoredFuncs:__builtin_expect,__builtin_constant_p,__builtin_types_compatible_p;IgnoreOnError:1",
        "正确示例": "```cpp\nint value = ...\nif (value != 0) {       // 符合： 使用的是逻辑表达式\n    ...\n}\nwhile (true) {          // 特殊场景中可以使用布尔类型常量  \n    ...\n}\nchar* p = ...\nif (p != nullptr) {     // 符合\n    ...\n}\n```",
        "错误示例": "```cpp\nint value = ...\nif (value) {            // 不符合： 不是布尔类型变量\n    ...\n}\n```",
        "修改建议": " - 变量类型修改为bool类型\n - 或者条件表达式使用比较操作符",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1024"
    },
    {
        "规则名称": "WordsTool.81 EMUI",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.275 质量免检",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "冗余代码[C++]",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "cmetrics",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1041"
    },
    {
        "规则名称": "G.EXP.37-CPP switch语句要有default分支--没有default分支",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：没有default分支\r\n- 修复示例：\r\n\r\n```cpp\r\nswitch (paraName) {\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n    default: // 符合：增加default分支并放在switch语句块的最后位置\r\n        break;\r\n}\r\n```",
        "错误示例": "##### 场景1：没有default分支\r\n- 错误示例：\r\n\r\n```cpp\r\nswitch (paraName) { // 不符合：没有default分支\r\n    case TIMEOUT_VALUE:\r\n        ...\r\n        break;\r\n    case CACHE_NUM:\r\n        ...\r\n        break;\r\n}\r\n```",
        "修改建议": "添加default分支，或者将default分支移到最后",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "478"
    },
    {
        "规则名称": "G.INC.10-CPP 不要在头文件中使用匿名namespace或static定义非外部可见符号",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在头文件中使用匿名namespace定义非外部可见符号\r\n- 修复示例：\r\n```cpp\r\n// Counter.h\r\n\r\n// 符合：没有使用匿名namespace\r\n...\r\n\r\n// Counter.cpp\r\nnamespace { // 符合：如果是非外部可见符号，可在cpp文件中使用匿名namespace封装或者使用static修饰\r\nint g_counter = 0;\r\nvoid DoCount() { g_counter++; }\r\n}\r\n```\r\n##### 场景2：在头文件中使用static定义非外部可见符号\r\n- 修复示例：\r\n\r\n```cpp\r\n// Counter.h\r\n\r\n// 符合：没有使用static\r\n...\r\n\r\n// Counter.cpp\r\nstatic int g_num = 0;       // 符合：如果是非外部可见符号，可在cpp文件中使用匿名namespace封装或者使用static修饰\r\nstatic inline void Add()    // 符合：如果是非外部可见符号，可在cpp文件中使用匿名namespace封装或者使用static修饰\r\n{\r\n    g_num++;\r\n}\r\n```",
        "错误示例": "##### 场景1：在头文件中使用匿名namespace定义非外部可见符号\r\n- 错误示例：\r\n\r\n```cpp\r\n// Counter.h\r\nnamespace { // 不符合：在头文件中的匿名namespace\r\nint g_counter = 0;\r\nvoid DoCount() { g_counter++; }\r\n}\r\n```\r\n##### 场景2：在头文件中使用static定义非外部可见符号\r\n- 错误示例：\r\n\r\n```cpp\r\n// Counter.h\r\nstatic int g_num = 0;       // 不符合：在头文件中使用static定义变量\r\nstatic inline void Add()    // 不符合：在头文件中使用static定义函数\r\n{\r\n    g_num++;\r\n}\r\n```",
        "修改建议": "不要在头文件中使用匿名namespace或static定义非外部可见符号，如果在cpp文件中使用匿名namespace或static，具体参考[G.INC.12-CPP 对于cpp文件中不需要导出的变量、常量或函数，应使用匿名namespace封装或者使用static修饰]。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "G.EXP.41-CPP 避免在基本for循环的循环体中修改循环控制变量",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```cpp\nfor (int i = 0; i < MAX_COUNT; ++i) {\n    std::cout << i;                         // 符合：没有修改控制变量i\n}\n```",
        "错误示例": "```cpp\nfor (int i = 0; i < MAX_COUNT; ++i) {\n    if (i > specialValue) {\n        ++i;                                // 不符合：修改了控制变量i\n    }\n    std::cout << i;\n}\n```",
        "修改建议": "尽量将对循环变量的修改放在for语句中",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1095"
    },
    {
        "规则名称": "WordsTool.77 doze",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.OTH.05 禁止代码中包含公网地址【C】",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "codemars",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：代码中硬编码Ipv4公网地址\r\n- 修复示例：通过配置文件获取公网地址，注意配置文件的使用权限管理\r\n\r\n```cpp\r\nvoid IPHardCodeGood01()\r\n{\r\n    const char *ip = GetIPFromConfigFile(); // 符合\r\n    printf(\"%s\", ip);\r\n}\r\n```\r\n##### 场景2：代码中硬编码Ipv6公网地址\r\n- 修复示例：通过配置文件获取公网地址，注意配置文件的使用权限管理\r\n\r\n```cpp\r\nvoid IPHardCodeGood02()\r\n{\r\n    const char *ip = GetIPFromConfigFile(); // 符合\r\n    printf(\"%s\", ip);\r\n}\r\n```",
        "错误示例": "##### 场景1：代码中硬编码Ipv4公网地址\r\n- 错误示例：变量`ip`使用Ipv4公网地址赋值\r\n\r\n```cpp\r\nvoid IPHardCodeBad01()\r\n{\r\n    /* POTENTIAL FLAW: 禁止使用Ipv4公网IP */\r\n    const char *ip = \"189.179.169.159\";\r\n    printf(\"%s\", ip);\r\n}\r\n```\r\n##### 场景2：代码中硬编码Ipv6公网地址\r\n- 错误示例：变量`ip`使用Ipv6公网地址赋值\r\n\r\n```cpp\r\nvoid IPHardCodeBad02()\r\n{\r\n    /* POTENTIAL FLAW: 禁止使用Ipv6公网IP */\r\n    const char *ip = \"fa80:0:0:ec61:c1d1:9827:82be:3\";\r\n    printf(\"%s\", ip);\r\n}\r\n```",
        "修改建议": "宏定义中、变量赋值中、特定函数（*strcmp、*strncmp、*memcmp）中禁止使用硬编码公网IP。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "547"
    },
    {
        "规则名称": "WordsTool.135 MLKit",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.CLS.12-CPP 在重写虚函数时应明确指定override或final",
        "问题级别": "严重",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "clangtidy",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "##### 场景1：在派生类重写虚函数时未指定`override`或`final`\r\n- 修复示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() {}\r\n    virtual void Foo();\r\n    virtual void Bar();\r\n};\r\n\r\nclass SimpleCases : public Base {\r\npublic:\r\n    ~SimpleCases() override; // 符合\r\n    void Foo() override;     // 符合：override保证SimpleCases的派生类可以再重写此函数\r\n    void Bar() final;        // 符合：final保证SimpleCases的派生类不能再重写此函数\r\n};\r\n```\r\n##### 场景2：在派生类重写虚函数时增加多余的`virtual`\r\n- 修复示例：在派生类重写虚函数时，无需再添加`virtual`关键字。\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() {}\r\n    virtual void Foo();\r\n};\r\n\r\nclass SimpleCases : public Base {\r\npublic:\r\n    ~SimpleCases() override;            // 符合：无需再添加`virtual`\r\n    void Foo() override;                // 符合：无需再添加`virtual`\r\n};\r\n```",
        "错误示例": "##### 场景1：在派生类重写虚函数时未指定`override`或`final`\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() {}\r\n    virtual void Foo();\r\n    virtual void Bar();\r\n};\r\n\r\nclass SimpleCases : public Base {\r\npublic:\r\n    virtual ~SimpleCases(); // 不符合：未指定`override`或`final`\r\n    void Foo();             // 不符合：未指定`override`或`final`\r\n    void Bar();             // 不符合：未指定`override`或`final`\r\n};\r\n```\r\n##### 场景2：在派生类重写虚函数时增加多余的`virtual`\r\n- 错误示例：\r\n\r\n```cpp\r\nclass Base {\r\npublic:\r\n    virtual ~Base() {}\r\n    virtual void Foo();\r\n};\r\n\r\nclass SimpleCases : public Base {\r\npublic:\r\n    virtual ~SimpleCases() override;    // 不符合：多余的`virtual`\r\n    virtual void Foo() override;        // 不符合：多余的`virtual`\r\n};\r\n```",
        "修改建议": "在派生类重写虚函数时：\r\n1. 无需再添加`virtual`关键字。\r\n2. 明确指定`override`或`final`。\r\n    - `override` 表示重写了基类中的虚函数，可以再被派生类重写\r\n    - `final`    表示重写了基类中的虚函数，不能再被派生类重写",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1076"
    },
    {
        "规则名称": "WordsTool.253 大牌",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.95 Google",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "WordsTool.50 ConnectionService",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "wordstool",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": NaN,
        "错误示例": NaN,
        "修改建议": NaN,
        "样例": NaN,
        "链接": NaN,
        "CWE信息": NaN
    },
    {
        "规则名称": "G.PRE.06 函数式宏要简短【C】",
        "问题级别": "一般",
        "支持的工具版本": 202306,
        "语言": "C++",
        "标签": "fixbotengine-cxx",
        "适用范围": "版本级,门禁级",
        "延迟开始时间": NaN,
        "延迟截止时间": NaN,
        "选项": NaN,
        "正确示例": "```c\r\n// 符合: 将函数式宏改为函数\r\nvoid BubbleSort(int arr[], int n)\r\n{\r\n    int i, j;\r\n    for (i = 0; i < n - 1; i++) {\r\n        for (j = 0; j < n - i - 1; j++) {\r\n            if (arr[j] > arr[j + 1]) {\r\n                int temp = arr[j];\r\n                arr[j] = arr[j + 1];\r\n                arr[j + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n```",
        "错误示例": "```c\r\n// 不符合: 函数式宏超过10行\r\n#define BUBBLESORT(arr, n)                \\\r\n    int i, j;                             \\\r\n    for (i = 0; i < n - 1; i++) {         \\\r\n        for (j = 0; j < n - i - 1; j++) { \\\r\n            if (arr[j] > arr[j + 1]) {    \\\r\n                int temp = arr[j];        \\\r\n                arr[j] = arr[j + 1];      \\\r\n                arr[j + 1] = temp;        \\\r\n            }                             \\\r\n        }                                 \\\r\n    }\r\n```",
        "修改建议": "如果函数式宏超过10行，建议使用函数代替，请参考[G.PRE.01 使用函数代替函数式宏]。",
        "样例": NaN,
        "链接": NaN,
        "CWE信息": "1080"
    }
]