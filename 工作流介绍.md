# HarmoCheck 项目工作流介绍

## 项目概述

HarmoCheck 是一个基于 mini-swe-agent 的代码质量检查与修复工具，专门用于处理 OpenHarmony 项目的代码质量问题。该项目使用 AI 代理（Agent）自动分析代码并修复违反编码规范的问题。

## 核心架构

项目采用 **Agent-Environment-Model** 三层架构：

- **Agent（代理）**：负责决策和执行流程控制
- **Environment（环境）**：提供代码执行环境（本地文件系统）
- **Model（模型）**：提供 AI 能力（支持 OpenAI 兼容的模型）

## 主要工作流程

### 1. 数据准备阶段

#### 1.1 问题数据加载

项目支持从多种格式加载代码质量问题：

- **Excel 格式**（`.xlsx`）：从 OpenHarmony 数字协作平台导出的问题列表
- **JSON/JS 格式**（`.js` 或 `.json`）：转换后的结构化问题数据

```python
# 自动转换流程
ISSUE_DESP.xlsx → convert_xlsx_to_json() → ISSUE_DESP.js
```

每个问题包含以下信息：
- 文件路径
- 代码行号
- 规范规则 ID
- 缺陷描述
- 问题级别（严重程度）
- 代码内容

#### 1.2 项目目录准备

- **备份原始代码**：自动备份到 `~/tmp/harmocheck/` 目录
- **创建工作目录**：为每个项目创建独立的工作目录
- **复制项目文件**：将项目代码复制到工作目录进行修改

### 2. 问题处理阶段

#### 2.1 单问题处理流程（harmocheck 命令）

```
用户输入
  ↓
加载问题文件（ISSUE_DESP.xlsx/js）
  ↓
创建问题实例（Instance）
  ↓
备份源代码
  ↓
初始化 Agent
  ↓
格式化问题描述
  ↓
Agent 执行修复
  ↓
保存轨迹文件（Trajectory）
```

**关键步骤详解：**

1. **问题格式化**
   ```python
   format_openharmony_issue(instance)
   ```
   将问题信息格式化为 Agent 可理解的任务描述，包括：
   - 项目名称
   - 文件路径和行号
   - 编码规范规则
   - 问题描述
   - 修复要求

2. **Agent 初始化**
   - 加载配置文件（`openharmony.yaml`）
   - 初始化模型（支持多种 AI 模型）
   - 创建本地执行环境
   - 设置工作目录

3. **Agent 执行循环**
   ```
   while not finished:
       1. Agent 分析问题（调用 Model）
       2. Model 返回修复方案（包含 bash 命令）
       3. Agent 解析命令
       4. Environment 执行命令
       5. 返回执行结果
       6. 更新对话历史
   ```

#### 2.2 Agent 执行机制

**DefaultAgent 核心循环：**

```python
def run(self, task: str):
    # 1. 初始化消息
    self.add_message("system", system_template)
    self.add_message("user", instance_template)
    
    # 2. 执行循环
    while True:
        try:
            self.step()  # 执行一步
        except NonTerminatingException:
            # 继续执行（格式错误、超时等）
            continue
        except TerminatingException:
            # 终止执行（完成、达到限制等）
            return exit_status, result
```

**单步执行（step）流程：**

```python
def step(self):
    # 1. 查询模型
    response = self.model.query(self.messages)
    
    # 2. 解析动作
    action = self.parse_action(response)  # 提取 bash 命令
    
    # 3. 执行动作
    output = self.env.execute(action["action"])
    
    # 4. 渲染观察结果
    observation = self.render_template(template, output=output)
    
    # 5. 添加到消息历史
    self.add_message("user", observation)
    
    # 6. 检查是否完成
    if output contains "COMPLETE_TASK_AND_SUBMIT_FINAL_OUTPUT":
        raise Submitted()
```

#### 2.3 静态代码分析模式

项目专门针对**静态代码分析**进行了优化：

- **只读取和修改代码文件**
- **不执行代码或运行测试**
- **不创建验证脚本**

Agent 的典型操作序列：
1. 读取问题文件：`cat filename.c`
2. 查看特定行：`nl -ba filename.c | sed -n '250,270p'`
3. 搜索模式：`grep -n "pattern" filename.c`
4. 修改文件：`sed -i 's/old_string/new_string/' filename.c`
5. 验证修改：再次读取文件确认

### 3. 批量处理阶段

#### 3.1 并行处理架构

项目采用 **线程池（ThreadPoolExecutor）** 实现多线程并行处理，可以同时处理多个代码质量问题，大幅提升处理效率。

##### 3.1.1 线程池初始化

```python
# 创建线程池，workers 参数控制并发线程数
with ThreadPoolExecutor(max_workers=workers) as executor:
    # 提交所有任务到线程池
    futures = {
        executor.submit(process_issue, instance, config, progress_manager, 
                        input_dir, traj_subdir): instance["instance_id"]
        for instance in instances
    }
```

**关键机制：**
- **线程池大小**：通过 `workers` 参数控制（默认 1，建议 3-10）
- **任务提交**：使用 `executor.submit()` 异步提交任务，立即返回 `Future` 对象
- **Future 映射**：建立 `Future` 对象与 `instance_id` 的映射关系，便于跟踪和错误处理

##### 3.1.2 Future 对象管理

`Future` 对象代表一个异步执行的任务，提供了任务状态查询和结果获取的能力：

```python
def process_futures(futures: dict[concurrent.futures.Future, str]):
    """处理所有 Future 对象，等待任务完成并处理结果"""
    for future in concurrent.futures.as_completed(futures):
        try:
            # 获取任务执行结果（会阻塞直到任务完成）
            future.result()
        except concurrent.futures.CancelledError:
            # 任务被取消（用户中断）
            pass
        except Exception as e:
            # 任务执行出错
            instance_id = futures[future]
            logger.error(f"Error in future for instance {instance_id}: {e}")
            progress_manager.on_uncaught_exception(instance_id, e)
```

**执行流程：**
1. **as_completed()**：返回一个迭代器，按完成顺序（而非提交顺序）返回 Future
2. **阻塞等待**：`future.result()` 会阻塞直到任务完成
3. **异常处理**：捕获并记录每个任务的异常，不影响其他任务

##### 3.1.3 进度跟踪系统

项目使用 `RunBatchProgressManager` 实现实时进度跟踪，基于 Rich 库提供美观的终端界面：

**进度管理器初始化：**
```python
progress_manager = RunBatchProgressManager(
    num_instances=len(instances),  # 总任务数
    yaml_report_path=None  # 可选：保存报告路径
)
```

**三层进度显示：**

1. **总体进度条**（Main Progress Bar）
   - 显示已完成/总任务数
   - 显示总 API 调用次数（成本统计）
   - 显示已用时间和预计剩余时间（ETA）
   - 自动计算处理速度

2. **任务进度条**（Task Progress Bar）
   - 每个问题一个独立的进度项
   - 显示实例 ID（缩短显示）
   - 显示当前状态（如 "Step 15"、"Starting..."）
   - 显示该任务的已用时间

3. **状态统计表**（Exit Status Table）
   - 按退出状态分组统计
   - 显示每种状态的数量
   - 显示最近完成的实例列表

**实时更新机制：**

```python
# 在 Agent 的每个 step 中更新状态
def step(self) -> dict:
    self.progress_manager.update_instance_status(
        self.instance_id, f"Step {self.model.n_calls + 1:3d}"
    )
    return super().step()
```

**状态更新流程：**
- `on_instance_start()`：任务开始时创建进度项
- `update_instance_status()`：实时更新任务状态（每步更新）
- `on_instance_end()`：任务结束时移除进度项，更新统计

**线程安全：**
- 使用 `Lock` 保护共享状态
- 所有更新操作都在锁保护下进行
- 确保多线程环境下的数据一致性

##### 3.1.4 错误处理机制

**分层错误处理：**

1. **任务级错误**：在 `process_issue()` 函数内部捕获
   ```python
   try:
       exit_status, result = agent.run(task)
   except Exception as e:
       exit_status, result = type(e).__name__, str(e)
       extra_info = {"traceback": traceback.format_exc()}
   ```

2. **Future 级错误**：在 `process_futures()` 中捕获
   ```python
   except Exception as e:
       instance_id = futures[future]
       progress_manager.on_uncaught_exception(instance_id, e)
   ```

3. **错误记录**：
   - 所有错误都会记录到轨迹文件
   - 错误信息包含完整的 traceback
   - 进度管理器会统计错误类型和数量

##### 3.1.5 中断处理（KeyboardInterrupt）

支持优雅的中断处理，用户可以随时按 `Ctrl+C` 中断：

```python
try:
    process_futures(futures)
except KeyboardInterrupt:
    logger.info("Cancelling all pending jobs. Press ^C again to exit immediately.")
    # 取消所有未运行的任务
    for future in futures:
        if not future.running() and not future.done():
            future.cancel()
    # 等待正在运行的任务完成
    process_futures(futures)
```

**中断行为：**
- **第一次 Ctrl+C**：取消所有未开始的任务，等待正在运行的任务完成
- **第二次 Ctrl+C**：强制退出（Python 默认行为）
- **已完成任务**：结果已保存，不受影响

##### 3.1.6 实时界面更新

使用 Rich 库的 `Live` 组件实现实时界面刷新：

```python
with Live(progress_manager.render_group, refresh_per_second=4):
    # 在 Live 上下文中，界面每 0.25 秒自动刷新一次
    with ThreadPoolExecutor(max_workers=workers) as executor:
        # ... 执行任务
```

**界面特性：**
- **自动刷新**：每秒刷新 4 次，确保状态实时显示
- **非阻塞**：不影响任务执行性能
- **美观显示**：使用颜色、进度条、表格等元素

#### 3.2 三种处理模式

1. **单实例模式**（`openharmony-single`）【很久没维护了】
   - 用于测试和调试
   - 处理单个问题
   - 交互式执行

2. **批量模式**（`openharmony-batch`）【很久没维护了】
   - 用于测试和调试
   - 处理指定范围的问题
   - 支持并行处理
   - 示例：`-i 0:10` 处理前 10 个问题

3. **全自动模式**（`openharmony`）
   - 自动发现所有项目
   - 处理所有问题
   - 完全自动化

### 4. 结果保存阶段

#### 4.1 轨迹文件（Trajectory）

每个问题的处理过程都会保存为轨迹文件：

- **位置**：`~/.local/share/harmocheck/trajectories/{timestamp}_{project}/`
- **格式**：JSON 格式（`.traj.json`）
- **内容**：
  - 完整的对话历史
  - 执行的命令序列
  - 执行结果
  - 退出状态
  - 错误信息（如果有）

#### 4.2 修改后的代码

- **直接修改**：代码在工作目录中被直接修改
- **原始备份**：原始代码已备份到 `~/tmp/harmocheck/`
- **可追溯**：通过轨迹文件可以查看所有修改历史

## 配置系统

### 配置文件结构

项目使用 YAML 配置文件定义 Agent 行为：

```yaml
agent:
  system_template: |  # 系统提示词
    You are a code quality expert...
  instance_template: |  # 任务模板
    <issue_description>
    {{task}}
    </issue_description>
  step_limit: 100  # 最大步数限制

environment:
  timeout: 30  # 命令超时时间
  cwd: /path/to/working/dir  # 工作目录

model:
  model_name: "deepseek-v3.2-exp"
  model_class: "openai_compatible"
```

### 模型配置

支持多种 AI 模型（需 OpenAI 兼容 API）：

- DeepSeek 系列
- Claude 系列
- 其他 OpenAI 兼容模型

配置位置：`config/models.yaml`

## 使用示例

### 基本用法

```bash
# 处理单个项目的所有问题
harmocheck \
  -i ./dataset1/openharmony/test/vendor_telink \
  -d ./dataset1/openharmony/ISSUE_DESP.xlsx \
  -w 5 \
  -m deepseek-v3.2-exp
```

### 参数说明

- `-i, --input`：包含代码的目录（将被修改）
- `-d, --defects`：问题描述文件（.xlsx 或 .js）
- `-w, --workers`：并行工作线程数
- `-m, --model`：使用的 AI 模型
- `--issue`：只处理指定索引的问题（可选）

## 工作流总结

```
┌─────────────────┐
│  问题数据加载    │ ← ISSUE_DESP.xlsx/js
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  项目目录准备    │ ← 备份 + 创建工作目录
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Agent 初始化    │ ← 模型 + 环境 + 配置
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  问题格式化      │ ← 生成任务描述
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Agent 执行循环  │ ← 分析 → 执行 → 观察
│                 │
│  while not done: │
│    1. 查询模型   │
│    2. 解析命令   │
│    3. 执行命令   │
│    4. 更新状态   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  结果保存        │ ← 轨迹文件 + 修改后的代码
└─────────────────┘
```


